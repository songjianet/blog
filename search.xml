<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>15种CSS居中方式</title>
    <url>/blog/2018/04/12/15%E7%A7%8DCSS%E5%B1%85%E4%B8%AD%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>最近由于公司的业务过于繁忙，一段时间前总结的一篇关于CSS居中的文档一直没有上传到服务器，今天对此文档稍作修改，并且部署服务器，以供大家查看。</p>
<p>很多人会觉得一个居中的方式，很简单啊，行内元素就用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">text-align: center</code>，块级元素就用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">margin: 0 auto;</code>。其实不然，单单是这两个样式就能演变出很多种的居中方式。为此，我总结出十五种的居中方式供大家参考，如果有没有想到的，大家可以留言我的邮箱：<a href="mailto:1778651752@qq.com">1778651752@qq.com</a>。</p>
<h5 id="1-内联元素水平居中"><a href="#1-内联元素水平居中" class="headerlink" title="1.内联元素水平居中"></a>1.内联元素水平居中</h5><p>利用 <code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">text-align: center </code>可以实现在块级元素内部的内联元素水平居中。此方法对内联元素(inline)，内联块(inline-block)，内联表(inline-table)，(inline-flex)元素水平居中都有效。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center-text</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-块级元素水平居中"><a href="#2-块级元素水平居中" class="headerlink" title="2.块级元素水平居中"></a>2.块级元素水平居中</h5><p>通过把固定宽度块级元素的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">margin-left</code>和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">margin-right</code>设成<code style="letter-spacing:2px;font-weight:700;background-color:#e6effb;border-radius:3px;">auto</code>，就可以使块级元素水平居中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center-block</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-多级块元素水平居中"><a href="#3-多级块元素水平居中" class="headerlink" title="3.多级块元素水平居中"></a>3.多级块元素水平居中</h5><p>如果一行中有两个或两个以上的块级元素，通过设置块级元素的显示类型为<code style="letter-spacing:2px;font-weight:700;background-color:#e6effb;border-radius:3px;">inline-block</code>和父容器的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">text-align</code>属性从而使多块级元素水平居中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inline-block</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-利用display-flex"><a href="#4-利用display-flex" class="headerlink" title="4.利用display: flex"></a>4.利用display: flex</h5><p>利用弹性布局(flex)，实现水平居中，其中<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">justify-content</code>用于设置弹性盒子元素在主轴（横轴）方向上的对齐方式，本例中设置子元素水平居中显示。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex-center</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-单行内联元素垂直居中"><a href="#5-单行内联元素垂直居中" class="headerlink" title="5.单行内联元素垂直居中"></a>5.单行内联元素垂直居中</h5><p>通过设置内联元素的高度<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">height</code>和行高<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">line-height</code>相等，从而使元素垂直居中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.v-box</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">120px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-利用表格布局的多行元素垂直居中"><a href="#6-利用表格布局的多行元素垂直居中" class="headerlink" title="6.利用表格布局的多行元素垂直居中"></a>6.利用表格布局的多行元素垂直居中</h5><p>利用表布局的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vertical-align: middle</code>可以实现子元素的垂直居中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center-table</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.v-cell</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-利用flex布局的多行元素垂直居中"><a href="#7-利用flex布局的多行元素垂直居中" class="headerlink" title="7.利用flex布局的多行元素垂直居中"></a>7.利用flex布局的多行元素垂直居中</h5><p>利用 flex 布局实现垂直居中，其中<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">flex-direction: column</code>定义主轴方向为纵向。因为 flex 布局是 CSS3 中定义，在较老的浏览器存在兼容性问题。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.center-flex</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-利用“精灵元素”"><a href="#8-利用“精灵元素”" class="headerlink" title="8.利用“精灵元素”"></a>8.利用“精灵元素”</h5><p>利用“精灵元素”(ghost element)技术实现垂直居中，即在父容器内放一个 100%高度的伪元素，让文本和伪元素垂直对齐，从而达到垂直居中的目的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.ghost-center</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ghost-center</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">" "</span>;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1%</span>;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ghost-center</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-固定高度的块级元素垂直居中"><a href="#9-固定高度的块级元素垂直居中" class="headerlink" title="9.固定高度的块级元素垂直居中"></a>9.固定高度的块级元素垂直居中</h5><p>我们知道居中元素的高度和宽度，垂直居中问题就很简单。通过绝对定位元素距离顶部 50%，并设置<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">margin-top</code>向上偏移元素高度的一半，就可以实现垂直居中了。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-未知高度的块元素垂直居中"><a href="#10-未知高度的块元素垂直居中" class="headerlink" title="10.未知高度的块元素垂直居中"></a>10.未知高度的块元素垂直居中</h5><p>当垂直居中的元素的高度和宽度未知时，我们可以借助 CSS3 中的<code style="letter-spacing:2px;font-weight:700;background-color:#e6effb;border-radius:3px;">transform</code>属性向 Y 轴反向偏移 50%的方法实现垂直居中。但是部分浏览器存在兼容性的问题。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-固定宽高元素水平垂直居中"><a href="#11-固定宽高元素水平垂直居中" class="headerlink" title="11.固定宽高元素水平垂直居中"></a>11.固定宽高元素水平垂直居中</h5><p>通过<code style="letter-spacing:2px;font-weight:700;background-color:#e6effb;border-radius:3px;">margin</code>平移元素整体宽度的一半，使元素水平垂直居中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin</span>: -<span class="number">70px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">170px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-未知宽高元素水平垂直居中"><a href="#12-未知宽高元素水平垂直居中" class="headerlink" title="12.未知宽高元素水平垂直居中"></a>12.未知宽高元素水平垂直居中</h5><p>利用 2D 变换，在水平和垂直两个方向都向反向平移宽高的一半，从而使元素水平垂直居中。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="13-利用flex布局水平垂直居中"><a href="#13-利用flex布局水平垂直居中" class="headerlink" title="13.利用flex布局水平垂直居中"></a>13.利用flex布局水平垂直居中</h5><p>利用 flex 布局，其中<code style="letter-spacing:2px;font-weight:700;background-color:#e6effb;border-radius:3px;">justify-content</code>用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式；而<code style="letter-spacing:2px;font-weight:700;background-color:#e6effb;border-radius:3px;">align-items</code>属性定义 flex 子项在 flex 容器的当前行的侧轴（纵轴）方向上的对齐方式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="14-利用grid布局水平垂直居中"><a href="#14-利用grid布局水平垂直居中" class="headerlink" title="14.利用grid布局水平垂直居中"></a>14.利用grid布局水平垂直居中</h5><p>利用 grid 实现水平垂直居中，兼容性较差，不推荐。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">140px</span>;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123; </span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="15-屏幕上水平垂直居中"><a href="#15-屏幕上水平垂直居中" class="headerlink" title="15.屏幕上水平垂直居中"></a>15.屏幕上水平垂直居中</h5><p>屏幕上水平垂直居中十分常用，常规的登录及注册页面都需要用到。要保证较好的兼容性，还需要用到表布局。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.outer</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inner</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: auto;</span><br><span class="line">    <span class="attribute">margin-right</span>: auto; </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>22岁我在想什么（工作）</title>
    <url>/blog/2018/02/06/22%E5%B2%81%E6%88%91%E5%9C%A8%E6%83%B3%E4%BB%80%E4%B9%88%EF%BC%88%E5%B7%A5%E4%BD%9C%EF%BC%89/</url>
    <content><![CDATA[<br>

<div style="width:330px;height:86px;margin:0 auto;"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=293852&auto=1&height=66"></iframe></div>

<br>

<p>我22岁也就是2017年，这一年我毕业下来参加工作，也顺利地进入了码农的行业。我对这个工作有很大的热爱之情。能够从事这份工作也是对我的综合能力的一个提升，比如细心程度、耐心与责任心等都一个不断提高的过程。在我上大学的最后一个学期，也曾经想过以后要做什么，甚至考虑到了毕业之后帮家里搞装修。</p>
<p>7月10号签订了试用劳动合同，留在了沈阳。沈阳对我来说算是比较熟悉的一个城市了，毕竟大学在沈阳。在毕业的时候，也就很顺利凭借一些前端的能力被举荐到了学校的公司（我的学校和公司是在一个园区内，我的几个同学也留在了我们学校的公司），开始了为期四个月的试用期，直到12月1日我变成了这个公司的一名正式的小码农。</p>
<p>公司是个外包公司（最近一直想转型，推出自己的产品，公司的IT方向涉及还是很多的，但是主要以web开发、移动端开发为主导），硬件环境条件还是不错的，而同事的技术水平和道德品质一样的参差不齐（我不想过多评价一个人，可能我在一些方面还不如他）。就在前几天，一位同事的离职也是让我感到有些失落（原因是：当初身为后端小白的我，他确实帮助了我不少，虽然技术不算太高，不过人很好），在这里我也只能祝福他以后在别的公司好好工作，不断提高自己的技术水平。</p>
<p>在工作中，我凭借着还算精通的html和css帮助公司把网站的响应式效果和界面风格提升了不止一个档次。同样在十一长假回来我们公司有很多的项目，几乎天天加班写代码，也就是大概从这时候开始，我开始真正的上手去写后端逻辑思维，事务的处理，也对MySQL、Oracle、ssm等后端的一些只是有了基本的了解，也很感谢当初一直带着我从零开始做项目的各位同事。也正是为此，我得到了领导的认可，可能是觉得我的学习能力还不错、底子比较好外加能够帮助他们提高页面的显示效果（这个公司以前竟然不会做响应式，公司的技术还是比较落后的，可能是当初没有抓住转型机会）。在十一之后，我也参加了很多的项目，为此我的后端能力以及jQuery的技术水平确实有些提高，不过我的前台技术（仅限于html和css）还是没有任何提高，可能是他们需要的前台我都能够应付得来，外加项目紧（能够一直有项目做的外包公司也算是不错的了），我在公司和个人时间里也一直没有时间去学习提高我的前端技术水平（看来离我的全栈工程师梦想还是很遥远的）。</p>
<p>针对现有公司的技术水平而言，我一直想发挥我的特长，我想带他们使用SCSS、vue技术，但是由于公司一直做外包也没有时间给我们去研究。提到研究不得不说当初领导认识到了虚拟机反向代理挂应用程序太慢了，还会耗费更多的服务器硬件资源，所以让我去研究集群的容器化部署——docker（只是我一个人研究到了最后，过程中也算是零零星星来了一两个人，但都因为某些原因走了）。而在公司领导准备让我普及给各个员工的时候，因为我的提议而终止了这次公司三大部门的学习计划。有人好奇为什么我要终止这次学习计划，原因有几点：1.学习成本大；2.项目时间紧；3.服务器资源不够（虽然公司有几百台服务器，但都正在跑项目）。</p>
<p>总的来讲，作为一名刚刚毕业的学生，能有一个工作还是可以的。没有去培训机构，也没有低到去做没有五险一金的工作。今后的三年，也是我要不断积累的三年。这个博客同样也会见证我的技术成长之路，同样我也会不断完善我的博客，在后期可能会增加评论功能等。</p>
]]></content>
      <categories>
        <category>About Me</category>
      </categories>
  </entry>
  <entry>
    <title>Ajax异步导致window.open被拦截的问题</title>
    <url>/blog/2018/05/04/Ajax%E5%BC%82%E6%AD%A5%E5%AF%BC%E8%87%B4window.open%E8%A2%AB%E6%8B%A6%E6%88%AA%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h5 id="问题介绍"><a href="#问题介绍" class="headerlink" title="问题介绍"></a>问题介绍</h5><p>这个问题的出现最根本的原因就是网页中的广告，让我在开发中耽误了半天的时间去找为什么异步成功回调后window.open()会被拦截。现在很多页面的广告都是通过Ajax异步成功的方式跳转到一个广告的页面，所以例如谷歌浏览器，火狐浏览器等很多浏览器就会为自身安全性增加对异步跳转的拦截（注：360浏览器暂时还没有对这个功能的拦截）。首先，先让大家看看代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addlogs</span> (<span class="params">url, module_name, title</span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">"post"</span>,</span><br><span class="line">        url: $(<span class="string">"#ctx"</span>).val() + <span class="string">"/addlogs"</span>,</span><br><span class="line">        data: &#123;<span class="attr">url</span>:url,module_name,title&#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> success = result.success;</span><br><span class="line">            <span class="keyword">if</span>(success)&#123;</span><br><span class="line">                <span class="built_in">window</span>.open(url); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的这段代码是增加信息点击数量的功能，这个代码在Ajax成功后进行了页面打开的操作，就是因为这个操作一些浏览器会认为打开的这个页面是广告，所以就被拦截了。我在网上找了半天时间也没有发现什么有用的方法，有说加定时器等等，经过我的尝试都没有解决我的问题，可能是开发情况不一样导致的。最后看到了浏览器装的屏蔽广告的插件突发奇想，百度了一下屏蔽广告插件的原理，为此尝试将Ajax改成同步请求，结果成功了</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span>: <span class="literal">false</span>,</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>jQuery</tag>
        <tag>window.open()</tag>
      </tags>
  </entry>
  <entry>
    <title>bpmn工作流简述</title>
    <url>/blog/2020/11/09/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><p><code>BPMN</code>全称为<code>Business Process Modeling Notation</code>，它是由业务流程管理倡议组织<code>BPMI</code>全称<code>The Business Process Management Initiative</code>开发的一套标准的业务流程建模符号规范。</p>
</li>
<li><p><code>BPMN</code>为用户提供一套容易理解的标准符号，这些符号作为<code>BPMN</code>的基础元素，将业务流程建模简单化、图形化，将复杂的建模过程视觉化，让业务建模者、业务实施人员、管理监督人员对<code>BPMN</code>描述的业务流程都有一个更加清晰明了的了解。</p>
</li>
<li><p><code>BPMN</code>允许开发者在现有的标准符号基础上自定义一些符合业务逻辑的元素，让使用者可以不去学习<code>BPMN</code>的流程图的绘制方式，以更简洁的元素展示给使用者。</p>
</li>
<li><p>如果使用<code>BPMN</code>自定义一些元素，则开发人员会有一定的负担，但是使用者会得到一个比较好的体验。</p>
</li>
</ul>
<hr>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><ul>
<li><p><code>Render</code>: 承载绘制流程的画布容器。</p>
</li>
<li><p><code>Viewer</code>: 流程查看器，功能最简单，仅用来展示。</p>
</li>
<li><p><code>NavigatedViewer</code>: 包含鼠标导航工具的图表查看器，在<code>Viewer</code>上扩展了导航和缩放功能。</p>
</li>
<li><p><code>Modeler</code>: 流程编辑器，融合了<code>Viewer</code>和<code>NavigatedViewer</code>。并拥有工具栏、属性面板等，实现建模能力。</p>
</li>
<li><p><code>Palette</code>: 指代左侧工具栏。</p>
</li>
<li><p><code>Shape</code>: 左侧工具栏中的每一个节点。</p>
</li>
<li><p><code>Connection</code>: 连接线节点。</p>
</li>
<li><p><code>Context-Pad</code>: 节点拖拽到<code>Render</code>中后，点击节点右侧出现的菜单。</p>
</li>
<li><p><code>Properties-Panel</code>: 节点属性的配置栏。</p>
</li>
</ul>
<p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1604987259267.jpg" alt="基础概念图"></p>
<hr>
<h2 id="bpmn2-0规范的xml介绍"><a href="#bpmn2-0规范的xml介绍" class="headerlink" title="bpmn2.0规范的xml介绍"></a><code>bpmn2.0</code>规范的<code>xml</code>介绍</h2><ul>
<li><p><code>xml</code>的<code>definitions</code>标签内必须含有<code>bpmn</code>规范的属性。</p>
</li>
<li><p><code>xml</code>中所有标签的<code>id</code>属性不能有重复。</p>
</li>
<li><p>所有从<code>Palette</code>中拖拽到<code>Render</code>的节点，包括<code>Shape</code>和<code>Connection</code>，都需要在<code>process</code>标签中呈现。</p>
</li>
<li><p><code>bpmndi</code>标签代表<code>Render</code>中绘制的所有内容，包括<code>Shape</code>、<code>Connection</code>以及位置和路径。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function() &#123;</span><br><span class="line">  return &#96;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">            &lt;definitions xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.omg.org&#x2F;spec&#x2F;BPMN&#x2F;20100524&#x2F;MODEL&quot; xmlns:bpmndi&#x3D;&quot;http:&#x2F;&#x2F;www.omg.org&#x2F;spec&#x2F;BPMN&#x2F;20100524&#x2F;DI&quot; xmlns:omgdi&#x3D;&quot;http:&#x2F;&#x2F;www.omg.org&#x2F;spec&#x2F;DD&#x2F;20100524&#x2F;DI&quot; xmlns:omgdc&#x3D;&quot;http:&#x2F;&#x2F;www.omg.org&#x2F;spec&#x2F;DD&#x2F;20100524&#x2F;DC&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; id&#x3D;&quot;sid-38422fae-e03e-43a3-bef4-bd33b32041b2&quot; targetNamespace&#x3D;&quot;http:&#x2F;&#x2F;bpmn.io&#x2F;bpmn&quot; exporter&#x3D;&quot;bpmn-js (https:&#x2F;&#x2F;demo.bpmn.io)&quot; exporterVersion&#x3D;&quot;5.1.2&quot;&gt;</span><br><span class="line">              &lt;process id&#x3D;&quot;Process_1&quot; isExecutable&#x3D;&quot;false&quot;&gt;</span><br><span class="line">                &lt;startEvent id&#x3D;&quot;StartEvent_1y45yut&quot; name&#x3D;&quot;开始&quot;&gt;</span><br><span class="line">                &lt;outgoing&gt;SequenceFlow_0h21x7r&lt;&#x2F;outgoing&gt;</span><br><span class="line">                &lt;&#x2F;startEvent&gt;</span><br><span class="line">                &lt;task id&#x3D;&quot;Task_1hcentk&quot;&gt;</span><br><span class="line">                &lt;incoming&gt;SequenceFlow_0h21x7r&lt;&#x2F;incoming&gt;</span><br><span class="line">                &lt;&#x2F;task&gt;</span><br><span class="line">                &lt;sequenceFlow id&#x3D;&quot;SequenceFlow_0h21x7r&quot; sourceRef&#x3D;&quot;StartEvent_1y45yut&quot; targetRef&#x3D;&quot;Task_1hcentk&quot; &#x2F;&gt;</span><br><span class="line">              &lt;&#x2F;process&gt;</span><br><span class="line">              &lt;bpmndi:BPMNDiagram id&#x3D;&quot;BpmnDiagram_1&quot;&gt;</span><br><span class="line">                &lt;bpmndi:BPMNPlane id&#x3D;&quot;BpmnPlane_1&quot; bpmnElement&#x3D;&quot;Process_1&quot;&gt;</span><br><span class="line">                  &lt;bpmndi:BPMNShape id&#x3D;&quot;StartEvent_1y45yut_di&quot; bpmnElement&#x3D;&quot;StartEvent_1y45yut&quot;&gt;</span><br><span class="line">                    &lt;omgdc:Bounds x&#x3D;&quot;152&quot; y&#x3D;&quot;102&quot; width&#x3D;&quot;36&quot; height&#x3D;&quot;36&quot; &#x2F;&gt;</span><br><span class="line">                    &lt;bpmndi:BPMNLabel&gt;</span><br><span class="line">                      &lt;omgdc:Bounds x&#x3D;&quot;160&quot; y&#x3D;&quot;145&quot; width&#x3D;&quot;22&quot; height&#x3D;&quot;14&quot; &#x2F;&gt;</span><br><span class="line">                    &lt;&#x2F;bpmndi:BPMNLabel&gt;</span><br><span class="line">                  &lt;&#x2F;bpmndi:BPMNShape&gt;</span><br><span class="line">                  &lt;bpmndi:BPMNShape id&#x3D;&quot;Task_1hcentk_di&quot; bpmnElement&#x3D;&quot;Task_1hcentk&quot;&gt;</span><br><span class="line">                    &lt;omgdc:Bounds x&#x3D;&quot;240&quot; y&#x3D;&quot;80&quot; width&#x3D;&quot;100&quot; height&#x3D;&quot;80&quot; &#x2F;&gt;</span><br><span class="line">                  &lt;&#x2F;bpmndi:BPMNShape&gt;</span><br><span class="line">                  &lt;bpmndi:BPMNEdge id&#x3D;&quot;SequenceFlow_0h21x7r_di&quot; bpmnElement&#x3D;&quot;SequenceFlow_0h21x7r&quot;&gt;</span><br><span class="line">                    &lt;omgdi:waypoint x&#x3D;&quot;188&quot; y&#x3D;&quot;120&quot; &#x2F;&gt;</span><br><span class="line">                    &lt;omgdi:waypoint x&#x3D;&quot;240&quot; y&#x3D;&quot;120&quot; &#x2F;&gt;</span><br><span class="line">                  &lt;&#x2F;bpmndi:BPMNEdge&gt;</span><br><span class="line">                &lt;&#x2F;bpmndi:BPMNPlane&gt;</span><br><span class="line">              &lt;&#x2F;bpmndi:BPMNDiagram&gt;</span><br><span class="line">            &lt;&#x2F;definitions&gt;&#96;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yarn</span></span><br><span class="line">yarn add bpmn-js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> npm</span></span><br><span class="line">npm install bpmn-js</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cnpm</span></span><br><span class="line">cnpm install bpmn-js</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><ul>
<li>查看器和编译器都要对一个<code>html</code>容器设置一个宽高，否则会造成内容显示不全和闪现的问题。</li>
</ul>
<h3 id="使用Viewer查看器"><a href="#使用Viewer查看器" class="headerlink" title="使用Viewer查看器"></a>使用<code>Viewer</code>查看器</h3><ul>
<li><code>Viewer</code>不包含任何的鼠标拖拽、缩放、新增、编辑和删除节点等功能，只能用做展示使用。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;canvas&quot; ref&#x3D;&quot;canvas&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Modeler from &#39;bpmn-js&#x2F;lib&#x2F;Viewer&#39;</span><br><span class="line">import defaultXML from &#39;.&#x2F;default-xml&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      viewer: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.viewer &#x3D; new Modeler(&#123;</span><br><span class="line">      container: this.$refs.canvas</span><br><span class="line">    &#125;)</span><br><span class="line">    try &#123;</span><br><span class="line">      this.viewer.importXML(defaultXML())</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot;&gt;</span><br><span class="line">.canvas &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100vh;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605064724382.jpg" alt="使用Viewer"></p>
<h3 id="使用NavigatedViewer包含鼠标导航工具的查看器"><a href="#使用NavigatedViewer包含鼠标导航工具的查看器" class="headerlink" title="使用NavigatedViewer包含鼠标导航工具的查看器"></a>使用<code>NavigatedViewer</code>包含鼠标导航工具的查看器</h3><ul>
<li>使用<code>NavigatedViewer</code>后，<code>Render</code>画布内的节点属性支持缩放、拖拽功能。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Modeler from &#39;bpmn-js&#x2F;lib&#x2F;NavigatedViewer&#39;</span><br></pre></td></tr></table></figure>

<h3 id="使用Modeler编辑器"><a href="#使用Modeler编辑器" class="headerlink" title="使用Modeler编辑器"></a>使用<code>Modeler</code>编辑器</h3><ul>
<li><p>使用<code>Modeler</code>时需要引入<code>css</code>文件，可以通过<code>scss</code>等其它预编译器引入。</p>
</li>
<li><p>缩放、前进后退、打开、下载等功能需要单独编写方法进行支持。</p>
</li>
<li><p>下图显示的是<code>bpmn</code>在<code>Modeler</code>模式下提供的默认组件，并非全部组件。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;canvas&quot; ref&#x3D;&quot;canvas&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Modeler from &#39;bpmn-js&#x2F;lib&#x2F;Modeler&#39;</span><br><span class="line">import &#39;bpmn-js&#x2F;dist&#x2F;assets&#x2F;diagram-js.css&#39;</span><br><span class="line">import &#39;bpmn-js&#x2F;dist&#x2F;assets&#x2F;bpmn-font&#x2F;css&#x2F;bpmn.css&#39;</span><br><span class="line">import &#39;bpmn-js&#x2F;dist&#x2F;assets&#x2F;bpmn-font&#x2F;css&#x2F;bpmn-codes.css&#39;</span><br><span class="line">import &#39;bpmn-js&#x2F;dist&#x2F;assets&#x2F;bpmn-font&#x2F;css&#x2F;bpmn-embedded.css&#39;</span><br><span class="line">import defaultXML from &#39;.&#x2F;default-xml&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#39;App&#39;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      modeler: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.modeler &#x3D; new Modeler(&#123;</span><br><span class="line">      container: this.$refs.canvas</span><br><span class="line">    &#125;)</span><br><span class="line">    try &#123;</span><br><span class="line">      this.modeler.importXML(defaultXML())</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">      console.log(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang&#x3D;&quot;scss&quot;&gt;</span><br><span class="line">.canvas &#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100vh;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605084566835.jpg" alt="使用Modeler"></p>
<h3 id="节点属性配置面板"><a href="#节点属性配置面板" class="headerlink" title="节点属性配置面板"></a>节点属性配置面板</h3><ul>
<li><p>一个默认的<code>bpmn</code>设计器是不带有右侧的节点属性配置面板的。</p>
</li>
<li><p>节点属性配置面板可以有两种实现方式，其一是使用官方提供的插件实现，其二是可以通过自定义<code>vue</code>组件，在将<code>Shape</code>从<code>Palette</code>中拖拽到<code>Render</code>时，可以通过<code>Modeler</code>提供的事件监听，对用户点击过的<code>Shape</code>在右侧替换对应的<code>vue</code>组件。</p>
</li>
<li><p>这一部分会使用第一种方式进行配置右侧的节点属性栏，第二种方式会在后续的自定义中进行讲解。</p>
</li>
<li><p>安装<code>bpmn-js-properties-panel</code>和<code>camunda-bpmn-moddle</code>插件。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yarn</span></span><br><span class="line">yarn add bpmn-js-properties-panel</span><br><span class="line">yarn add camunda-bpmn-moddle</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> npm</span></span><br><span class="line">npm install bpmn-js-properties-panel</span><br><span class="line">npm install camunda-bpmn-moddle</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">cnpm</span></span><br><span class="line">cnpm install bpmn-js-properties-panel</span><br><span class="line">cnpm install camunda-bpmn-moddle</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>html</code>部分与<code>canvas</code>同级，增加用于承载节点属性配置面板的容器。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;bpmn-container&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;canvas&quot; ref&#x3D;&quot;canvas&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;properties&quot; ref&#x3D;&quot;properties&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>引入对应的<code>js</code>和<code>css</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import propertiesPanelModule from &#39;bpmn-js-properties-panel&#39;</span><br><span class="line">import propertiesProviderModule from &#39;bpmn-js-properties-panel&#x2F;lib&#x2F;provider&#x2F;camunda&#39;</span><br><span class="line">import camundaModdleDescriptor from &#39;camunda-bpmn-moddle&#x2F;resources&#x2F;camunda&#39;</span><br><span class="line">import &#39;bpmn-js-properties-panel&#x2F;dist&#x2F;assets&#x2F;bpmn-js-properties-panel.css&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>new Modeler</code>中增加<code>propertiesPanel</code>、<code>additionalModules</code>和<code>moddleExtensions</code>对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.viewer = <span class="keyword">new</span> Modeler(&#123;</span><br><span class="line">  container: <span class="keyword">this</span>.$refs.canvas,</span><br><span class="line">  propertiesPanel: &#123;</span><br><span class="line">    parent: <span class="keyword">this</span>.$refs.properties</span><br><span class="line">  &#125;,</span><br><span class="line">  additionalModules: [</span><br><span class="line">    propertiesProviderModule,</span><br><span class="line">    propertiesPanelModule</span><br><span class="line">  ],</span><br><span class="line">  moddleExtensions: &#123;</span><br><span class="line">    camunda: camundaModdleDescriptor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>由于之前将<code>class</code>为<code>canvas</code>容器的样式设置成了<code>100%</code>，所以节点属性配置面板不会展示出来，对此需要修改一部分样式。</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.bpmn-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.canvas</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">80%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100vh</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="selector-class">.properties</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">20%</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605087706732.jpg" alt="节点属性配置面板"></p>
<hr>
<h2 id="全局操作"><a href="#全局操作" class="headerlink" title="全局操作"></a>全局操作</h2><ul>
<li>全局操作包括用户的缩放行为、画布的自适应、上一步下一步、下载、保存、打开等操作。</li>
</ul>
<p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605146722819.jpg" alt="全剧操作"></p>
<h3 id="上一步"><a href="#上一步" class="headerlink" title="上一步"></a>上一步</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">previous() &#123;</span><br><span class="line">  const commandStack &#x3D; this.modeler.get(&#39;commandStack&#39;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 没有可以执行的上一步操作，可以通过下面条件对上一步按钮设置禁用</span><br><span class="line">  if (commandStack._stackIdx &#x3D;&#x3D;&#x3D; -1) &#123; return false &#125;</span><br><span class="line"></span><br><span class="line">  commandStack.undo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="下一步"><a href="#下一步" class="headerlink" title="下一步"></a>下一步</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">next() &#123;</span><br><span class="line">  const commandStack &#x3D; this.modeler.get(&#39;commandStack&#39;)</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 没有可以执行的下一步操作，可以通过下面条件对下一步按钮设置禁用</span><br><span class="line">  if (commandStack._stack.length - 1 &#x3D;&#x3D;&#x3D; commandStack._stackIdx) &#123; return false &#125;</span><br><span class="line"></span><br><span class="line">  commandStack.redo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="放大"><a href="#放大" class="headerlink" title="放大"></a>放大</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zoomIn() &#123;</span><br><span class="line">  let zoom &#x3D; this.modeler.get(&#39;canvas&#39;).zoom()</span><br><span class="line"></span><br><span class="line">  zoom +&#x3D; 0.1</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 保存当前的缩放比例到vue的data中，后续用于通过输入框控制缩放时使用</span><br><span class="line">  &#x2F;&#x2F; 保留一位小数，避免出现计算精度影响功能的情况</span><br><span class="line">  this.zoom &#x3D; Number(zoom.toFixed(1))</span><br><span class="line"></span><br><span class="line">  this.modeler.get(&#39;canvas&#39;).zoom(zoom)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缩小"><a href="#缩小" class="headerlink" title="缩小"></a>缩小</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zoomOut() &#123;</span><br><span class="line">  let zoom &#x3D; this.modeler.get(&#39;canvas&#39;).zoom()</span><br><span class="line"></span><br><span class="line">  zoom -&#x3D; 0.1</span><br><span class="line"></span><br><span class="line">  this.zoom &#x3D; Number(zoom.toFixed(1))</span><br><span class="line"></span><br><span class="line">  this.modeler.get(&#39;canvas&#39;).zoom(zoom)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="输入框控制缩放"><a href="#输入框控制缩放" class="headerlink" title="输入框控制缩放"></a>输入框控制缩放</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-input v-model.number&#x3D;&quot;zoomScale&quot; size&#x3D;&quot;mini&quot; @change&#x3D;&quot;setZoom&quot; suffix-icon&#x3D;&quot;el-icon-connection&quot;&gt;&lt;&#x2F;el-input&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;canvas&quot; ref&#x3D;&quot;canvas&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;properties&quot; ref&#x3D;&quot;properties&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Modeler from &#39;bpmn-js&#x2F;lib&#x2F;Modeler&#39;</span><br><span class="line">import &#39;bpmn-js&#x2F;dist&#x2F;assets&#x2F;diagram-js.css&#39;</span><br><span class="line">import &#39;bpmn-js&#x2F;dist&#x2F;assets&#x2F;bpmn-font&#x2F;css&#x2F;bpmn.css&#39;</span><br><span class="line">import &#39;bpmn-js&#x2F;dist&#x2F;assets&#x2F;bpmn-font&#x2F;css&#x2F;bpmn-codes.css&#39;</span><br><span class="line">import &#39;bpmn-js&#x2F;dist&#x2F;assets&#x2F;bpmn-font&#x2F;css&#x2F;bpmn-embedded.css&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      zoom: 1, &#x2F;&#x2F; 缩放比例</span><br><span class="line">      zoomScale: 100, &#x2F;&#x2F; 缩放基础值</span><br><span class="line">      modeler: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.modeler &#x3D; new Modeler(&#123;</span><br><span class="line">      container: this.$refs.canvas</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">     setZoom() &#123;</span><br><span class="line">       this.zoom &#x3D; this.zoomScale &#x2F; 100</span><br><span class="line">       this.modeler.get(&#39;canvas&#39;).zoom(this.zoom)</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="适应画布"><a href="#适应画布" class="headerlink" title="适应画布"></a>适应画布</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;canvas&quot; ref&#x3D;&quot;canvas&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;properties&quot; ref&#x3D;&quot;properties&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Modeler from &#39;bpmn-js&#x2F;lib&#x2F;Modeler&#39;</span><br><span class="line">import &#39;bpmn-js&#x2F;dist&#x2F;assets&#x2F;diagram-js.css&#39;</span><br><span class="line">import &#39;bpmn-js&#x2F;dist&#x2F;assets&#x2F;bpmn-font&#x2F;css&#x2F;bpmn.css&#39;</span><br><span class="line">import &#39;bpmn-js&#x2F;dist&#x2F;assets&#x2F;bpmn-font&#x2F;css&#x2F;bpmn-codes.css&#39;</span><br><span class="line">import &#39;bpmn-js&#x2F;dist&#x2F;assets&#x2F;bpmn-font&#x2F;css&#x2F;bpmn-embedded.css&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      zoom: 1, &#x2F;&#x2F; 缩放比例</span><br><span class="line">      modeler: null</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.modeler &#x3D; new Modeler(&#123;</span><br><span class="line">      container: this.$refs.canvas</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fitViewport() &#123;</span><br><span class="line">      this.zoom &#x3D; this.modeler.get(&#39;canvas&#39;).zoom(&#39;fit-viewport&#39;)</span><br><span class="line">    </span><br><span class="line">      const bBox &#x3D; document.querySelector(&#39;.viewport&#39;).getBBox()</span><br><span class="line">      const currentViewBox &#x3D; this.modeler.get(&#39;canvas&#39;).viewbox()</span><br><span class="line">      const elementMid &#x3D; &#123;</span><br><span class="line">        x: bBox.x + bBox.width &#x2F; 2 - 65,</span><br><span class="line">        y: bBox.y + bBox.height &#x2F; 2</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      this.modeler.get(&#39;canvas&#39;).viewbox(&#123;</span><br><span class="line">        x: elementMid.x - currentViewBox.width &#x2F; 2,</span><br><span class="line">        y: elementMid.y - currentViewBox.height &#x2F; 2,</span><br><span class="line">        width: currentViewBox.width,</span><br><span class="line">        height: currentViewBox.height</span><br><span class="line">      &#125;)</span><br><span class="line">    </span><br><span class="line">      this.zoom &#x3D; bBox.width &#x2F; currentViewBox.width * 1.8</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="打开"><a href="#打开" class="headerlink" title="打开"></a>打开</h3><ul>
<li><p>打开<code>xml</code>本质就是一个上传文件的方法，然后将文件中的<code>xml</code>内容重新装载。</p>
</li>
<li><p>装载方式是使用<code>importXML</code>方法装载<code>xml</code>，可以查看文章中《快速上手 -&gt; 使用<code>Modeler</code>编辑器》部分的介绍。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-upload action&#x3D;&quot;&quot; :before-upload&#x3D;&quot;beforeUpload&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;open&quot;&gt;</span><br><span class="line">      &lt;i class&#x3D;&quot;el-icon-folder-opened&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">      &lt;p&gt;打开&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;el-upload&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    beforeUpload(file) &#123;</span><br><span class="line">      const reader &#x3D; new FileReader()</span><br><span class="line"></span><br><span class="line">      reader.readAsText(file, &#39;utf-8&#39;)</span><br><span class="line">      reader.onload &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(reader.result) &#x2F;&#x2F; xml内容</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><ul>
<li>新建可以用于加载后端提供的<code>xml</code>模板，可以让使用者基于不同的模板进行绘制，减少用户的绘制时间。</li>
</ul>
<h3 id="重做"><a href="#重做" class="headerlink" title="重做"></a>重做</h3><ul>
<li>重做就是使用<code>importXML</code>方法装载一个空的<code>xml</code>文件。</li>
</ul>
<h3 id="下载xml"><a href="#下载xml" class="headerlink" title="下载xml"></a>下载xml</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async downloadXML() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    let &#123; xml &#125; &#x3D; await this.modeler.saveXML(&#123; format: true &#125;)</span><br><span class="line"></span><br><span class="line">    downloadFile(&#96;$&#123;this.modeler.getDefinitions().rootElements[0].name&#125;.bpmn20.xml&#96;, drawToXML(xml), &#39;application&#x2F;xml&#39;)</span><br><span class="line"></span><br><span class="line">    return xml</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="下载svg"><a href="#下载svg" class="headerlink" title="下载svg"></a>下载svg</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async downloadSVG() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const &#123; svg &#125; &#x3D; await this.modeler.saveSVG(&#123; format: true &#125;)</span><br><span class="line"></span><br><span class="line">    downloadFile(this.modeler.getDefinitions().rootElements[0].name, svg, &#39;image&#x2F;svg+xml&#39;)</span><br><span class="line"></span><br><span class="line">    return svg</span><br><span class="line">  &#125; catch (err) &#123;</span><br><span class="line">    console.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><ul>
<li>保存方法与下载<code>xml</code>方法是一致的，保存方法主要用于将<code>xml</code>通过接口发送给后端服务。</li>
</ul>
<h3 id="缩略预览"><a href="#缩略预览" class="headerlink" title="缩略预览"></a>缩略预览</h3><ul>
<li>安装<code>diagram-js-minimap</code>插件。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yarn</span></span><br><span class="line">yarn add diagram-js-minimap</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> npm</span></span><br><span class="line">npm install diagram-js-minimap</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> cnpm</span></span><br><span class="line">cnpm install diagram-js-minimap</span><br></pre></td></tr></table></figure>

<ul>
<li>引入。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import minimapModule from &#39;diagram-js-minimap&#39;</span><br><span class="line">import &#39;diagram-js-minimap&#x2F;assets&#x2F;diagram-js-minimap.css&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>在<code>Modeler</code>中装载插件。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.modeler &#x3D; new Modeler(&#123;</span><br><span class="line">  container: this.$refs.canvas,</span><br><span class="line">  additionalModules: [</span><br><span class="line">    minimapModule</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605156209317.jpg" alt="关闭状态的效果"></p>
<ul>
<li>插件默认为<code>close</code>状态，如果需要在项目打开时缩放预览为<code>open</code>状态，可执行以下代码。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.modeler.get(&#39;minimap&#39;).open()</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605156282864.jpg" alt="打开状态的效果"></p>
<ul>
<li>如果不满意默认的缩放预览效果，可以通过样式覆盖的形式去更改，在后续的文章中会以一个例子介绍具体的更改方法。</li>
</ul>
<hr>
<h2 id="自定义Palette"><a href="#自定义Palette" class="headerlink" title="自定义Palette"></a>自定义<code>Palette</code></h2><ul>
<li><p>在了解了<code>bpmn</code>基础概念和使用后，对一些模块以及它们之间的配合应该有了一定的概念，同时<code>bpmn</code>的默认样式可能无法满足业务的需求。</p>
</li>
<li><p>自定义<code>Palette</code>后允许通过配置生成工具栏、更改工具栏样式和布局等。</p>
</li>
<li><p>自定义的方式包含两种，其一是基于<code>Modeler</code>中的<code>Palette</code>进行修改，其二是完全重写<code>Palette</code>方法。</p>
</li>
</ul>
<h3 id="新建目录和文件"><a href="#新建目录和文件" class="headerlink" title="新建目录和文件"></a>新建目录和文件</h3><ul>
<li><p>在<code>components</code>目录下新建<code>modeler</code>目录，在<code>modeler</code>目录下新建<code>palette</code>目录和<code>index.js</code>文件。</p>
</li>
<li><p>在<code>palette</code>目录下新建<code>CustomPalette.js</code>文件。</p>
</li>
</ul>
<p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605245857229.jpg" alt="基于`Modeler`中的`Palette`进行自定义目录结构"></p>
<h3 id="基于Modeler中的Palette进行自定义"><a href="#基于Modeler中的Palette进行自定义" class="headerlink" title="基于Modeler中的Palette进行自定义"></a>基于<code>Modeler</code>中的<code>Palette</code>进行自定义</h3><h4 id="编写CustomPalette-js代码"><a href="#编写CustomPalette-js代码" class="headerlink" title="编写CustomPalette.js代码"></a>编写<code>CustomPalette.js</code>代码</h4><ul>
<li><p>使用<code>$inject</code>注入一些需要的变量。</p>
</li>
<li><p>在类中使用<code>palette.registerProvider(this)</code>指定这是一个<code>palette</code>。</p>
</li>
<li><p><code>CustomPalette</code>类中的核心代码是<code>getPaletteEntries</code>函数，该函数的名称不能改变, 该函数返回的是一个对象, 对象中指定的内容就是自定义的中的每一项。</p>
</li>
<li><p><code>group</code>: 属于哪个分组, <code>比如tools</code>、<code>event</code>、<code>gateway</code>、<code>activity等等</code>。</p>
</li>
<li><p><code>className</code>: 样式类名, 我们可以通过它给元素修改样式。</p>
</li>
<li><p><code>title</code>: 鼠标移动到元素上面给出的提示信息。</p>
</li>
<li><p><code>action</code>: 用户操作时会触发的事件</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class CustomPalette &#123;</span><br><span class="line">  constructor(bpmnFactory, create, elementFactory, palette, translate) &#123;</span><br><span class="line">    this.bpmnFactory &#x3D; bpmnFactory</span><br><span class="line">    this.create &#x3D; create</span><br><span class="line">    this.elementFactory &#x3D; elementFactory</span><br><span class="line">    this.translate &#x3D; translate</span><br><span class="line"></span><br><span class="line">    palette.registerProvider(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getPaletteEntries(element) &#123;</span><br><span class="line">    console.log(element)</span><br><span class="line"></span><br><span class="line">    const &#123;</span><br><span class="line">      bpmnFactory,</span><br><span class="line">      create,</span><br><span class="line">      elementFactory,</span><br><span class="line">      translate</span><br><span class="line">    &#125; &#x3D; this</span><br><span class="line"></span><br><span class="line">    function createTask() &#123;</span><br><span class="line">      return function(event) &#123;</span><br><span class="line">        const businessObject &#x3D; bpmnFactory.create(&#39;bpmn:StartEvent&#39;)</span><br><span class="line">        const shape &#x3D; elementFactory.createShape(&#123;</span><br><span class="line">          type: &#39;bpmn:StartEvent&#39;,</span><br><span class="line">          businessObject</span><br><span class="line">        &#125;)</span><br><span class="line">        create.start(event, shape)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      &#39;create.test-start-event&#39;: &#123;</span><br><span class="line">        group: &#39;model&#39;,</span><br><span class="line">        className: &#39;icon-custom test-start-event&#39;,</span><br><span class="line">        title: translate(&#39;创建一个开始节点&#39;),</span><br><span class="line">        action: &#123;</span><br><span class="line">          dragstart: createTask(),</span><br><span class="line">          click: createTask()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomPalette.$inject &#x3D; [</span><br><span class="line">  &#39;bpmnFactory&#39;,</span><br><span class="line">  &#39;create&#39;,</span><br><span class="line">  &#39;elementFactory&#39;,</span><br><span class="line">  &#39;palette&#39;,</span><br><span class="line">  &#39;translate&#39;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="编写index-js文件"><a href="#编写index-js文件" class="headerlink" title="编写index.js文件"></a>编写<code>index.js</code>文件</h4><ul>
<li><code>__init__</code>中的名字就必须是<code>customPalette</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import CustomPalette from &#39;.&#x2F;palette&#x2F;CustomPalette&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  __init__: [&#39;customPalette&#39;],</span><br><span class="line">  customPalette: [&#39;type&#39;, CustomPalette]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在vue文件中引入"><a href="#在vue文件中引入" class="headerlink" title="在vue文件中引入"></a>在<code>vue</code>文件中引入</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import customPalette from &#39;.&#x2F;components&#x2F;modeler&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.modeler &#x3D; new Modeler(&#123;</span><br><span class="line">      container: this.$refs.canvas,</span><br><span class="line">      additionalModules: [</span><br><span class="line">        customPalette</span><br><span class="line">      ]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="编写样式"><a href="#编写样式" class="headerlink" title="编写样式"></a>编写样式</h4><ul>
<li>编写样式样式，能够在左侧<code>Palette</code>中展示自定义的节点。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.icon-custom</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">65%</span>;</span><br><span class="line">  <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">  <span class="attribute">background-position</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-custom</span><span class="selector-class">.test-start-event</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">'https://zdgg-scrm.oss-cn-shanghai.aliyuncs.com/bpmn/liuchengkongzhi/start.png'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h4><p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605170483360.jpg" alt="基于`Modeler`中的`Palette`进行自定义完成效果"></p>
<h3 id="重写Palette方法"><a href="#重写Palette方法" class="headerlink" title="重写Palette方法"></a>重写<code>Palette</code>方法</h3><ul>
<li>上面的代码通过修改<code>Modeler</code>中的<code>Palette</code>实现了对<code>Palette</code>中的节点进行自定义的功能，但是如果想实现以下红线圈出效果，则需要重写<code>Palette</code>方法。</li>
</ul>
<p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605172503339.jpg" alt="重写`Palette`方法展示图"></p>
<h4 id="编写CustomPalette-js代码-1"><a href="#编写CustomPalette-js代码-1" class="headerlink" title="编写CustomPalette.js代码"></a>编写<code>CustomPalette.js</code>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function PaletteProvider(palette, create, elementFactory, globalConnect) &#123;</span><br><span class="line">  this.create &#x3D; create</span><br><span class="line">  this.elementFactory &#x3D; elementFactory</span><br><span class="line">  this.globalConnect &#x3D; globalConnect</span><br><span class="line"></span><br><span class="line">  palette.registerProvider(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PaletteProvider.$inject &#x3D; [</span><br><span class="line">  &#39;palette&#39;,</span><br><span class="line">  &#39;create&#39;,</span><br><span class="line">  &#39;elementFactory&#39;,</span><br><span class="line">  &#39;globalConnect&#39;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">PaletteProvider.prototype.getPaletteEntries &#x3D; function() &#123;</span><br><span class="line">  const &#123;</span><br><span class="line">    create,</span><br><span class="line">    elementFactory</span><br><span class="line">  &#125; &#x3D; this</span><br><span class="line"></span><br><span class="line">  function createTask() &#123;</span><br><span class="line">    return function(event) &#123;</span><br><span class="line">      const shape &#x3D; elementFactory.createShape(&#123;</span><br><span class="line">        type: &#39;bpmn:StartEvent&#39;</span><br><span class="line">      &#125;)</span><br><span class="line">      console.log(shape)</span><br><span class="line">      create.start(event, shape)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    &#39;create.test-start-event&#39;: &#123;</span><br><span class="line">      group: &#39;model&#39;,</span><br><span class="line">      className: &#39;icon-custom test-start-event&#39;,</span><br><span class="line">      title: &#39;创建一个开始节点&#39;,</span><br><span class="line">      action: &#123;</span><br><span class="line">        dragstart: createTask(),</span><br><span class="line">        click: createTask()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写index-js代码"><a href="#编写index-js代码" class="headerlink" title="编写index.js代码"></a>编写<code>index.js</code>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Modeler from &#39;bpmn-js&#x2F;lib&#x2F;Modeler&#39;</span><br><span class="line">import inherits from &#39;inherits&#39;</span><br><span class="line">import CustomPalette from &#39;.&#x2F;palette&#x2F;CustomPalette&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  __init__: [&#39;paletteProvider&#39;],</span><br><span class="line">  paletteProvider: [&#39;type&#39;, CustomPalette]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function CustomModeler(options) &#123;</span><br><span class="line">  Modeler.call(this, options)</span><br><span class="line">  this._customElements &#x3D; []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inherits(CustomModeler, Modeler)</span><br><span class="line">CustomModeler.prototype._modules &#x3D; [].concat(</span><br><span class="line">  CustomModeler.prototype._modules, [</span><br><span class="line">    CustomModule</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="在vue文件中引入-1"><a href="#在vue文件中引入-1" class="headerlink" title="在vue文件中引入"></a>在<code>vue</code>文件中引入</h4><ul>
<li>当重写<code>Palette</code>方法后，将不再通过<code>BpmnModeler</code>进行创建，需要通过<code>CustomModeler</code>进行创建。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import CustomModeler from &#39;.&#x2F;components&#x2F;modeler&#39;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  mounted() &#123;</span><br><span class="line">    this.modeler &#x3D; new CustomModeler(&#123;</span><br><span class="line">      container: this.$refs.canvas</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="编写样式-1"><a href="#编写样式-1" class="headerlink" title="编写样式"></a>编写样式</h4><ul>
<li>样式使用《基于<code>Modeler</code>中的<code>Palette</code>进行自定义》中的样式。</li>
</ul>
<h4 id="产看效果"><a href="#产看效果" class="headerlink" title="产看效果"></a>产看效果</h4><p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605174390912.jpg" alt="重写`Palette`方法完成效果"></p>
<h3 id="修改Palette样式"><a href="#修改Palette样式" class="headerlink" title="修改Palette样式"></a>修改<code>Palette</code>样式</h3><ul>
<li><p>想要更改默认的<code>Palette</code>侧边栏的样式需要对<code>dom</code>结构有一定的更改，同时也要增加一部分样式。</p>
</li>
<li><p>获取<code>canvas</code>容器，获取<code>Palette</code>侧边栏的<code>dom</code>节点。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const canvas &#x3D; this.$refs.canvas</span><br><span class="line">const djsPalette &#x3D; canvas.children[0].children[1].children[5]</span><br></pre></td></tr></table></figure>

<ul>
<li>拿到节点后就可以对其进行节点以及样式的增删改等操作。</li>
</ul>
<hr>
<h2 id="自定义Renderer"><a href="#自定义Renderer" class="headerlink" title="自定义Renderer"></a>自定义<code>Renderer</code></h2><ul>
<li><p>由于画布中的图形为<code>svg</code>，与<code>Palette</code>不同的是<code>Palette</code>使用的是<code>html</code>，如果需要深度自定义（不仅仅是替换节点在<code>Render</code>中显示的图标）需要一定的<code>svg</code>知识。</p>
</li>
<li><p>在自定义<code>Palette</code>后，将一个节点从<code>Palette</code>栏拖拽到<code>Render</code>后，节点在<code>Render</code>上展示的还是默认类型的样子。</p>
</li>
</ul>
<p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605235889814.jpg" alt="重写`Palette`方法完成效果"></p>
<h3 id="新建目录和文件-1"><a href="#新建目录和文件-1" class="headerlink" title="新建目录和文件"></a>新建目录和文件</h3><ul>
<li><p>在<code>components -&gt; modeler</code>下新建<code>renderer</code>文件夹，在<code>renderer</code>文件夹下新建<code>CustomRenderer.js</code>文件。</p>
</li>
<li><p>在<code>components -&gt; modeler</code>下新建<code>utils.js</code>文件。</p>
</li>
</ul>
<p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605236911318.jpg" alt="在默认的`Renderer`上进行自定义目录结构"></p>
<h3 id="在默认的Renderer上进行自定义"><a href="#在默认的Renderer上进行自定义" class="headerlink" title="在默认的Renderer上进行自定义"></a>在默认的<code>Renderer</code>上进行自定义</h3><h4 id="编写CustomRenderer-js代码"><a href="#编写CustomRenderer-js代码" class="headerlink" title="编写CustomRenderer.js代码"></a>编写<code>CustomRenderer.js</code>代码</h4><ul>
<li><p>由于是在<code>bpmn.js</code>已有的元素上进行修改, 所以所以需要将<code>BaseRenderer</code>这个类引入进来, 然后自定义<code>renderer</code>来继承它。</p>
</li>
<li><p>代码中<code>HIGH_PRIORITY</code>不能去掉, 否则不会执行<code>drawShape</code>函数。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import BaseRenderer from &#39;diagram-js&#x2F;lib&#x2F;draw&#x2F;BaseRenderer&#39;</span><br><span class="line">import &#123; customElements, customConfig &#125; from &#39;..&#x2F;utils&#39;</span><br><span class="line">import &#123; append as svgAppend, create as svgCreate &#125; from &#39;tiny-svg&#39;</span><br><span class="line"></span><br><span class="line">const HIGH_PRIORITY &#x3D; 1500</span><br><span class="line"></span><br><span class="line">export default class CustomRenderer extends BaseRenderer &#123;</span><br><span class="line">  constructor(eventBus, bpmnRenderer) &#123;</span><br><span class="line">    super(eventBus, HIGH_PRIORITY)</span><br><span class="line">    this.bpmnRenderer &#x3D; bpmnRenderer</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  canRender(element) &#123;</span><br><span class="line">    return !element.labelTarget</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  drawShape(parentNode, element) &#123;</span><br><span class="line">    const type &#x3D; element.type</span><br><span class="line"></span><br><span class="line">    if (customElements.includes(type)) &#123;</span><br><span class="line">      const &#123; url, attr &#125; &#x3D; customConfig[type]</span><br><span class="line">      const customIcon &#x3D; svgCreate(&#39;image&#39;, &#123;</span><br><span class="line">        ...attr,</span><br><span class="line">        href: url</span><br><span class="line">      &#125;)</span><br><span class="line">      element[&#39;width&#39;] &#x3D; attr.width</span><br><span class="line">      element[&#39;height&#39;] &#x3D; attr.height</span><br><span class="line">      svgAppend(parentNode, customIcon)</span><br><span class="line"></span><br><span class="line">      return customIcon</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const shape &#x3D; this.bpmnRenderer.drawShape(parentNode, element)</span><br><span class="line"></span><br><span class="line">    return shape</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getShapePath(shape) &#123;</span><br><span class="line">    return this.bpmnRenderer.getShapePath(shape)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomRenderer.$inject &#x3D; [&#39;eventBus&#39;, &#39;bpmnRenderer&#39;]</span><br></pre></td></tr></table></figure>

<h4 id="编写utils-js代码"><a href="#编写utils-js代码" class="headerlink" title="编写utils.js代码"></a>编写<code>utils.js</code>代码</h4><ul>
<li><p>自定义的<code>Palette</code>中的节点的类型需要在<code>customElements</code>中注册，否则当用户拖拽一个节点从<code>Palette</code>侧边栏到<code>Render</code>中会提示找不到组件的错误。</p>
</li>
<li><p><code>customConfig</code>中的对象在<code>CustomRenderer.js</code>中</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const customElements &#x3D; [&#39;bpmn:StartEvent&#39;]</span><br><span class="line"></span><br><span class="line">const customConfig &#x3D; &#123;</span><br><span class="line">  &#39;bpmn:StartEvent&#39;: &#123;</span><br><span class="line">    &#39;url&#39;: &#39;https:&#x2F;&#x2F;zdgg-scrm.oss-cn-shanghai.aliyuncs.com&#x2F;bpmn&#x2F;liuchengkongzhi&#x2F;start.png&#39;,</span><br><span class="line">    &#39;attr&#39;: &#123; x: 0, y: 0, width: 48, height: 48 &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; customElements, customConfig &#125;</span><br></pre></td></tr></table></figure>

<h4 id="编写index-js代码-1"><a href="#编写index-js代码-1" class="headerlink" title="编写index.js代码"></a>编写<code>index.js</code>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Modeler from &#39;bpmn-js&#x2F;lib&#x2F;Modeler&#39;</span><br><span class="line">import inherits from &#39;inherits&#39;</span><br><span class="line">import CustomPalette from &#39;.&#x2F;palette&#x2F;CustomPalette&#39;</span><br><span class="line">import CustomRenderer from &#39;.&#x2F;renderer&#x2F;CustomRenderer&#39;</span><br><span class="line"></span><br><span class="line">const CustomModule &#x3D;  &#123;</span><br><span class="line">  __init__: [&#39;paletteProvider&#39;, &#39;customRenderer&#39;],</span><br><span class="line">  paletteProvider: [&#39;type&#39;, CustomPalette],</span><br><span class="line">  customRenderer: [&#39;type&#39;, CustomRenderer]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function CustomModeler(options) &#123;</span><br><span class="line">  Modeler.call(this, options)</span><br><span class="line">  this._customElements &#x3D; []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inherits(CustomModeler, Modeler)</span><br><span class="line">CustomModeler.prototype._modules &#x3D; [].concat(</span><br><span class="line">  CustomModeler.prototype._modules, [</span><br><span class="line">    CustomModule</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="重写Renderer方法"><a href="#重写Renderer方法" class="headerlink" title="重写Renderer方法"></a>重写<code>Renderer</code>方法</h3><ul>
<li>对于重写<code>Renderer</code>方法而言，只需修改<code>CustomRenderer.js</code>文件的代码，<code>index.js</code>和<code>utils.js</code>文件与在《默认的<code>Renderer</code>上进行自定义》的内容一致。</li>
</ul>
<h4 id="编写CustomRenderer-js代码-1"><a href="#编写CustomRenderer-js代码-1" class="headerlink" title="编写CustomRenderer.js代码"></a>编写<code>CustomRenderer.js</code>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import inherits from &#39;inherits&#39;</span><br><span class="line">import BaseRenderer from &#39;diagram-js&#x2F;lib&#x2F;draw&#x2F;BaseRenderer&#39;</span><br><span class="line">import &#123; append as svgAppend, create as svgCreate &#125; from &#39;tiny-svg&#39;</span><br><span class="line">import &#123; customElements, customConfig &#125; from &#39;..&#x2F;utils&#39;</span><br><span class="line"></span><br><span class="line">export default function CustomRenderer(eventBus) &#123;</span><br><span class="line">  BaseRenderer.call(this, eventBus, 2000)</span><br><span class="line"></span><br><span class="line">  this.drawCustomElements &#x3D; function(parentNode, element) &#123;</span><br><span class="line">    const type &#x3D; element.type &#x2F;&#x2F; 获取到类型</span><br><span class="line"></span><br><span class="line">    if (customElements.includes(type)) &#123; &#x2F;&#x2F; or customConfig[type]</span><br><span class="line">      const &#123; url, attr &#125; &#x3D; customConfig[type]</span><br><span class="line">      const customIcon &#x3D; svgCreate(&#39;image&#39;, &#123;</span><br><span class="line">        ...attr,</span><br><span class="line">        href: url</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">      element[&#39;width&#39;] &#x3D; attr.width</span><br><span class="line">      element[&#39;height&#39;] &#x3D; attr.height</span><br><span class="line">      svgAppend(parentNode, customIcon)</span><br><span class="line"></span><br><span class="line">      return customIcon</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const shape &#x3D; this.bpmnRenderer.drawShape(parentNode, element)</span><br><span class="line"></span><br><span class="line">    return shape</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inherits(CustomRenderer, BaseRenderer)</span><br><span class="line"></span><br><span class="line">CustomRenderer.$inject &#x3D; [&#39;eventBus&#39;, &#39;styles&#39;]</span><br><span class="line"></span><br><span class="line">CustomRenderer.prototype.canRender &#x3D; function(element) &#123;</span><br><span class="line">  return !element.labelTarget</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomRenderer.prototype.drawShape &#x3D; function(p, element) &#123;</span><br><span class="line">  return this.drawCustomElements(p, element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomRenderer.prototype.getShapePath &#x3D; function(shape) &#123;</span><br><span class="line">  console.log(shape)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605249951861.jpg" alt="自定义`Renderer`效果"></p>
<hr>
<h2 id="自定义ContextPad"><a href="#自定义ContextPad" class="headerlink" title="自定义ContextPad"></a>自定义<code>ContextPad</code></h2><ul>
<li><p>默认效果的<code>ContextPad</code>。</p>
</li>
<li><p>可以看到除了在左侧的工具栏处能添加节点之外, 点击节点的时候也会出现一个小弹窗, 这里面也可以添加节点。</p>
</li>
</ul>
<p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605252528039.jpg" alt="`ContextPad`默认效果"></p>
<h3 id="新建目录和文件-2"><a href="#新建目录和文件-2" class="headerlink" title="新建目录和文件"></a>新建目录和文件</h3><ul>
<li>在<code>components -&gt; modeler</code>下新建<code>context-pad</code>文件夹，在<code>context-pad</code>文件夹下新建<code>CustomContextPad.js</code>文件。</li>
</ul>
<p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605252797758.jpg" alt="自定义`CustomContextPad`目录结构"></p>
<h3 id="在默认的ContextPad上自定义"><a href="#在默认的ContextPad上自定义" class="headerlink" title="在默认的ContextPad上自定义"></a>在默认的<code>ContextPad</code>上自定义</h3><h4 id="编写CustomContextPad-js代码"><a href="#编写CustomContextPad-js代码" class="headerlink" title="编写CustomContextPad.js代码"></a>编写<code>CustomContextPad.js</code>代码</h4><ul>
<li><p>其实自定义<code>ContextPad</code>和<code>Palette</code>很像, 只不过是使用<code>contextPad.registerProvider(this)</code>来指定它是一个<code>ContextPad</code>, 而自定义<code>Palette</code>是用<code>paltette.registerProvider(this)</code>。</p>
</li>
<li><p><code>getContextPadEntries</code>方法与自定义<code>palette</code>时候的<code>getPaletteEntries</code>方法返回的参数相似。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default class CustomContextPad &#123;</span><br><span class="line">  constructor(config, contextPad, create, elementFactory, injector, translate) &#123;</span><br><span class="line">    this.create &#x3D; create</span><br><span class="line">    this.elementFactory &#x3D; elementFactory</span><br><span class="line">    this.translate &#x3D; translate</span><br><span class="line"></span><br><span class="line">    if (config.autoPlace !&#x3D;&#x3D; false) &#123;</span><br><span class="line">      this.autoPlace &#x3D; injector.get(&#39;autoPlace&#39;, false)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    contextPad.registerProvider(this)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getContextPadEntries(element) &#123;</span><br><span class="line">    const &#123;</span><br><span class="line">      autoPlace,</span><br><span class="line">      create,</span><br><span class="line">      elementFactory,</span><br><span class="line">      translate</span><br><span class="line">    &#125; &#x3D; this</span><br><span class="line"></span><br><span class="line">    function appendTask(event, element) &#123;</span><br><span class="line">      if (autoPlace) &#123;</span><br><span class="line">        const shape &#x3D; elementFactory.createShape(&#123; type: &#39;bpmn:StartEvent&#39; &#125;)</span><br><span class="line">        autoPlace.append(element, shape)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        appendTaskStart(event, element)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function appendTaskStart(event) &#123;</span><br><span class="line">      const shape &#x3D; elementFactory.createShape(&#123; type: &#39;bpmn:StartEvent&#39; &#125;)</span><br><span class="line">      create.start(event, shape, element)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return &#123;</span><br><span class="line">      &#39;append.test-start-event&#39;: &#123;</span><br><span class="line">        group: &#39;model&#39;,</span><br><span class="line">        className: &#39;icon-custom test-start-event&#39;,</span><br><span class="line">        title: translate(&#39;创建一个开始节点&#39;),</span><br><span class="line">        action: &#123;</span><br><span class="line">          click: appendTask,</span><br><span class="line">          dragstart: appendTaskStart</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CustomContextPad.$inject &#x3D; [</span><br><span class="line">  &#39;config&#39;,</span><br><span class="line">  &#39;contextPad&#39;,</span><br><span class="line">  &#39;create&#39;,</span><br><span class="line">  &#39;elementFactory&#39;,</span><br><span class="line">  &#39;injector&#39;,</span><br><span class="line">  &#39;translate&#39;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h4 id="编写index-js代码-2"><a href="#编写index-js代码-2" class="headerlink" title="编写index.js代码"></a>编写<code>index.js</code>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Modeler from &#39;bpmn-js&#x2F;lib&#x2F;Modeler&#39;</span><br><span class="line">import inherits from &#39;inherits&#39;</span><br><span class="line">import CustomPalette from &#39;.&#x2F;palette&#x2F;CustomPalette&#39;</span><br><span class="line">import CustomRenderer from &#39;.&#x2F;renderer&#x2F;CustomRenderer&#39;</span><br><span class="line">import CustomContextPadProvider from &#39;.&#x2F;context-pad&#x2F;CustomContextPad&#39;</span><br><span class="line"></span><br><span class="line">const CustomModule &#x3D;  &#123;</span><br><span class="line">  __init__: [&#39;paletteProvider&#39;, &#39;customRenderer&#39;, &#39;contextPadProvider&#39;],</span><br><span class="line">  paletteProvider: [&#39;type&#39;, CustomPalette],</span><br><span class="line">  customRenderer: [&#39;type&#39;, CustomRenderer],</span><br><span class="line">  contextPadProvider: [&#39;type&#39;, CustomContextPadProvider]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default function CustomModeler(options) &#123;</span><br><span class="line">  Modeler.call(this, options)</span><br><span class="line">  this._customElements &#x3D; []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inherits(CustomModeler, Modeler)</span><br><span class="line">CustomModeler.prototype._modules &#x3D; [].concat(</span><br><span class="line">  CustomModeler.prototype._modules, [</span><br><span class="line">    CustomModule</span><br><span class="line">  ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="编写样式-2"><a href="#编写样式-2" class="headerlink" title="编写样式"></a>编写样式</h4><ul>
<li>在<code>App.vue</code>中增加样式。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.djs-context-pad</span> <span class="selector-class">.test-start-event</span><span class="selector-class">.entry</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">'https://zdgg-scrm.oss-cn-shanghai.aliyuncs.com/bpmn/liuchengkongzhi/start.png'</span>) center no-repeat <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">background-size</span>: cover <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.djs-context-pad</span> <span class="selector-class">.entry</span><span class="selector-pseudo">:hover</span> &#123; <span class="comment">/* 重新修改了 hover 之后的样式 */</span></span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#1890ff</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.djs-context-pad</span> <span class="selector-class">.entry</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="number">94%</span>;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.3s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="重写ContextPad方法"><a href="#重写ContextPad方法" class="headerlink" title="重写ContextPad方法"></a>重写<code>ContextPad</code>方法</h3><ul>
<li>重写<code>ContextPad</code>方法只需要修改<code>CustomContextPad.js</code>中的代码，对于<code>utils.js</code>和<code>App.vue</code>则与《在默认的<code>ContextPad</code>上自定义》相同。</li>
</ul>
<h4 id="编写CustomContextPad-js代码-1"><a href="#编写CustomContextPad-js代码-1" class="headerlink" title="编写CustomContextPad.js代码"></a>编写<code>CustomContextPad.js</code>代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export default function ContextPadProvider(contextPad, config, injector, translate, bpmnFactory, elementFactory, create, modeling, connect) &#123;</span><br><span class="line">  this.create &#x3D; create</span><br><span class="line">  this.elementFactory &#x3D; elementFactory</span><br><span class="line">  this.translate &#x3D; translate</span><br><span class="line">  this.bpmnFactory &#x3D; bpmnFactory</span><br><span class="line">  this.modeling &#x3D; modeling</span><br><span class="line">  this.connect &#x3D; connect</span><br><span class="line"></span><br><span class="line">  config &#x3D; config || &#123;&#125;</span><br><span class="line"></span><br><span class="line">  if (config.autoPlace !&#x3D;&#x3D; false) &#123;</span><br><span class="line">    this._autoPlace &#x3D; injector.get(&#39;autoPlace&#39;, false)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  contextPad.registerProvider(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ContextPadProvider.$inject &#x3D; [</span><br><span class="line">  &#39;contextPad&#39;,</span><br><span class="line">  &#39;config&#39;,</span><br><span class="line">  &#39;injector&#39;,</span><br><span class="line">  &#39;translate&#39;,</span><br><span class="line">  &#39;bpmnFactory&#39;,</span><br><span class="line">  &#39;elementFactory&#39;,</span><br><span class="line">  &#39;create&#39;,</span><br><span class="line">  &#39;modeling&#39;,</span><br><span class="line">  &#39;connect&#39;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">ContextPadProvider.prototype.getContextPadEntries &#x3D; function(element) &#123;</span><br><span class="line">  const &#123;</span><br><span class="line">    autoPlace,</span><br><span class="line">    create,</span><br><span class="line">    elementFactory,</span><br><span class="line">    translate</span><br><span class="line">  &#125; &#x3D; this</span><br><span class="line"></span><br><span class="line">  function appendTask(event, element) &#123;</span><br><span class="line">    if (autoPlace) &#123;</span><br><span class="line">      const shape &#x3D; elementFactory.createShape(&#123; type: &#39;bpmn:StartEvent&#39; &#125;)</span><br><span class="line">      autoPlace.append(element, shape)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      appendTaskStart(event, element)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function appendTaskStart(event) &#123;</span><br><span class="line">    const shape &#x3D; elementFactory.createShape(&#123; type: &#39;bpmn:StartEvent&#39; &#125;)</span><br><span class="line">    create.start(event, shape, element)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    &#39;append.test-start-event&#39;: &#123;</span><br><span class="line">      group: &#39;model&#39;,</span><br><span class="line">      className: &#39;icon-custom test-start-event&#39;,</span><br><span class="line">      title: translate(&#39;创建一个开始节点&#39;),</span><br><span class="line">      action: &#123;</span><br><span class="line">        click: appendTask,</span><br><span class="line">        dragstart: appendTaskStart</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605252668249.jpg" alt="`ContextPad`自定义效果"></p>
<hr>
<h2 id="自定义连接线和箭头"><a href="#自定义连接线和箭头" class="headerlink" title="自定义连接线和箭头"></a>自定义连接线和箭头</h2><h3 id="默认效果"><a href="#默认效果" class="headerlink" title="默认效果"></a>默认效果</h3><p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605254672725.jpg" alt="默认效果"></p>
<h3 id="修改连接线颜色"><a href="#修改连接线颜色" class="headerlink" title="修改连接线颜色"></a>修改连接线颜色</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.djs-connection</span> &#123;</span><br><span class="line">  path &#123;</span><br><span class="line">    stroke: blue <span class="meta">!important</span>;</span><br><span class="line">    marker-end: url(#sequenceflow-arrow-normal) <span class="meta">!important</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605254549761.jpg" alt="修改连接线颜色"></p>
<h3 id="自定义箭头"><a href="#自定义箭头" class="headerlink" title="自定义箭头"></a>自定义箭头</h3><ul>
<li><p>绘制箭头需要有一定的<code>svg</code>开发能力，因为<code>Render</code>中的所有节点都是以<code>svg</code>进行呈现的。</p>
</li>
<li><p>自定义<code>svg</code>需要引入以下两个包。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; append as svgAppend, attr as svgAttr, create as svgCreate &#125; from &#39;tiny-svg&#39;</span><br><span class="line">import &#123; query as domQuery &#125; from &#39;min-dom&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li>修改装载<code>xml</code>时候的方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bpmnModeler.importXML(xml).then(() &#x3D;&gt; &#123;</span><br><span class="line">  const marker &#x3D; svgCreate(&#39;marker&#39;)</span><br><span class="line"></span><br><span class="line">  svgAttr(marker, &#123;</span><br><span class="line">    id: &#39;#sequenceflow-arrow-normal&#39;,</span><br><span class="line">    viewBox: &#39;0 0 20 20&#39;,</span><br><span class="line">    refX: &#39;11&#39;,</span><br><span class="line">    refY: &#39;10&#39;,</span><br><span class="line">    markerWidth: &#39;10&#39;,</span><br><span class="line">    markerHeight: &#39;10&#39;,</span><br><span class="line">    orient: &#39;auto&#39;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  const path &#x3D; svgCreate(&#39;path&#39;)</span><br><span class="line"></span><br><span class="line">  svgAttr(path, &#123;</span><br><span class="line">    d: &#39;M 1 5 L 11 10 L 1 15 Z&#39;,</span><br><span class="line">    style:</span><br><span class="line">      &#39; stroke-width: 1px; stroke-linecap: round; stroke-dasharray: 10000, 1; &#39;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  const defs &#x3D; domQuery(&#39;defs&#39;)</span><br><span class="line">  svgAppend(marker, path)</span><br><span class="line">  svgAppend(defs, marker)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="实现效果-2"><a href="#实现效果-2" class="headerlink" title="实现效果"></a>实现效果</h3><p><img src="/blog/images/BPMN%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%AE%80%E8%BF%B0/1605255869265.jpg" alt="实现效果"></p>
]]></content>
      <categories>
        <category>bpmn</category>
      </categories>
      <tags>
        <tag>bpmn</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6.9下对MySQL5.7的用户权限管理</title>
    <url>/blog/2018/04/17/CentOS6.9%E4%B8%8B%E5%AF%B9MySQL5.7%E7%9A%84%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>在实际开发中的很多情况下，我们不免要对数据库根据用户的不同进行权限的分配。在MySQL数据库中，基本有28种权限，我们可以将其归类成三大类的权限。</p>
<h4 id="MySQL的权限分类"><a href="#MySQL的权限分类" class="headerlink" title="MySQL的权限分类"></a>MySQL的权限分类</h4><h5 id="一）数据操作类"><a href="#一）数据操作类" class="headerlink" title="一）数据操作类"></a>一）数据操作类</h5> <div class="table-responsive"><table class="table table-striped table-bordered table-hover"><tr><td>操作</td><td>含义</td></tr><tr><td>SELECT</td><td>查询权限</td></tr><tr><td>INSERT</td><td>插入权限</td></tr><tr><td>UPDATE</td><td>更新权限</td></tr><tr><td>DELETE</td><td>删除数据权限</td></tr><tr><td>FILE</td><td>文件访问权限</td></tr></table></div>

<h5 id="二）结构操作类"><a href="#二）结构操作类" class="headerlink" title="二）结构操作类"></a>二）结构操作类</h5><div class="table-responsive"><table class="table table-striped table-bordered table-hover"><tr><td>操作</td><td>含义</td></tr><tr><td>CREATE</td><td>创建数据库、表或索引权限</td></tr><tr><td>ALTER</td><td>更改表权限（添加字段或者索引等）</td></tr><tr><td>INDEX</td><td>索引权限</td></tr><tr><td>DROP</td><td>删除数据库或表权限</td></tr><tr><td>CREATE TEMPORARY TABLES</td><td>创建临时表权限</td></tr><tr><td>SHOW VIEW</td><td>查看视图权限</td></tr><tr><td>CREATE ROUTINE</td><td>创建存储过程权限</td></tr><tr><td>ALTER ROUTINE</td><td>更改存储过程权限</td></tr><tr><td>EXECUTE</td><td>执行存储过程权限</td></tr><tr><td>CREATE VIEW</td><td>创建视图权限</td></tr><tr><td>EVENT</td><td>可在数据下创建时间调度器权限</td></tr><tr><td>TRIGGER</td><td>可在数据下创建触发器权限</td></tr></table></div>

<h5 id="三）管理操作类"><a href="#三）管理操作类" class="headerlink" title="三）管理操作类"></a>三）管理操作类</h5><div class="table-responsive"><table class="table table-striped table-bordered table-hover"><tr><td>操作</td><td>含义</td></tr><tr><td>GRANT</td><td>赋予权限选项</td></tr><tr><td>SUPER</td><td>执行kill线程权限</td></tr><tr><td>PROCESS</td><td>查看进程权限</td></tr><tr><td>RELOAD</td><td>执行flush-hosts，flush-logs等权限</td></tr><tr><td>SHUTDOWN</td><td>创建临时表权限</td></tr><tr><td>SHOW DATABASES</td><td>关闭数据库权限</td></tr><tr><td>LOCK TABLES</td><td>可对其下所有表进行锁定权限</td></tr><tr><td>REFERENCES</td><td>未来MySQL特性的占位符</td></tr><tr><td>REPLICATION CLIENT</td><td>复制权限</td></tr><tr><td>REPLICATION SLAVE</td><td>复制权限</td></tr><tr><td>CREATE USER</td><td>创建用户权限</td></tr></table></div>



<h4 id="MySQL的权限操作（以root用户登录到数据库进行操作）"><a href="#MySQL的权限操作（以root用户登录到数据库进行操作）" class="headerlink" title="MySQL的权限操作（以root用户登录到数据库进行操作）"></a>MySQL的权限操作（以root用户登录到数据库进行操作）</h4><h5 id="一）创建用户"><a href="#一）创建用户" class="headerlink" title="一）创建用户"></a>一）创建用户</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> CREATE USER <span class="string">'username'</span>@<span class="string">'localhost'</span> IDENTIFIED BY <span class="string">'password'</span>;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> CREATE USER <span class="string">'username1'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'password1'</span>;</span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>username为用户名</p>
<p>password为用户密码</p>
<p>localhost只允许在本机登录数据库</p>
<p>%任何一台电脑上都可以远程登陆</p>
<h5 id="二）受理权限"><a href="#二）受理权限" class="headerlink" title="二）受理权限"></a>二）受理权限</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> GRANT privileges ON databasename.tablename TO <span class="string">'username'</span>@<span class="string">'localhost'</span>;</span></span><br></pre></td></tr></table></figure>

<p>注：</p>
<p>privileges为用户操作权限，例如select等，如果需要所有权限直接写all</p>
<p>databasename为数据库名，给某个用户访问某个数据库的权限，如果给某个用户所有库的访问权限可以用*表示</p>
<p>tablename为表名，如果为某个库下的所有表可以用*号表示</p>
<h5 id="三）撤销用户权限"><a href="#三）撤销用户权限" class="headerlink" title="三）撤销用户权限"></a>三）撤销用户权限</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> REVOKE privilege ON databasename.tablename FROM <span class="string">'username'</span>@<span class="string">'localhost'</span>;</span></span><br></pre></td></tr></table></figure>

<h5 id="四）删除账号及权限"><a href="#四）删除账号及权限" class="headerlink" title="四）删除账号及权限"></a>四）删除账号及权限</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> REVOKE privilege ON databasename.tablename FROM <span class="string">'username'</span>@<span class="string">'localhost'</span>;</span></span><br></pre></td></tr></table></figure>

<h5 id="五）查看用户的权限信息"><a href="#五）查看用户的权限信息" class="headerlink" title="五）查看用户的权限信息"></a>五）查看用户的权限信息</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> SHOW GRANTS FOR <span class="string">'username'</span>@<span class="string">'localhost'</span>;</span></span><br></pre></td></tr></table></figure>
<h5 id="六）刷新权限操作"><a href="#六）刷新权限操作" class="headerlink" title="六）刷新权限操作"></a>六）刷新权限操作</h5><p>这里我需要着重的强调一下，如果使用delete对数据库用户删除后需要执行一遍刷新flush privileges;否则会报有1396错误；建议还是使用drop等相关命令进行做删除用户操作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> flush privileges;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS6.9</tag>
        <tag>MySQL5.7</tag>
        <tag>MySQL权限分类</tag>
        <tag>MySQL5.7权限分配</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7定时清理buff/cache内存占用过高</title>
    <url>/blog/2018/03/20/CentOS7%E5%AE%9A%E6%97%B6%E6%B8%85%E7%90%86buffcache%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/</url>
    <content><![CDATA[<p>最近因为公司事物过多，没有时间去更新博客，今天在查看自己博客的时候发现，应该对之前的一片文章<a href="http://120.79.151.66:4000/2018/02/06/buffcache%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/" target="_blank" rel="noopener">buff / cache内存占用过高</a>进行更深度的讲解，以及通过定时任务，解放人为清理的麻烦。</p>
<p>首先，在linux系统中想到自动化处理任务，无疑就是crontab，crontab就是linux系统中的自动化处理的程序，在默认的情况下，系统是自带crontab程序的，只是处于关闭状态，但是本篇文章依旧为大家提供crontab的安装方式。</p>
<p>1.安装crontab</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install vixie-cron</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install crontabs</span></span><br></pre></td></tr></table></figure>

<p>2.查看crond.service的服务自启动状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl is-enabled crond.service</span></span><br><span class="line">disabled</span><br></pre></td></tr></table></figure>

<p>3.使crond.service的服务在开机时自启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> crond.service</span></span><br></pre></td></tr></table></figure>

<p>4.再次查看crond.service的服务自启动状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl is-enabled crond.service</span></span><br><span class="line">enabled</span><br></pre></td></tr></table></figure>

<p>5.其他关于crond.service操作的基本命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl start crond.service // 启动</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl stop crond.service // 关闭</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl restart crond.service // 重启</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl reload crond.service // 重新载入配置</span></span><br></pre></td></tr></table></figure>

<p>6.crontab文件格式</p>
<p><img src="/blog/images/images/CentOS7%E5%AE%9A%E6%97%B6%E6%B8%85%E7%90%86buffcache%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/%E6%9F%A5%E7%9C%8Bcrontab%E8%A7%84%E5%88%99.png" alt="查看crontab规则"></p>
<p>7.crontab的特殊字符</p>
<blockquote>
<p>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</p>
<p>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”。</p>
<p>中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”。</p>
<p>正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。</p>
</blockquote>
<p>8.接下来我们要创建一个shell脚本，里面存放一个清除buff / cache的命令，通过让crontab在什么时间去执行这个shell脚本，而实现定时清理的任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /home/automaticallyCleanUpMemory.sh</span></span><br></pre></td></tr></table></figure>

<p>9.在文件中写入清理buff / cache的命令，推出保存</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>

<p>10.定时任务相关操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> crontab -e // 创建一个定时任务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> crontab -l // 列出当前用户的定时任务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> crontab -r // 删除当前用户的定时任务</span></span><br></pre></td></tr></table></figure>

<p>11.创建一个定时任务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> crontab -e</span></span><br></pre></td></tr></table></figure>

<p>12.将什么时候执行什么任务写在任务中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">0 4 * * * /home/automaticallyCleanUpMemory.sh</span><br><span class="line">// 每天早上四点执行一次automaticallyCleanUpMemory.sh脚本</span><br></pre></td></tr></table></figure>

<p>到这里我们的自动清理buff / cache内存的方法就介绍完了，接下来介绍一些相关的其他操作示例</p>
<p>示例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">* * * * * /home/automaticallyCleanUpMemory.sh </span><br><span class="line">// 每一分钟执行一次</span><br><span class="line">10,15 * * * * /home/automaticallyCleanUpMemory.sh</span><br><span class="line">// 每小时的第十分钟和第十五分钟执行一次</span><br><span class="line">15 8 * * * /home/automaticallyCleanUpMemory.sh</span><br><span class="line">// 每天早上八点十五执行一次</span><br><span class="line">15 8 1 jan * /home/automaticallyCleanUpMemory.sh</span><br><span class="line">// 一月一号的早上八点十五执行一次</span><br><span class="line">0 6 * * 6 /home/automaticallyCleanUpMemory.sh</span><br><span class="line">// 每个星期六的早上六点执行一次</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>crontab</tag>
        <tag>buff/cache</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos6.9安装MySQL5.7，以及数据库迁移</title>
    <url>/blog/2018/03/05/Centos6.9%E5%AE%89%E8%A3%85MySQL5.7/</url>
    <content><![CDATA[<p>身为一名佛系程序员，在一个佛系公司上班，真是身不由己，一切随缘。这不因为公司没有运维我又干起了运维的活，这次主要是介绍一下如何在Centos6.9环境下安装MySQL5.7。这时候就有小伙伴问了，为什么要用Centos6.9不用7.4呢，说起来都是泪啊，公司没几个会的啊，我倒是想用7.4，泪奔。</p>
<p>（一）下载四个软件包到/home下（可以自己选择下载路径）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> wget http://mirrors.sohu.com/mysql/MySQL-5.7/mysql-community-client-5.7.18-1.el6.x86_64.rpm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wget http://mirrors.sohu.com/mysql/MySQL-5.7/mysql-community-common-5.7.18-1.el6.x86_64.rpm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wget http://mirrors.sohu.com/mysql/MySQL-5.7/mysql-community-libs-5.7.18-1.el6.x86_64.rpm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> wget http://mirrors.sohu.com/mysql/MySQL-5.7/mysql-community-server-5.7.18-1.el6.x86_64.rpm</span></span><br></pre></td></tr></table></figure>

<p>（二）检查mysql rpm相关的包是否安装并去除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rpm -qa | grep -i mysql</span></span><br><span class="line">mysql-libs-5.1.73-8.el6_8.x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> rpm -e mysql-libs-5.1.73-8.el6_8.x86_64</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum remove -y mysql-libs // 删除依赖包</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rpm -qa | grep -i mysql // 在此查询如果没有信息显示则表示删除成功</span></span><br></pre></td></tr></table></figure>

<p>（三）同时安装这四个rpm包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rpm -ivh mysql-community-client-5.7.18-1.el6.x86_64.rpm mysql-community-common-5.7.18-1.el6.x86_64.rpm mysql-community-libs-5.7.18-1.el6.x86_64.rpm mysql-community-server-5.7.18-1.el6.x86_64.rpm</span></span><br></pre></td></tr></table></figure>

<p>（四）如果安装时提示缺少依赖执行numactl的安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rpm -ivh mysql-community-client-5.7.18-1.el6.x86_64.rpm mysql-community-common-5.7.18-1.el6.x86_64.rpm mysql-community-libs-5.7.18-1.el6.x86_64.rpm mysql-community-server-5.7.18-1.el6.x86_64.rpm</span></span><br><span class="line">warning: mysql-community-client-5.7.18-1.el6.x86_64.rpm: Header V3 DSA/SHA1 Signature, key ID 5072e1f5: NOKEY</span><br><span class="line">error: Failed dependencies:</span><br><span class="line">libnuma.so.1()(64bit) is needed by mysql-community-server-5.7.18-1.el6.x86_64</span><br><span class="line">libnuma.so.1(libnuma_1.1)(64bit) is needed by mysql-community-server-5.7.18-1.el6.x86_64</span><br><span class="line">libnuma.so.1(libnuma_1.2)(64bit) is needed by mysql-community-server-5.7.18-1.el6.x86_64</span><br><span class="line"><span class="meta">#</span><span class="bash"> yum install -y numactl</span></span><br></pre></td></tr></table></figure>

<p>到这里，基本的安装就已经完成了，接下来我们要对数据库进行基本的设置，通过基本设置后我们会进行数据的迁移工作。</p>
<p>（一）首先停止掉MySQL的服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> service mysqld stop</span></span><br></pre></td></tr></table></figure>

<p>（二）跳过MySQL密码认证，在[mysqld]后面任意一行添加“skip-grant-tables”用来跳过密码验证的过程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/my.cnf</span></span><br></pre></td></tr></table></figure>

<p>（三）重新启动MySQL服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> service mysqld start</span></span><br></pre></td></tr></table></figure>

<p>（四）重启后通过mysql命令即可进入到数据库中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mysql</span></span><br></pre></td></tr></table></figure>

<p>（五）使用sql修改数据库的密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> use mysql; // 使用这个数据库</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> update user <span class="built_in">set</span> password=password(<span class="string">"你的新密码"</span>) <span class="built_in">where</span> user=<span class="string">"root"</span>; // 设置密码</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> flush privileges; // 立即生效</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> quit // 退出数据库</span></span><br></pre></td></tr></table></figure>

<p>（六）去掉配置文件中的“skip-grant-tables”，并且重启MySQL服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> service mysqld restart</span></span><br></pre></td></tr></table></figure>

<p>在配置完数据库的基本设置后，就要进行数据库的数据搬迁，首先要准备两个数据库，我这里用的是公司的两台数据库服务器。</p>
<p>原有数据库服务器：10.2.8.123</p>
<p>新的数据库服务器：10.2.8.128</p>
<p>（一）在原有数据库服务器上操作，讲数据和表结构导出成sql文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mysqldump -uroot -p dbname &gt; /home/dbname .sql // 导出数据和表结构</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mysqldump -uroot -p -d dbname &gt; dbname .sql // 只导出表结构</span></span><br></pre></td></tr></table></figure>

<p>（二）在新的数据库服务器上操作，讲原有服务器上备份的sql文件复制到新服务器上（注：如果没有配置ssh免密登录，在执行如下命令时会提示输入密码，如果想跳过此步骤，请参考<a href="http://120.79.151.66:4000/2018/02/28/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9/" target="_blank" rel="noopener">ssh免密登录</a>）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> scp root@10.2.8.123:/home/dbname.sql /home</span></span><br></pre></td></tr></table></figure>

<p>（三）在新机器上导入拷贝过来的sql</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> create database dbname; // 创建数据库</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> use dbname; // 使用数据库</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">set</span> names utf8; // 设置数据库编码格式</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> <span class="built_in">source</span> /home/dbname.sql; // 把sql文件导入到数据库</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL5.7</tag>
        <tag>Centos6.9</tag>
        <tag>数据库迁移</tag>
        <tag>scp</tag>
      </tags>
  </entry>
  <entry>
    <title>Centos7升级内核</title>
    <url>/blog/2018/06/30/Centos7%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<p>内核主要有两种作用：</p>
<p>1.作为硬件和系统上运行的软件之间的接口；</p>
<p>2.尽可能地高效管理资源；</p>
<p>为此，内核通过内置的驱动程序或以后可作为模块安装的驱动程序与硬件通信。 </p>
<p>例如，当你计算机上运行的程序想要连接到无线网络时，它会将该请求提交给内核，后者又会使用正确的驱动程序连接到网络。 </p>
<p>随着新的设备和技术定期出来，如果我们想充分利用它们，保持最新的内核就很重要。此外，更新内核将帮助我们利用新的内核函数，并保护自己免受先前版本中发现的漏洞的攻击。 </p>
<p style="color: red;">*这篇文章的方式支持发行版本种Centos7系统上进行操作</p>

<h5 id="检查已安装的内核版本"><a href="#检查已安装的内核版本" class="headerlink" title="检查已安装的内核版本"></a>检查已安装的内核版本</h5><p>当前我的系统内核版本为Linux 3.10.0-862.3.3.el7.x86_64</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uname -sr</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/Centos7%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/666.png" alt="666"></p>
<h5 id="在系统中启用ELRepo第三方库"><a href="#在系统中启用ELRepo第三方库" class="headerlink" title="在系统中启用ELRepo第三方库"></a>在系统中启用ELRepo第三方库</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-2.el7.elrepo.noarch.rpm</span></span><br></pre></td></tr></table></figure>

<h5 id="列出可用的内核相关包"><a href="#列出可用的内核相关包" class="headerlink" title="列出可用的内核相关包"></a>列出可用的内核相关包</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum --disablerepo=<span class="string">"*"</span> --enablerepo=<span class="string">"elrepo-kernel"</span> list available</span></span><br></pre></td></tr></table></figure>

<h5 id="安装最新的主线稳定内核"><a href="#安装最新的主线稳定内核" class="headerlink" title="安装最新的主线稳定内核"></a>安装最新的主线稳定内核</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum --enablerepo=elrepo-kernel install kernel-ml</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/Centos7%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/1530331787.jpg" alt="1530331787(1)"></p>
<h5 id="设置默认内核版本"><a href="#设置默认内核版本" class="headerlink" title="设置默认内核版本"></a>设置默认内核版本</h5><p>编辑/etc/default/grub 文件中的GRUB_DEFAULT 将值设置为0.意思是 GRUB 初始化页面的第一个内核将作为默认内核 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">GRUB_TIMEOUT=5</span><br><span class="line">GRUB_DEFAULT=0</span><br><span class="line">GRUB_DISABLE_SUBMENU=true</span><br><span class="line">GRUB_TERMINAL_OUTPUT="console"</span><br><span class="line">GRUB_CMDLINE_LINUX="rd.lvm.lv=centos/root rd.lvm.lv=centos/swap crashkernel=auto rhgb quiet"</span><br><span class="line">GRUB_DISABLE_RECOVERY="true"</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/Centos7%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/1530332090.jpg" alt="1530332090(1)"></p>
<h5 id="重新创建内核配置"><a href="#重新创建内核配置" class="headerlink" title="重新创建内核配置"></a>重新创建内核配置</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> grub2-mkconfig -o /boot/grub2/grub.cfg</span></span><br></pre></td></tr></table></figure>

<h5 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h5><p><img src="/blog/images/Centos7%E5%8D%87%E7%BA%A7%E5%86%85%E6%A0%B8/1530332137.jpg" alt="1530332137(1)"></p>
<h5 id="重新查看内核版本为最新内核版本"><a href="#重新查看内核版本为最新内核版本" class="headerlink" title="重新查看内核版本为最新内核版本"></a>重新查看内核版本为最新内核版本</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> uname -sr</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
      </tags>
  </entry>
  <entry>
    <title>cocos creator简述</title>
    <url>/blog/2020/09/28/CocosCreator%E7%AE%80%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><blockquote>
<p><code>scene</code>： 场景<br><code>canvas</code>： 画布<br><code>prefab</code>： 预制体<br><code>animation</code>： 动画<br><code>sprite</code>： 精灵<br><code>position</code>： 精灵位置<br><code>rotate</code>： 精灵旋转<br><code>scale</code>： 精灵缩放<br><code>opacity</code>： 精灵透明度<br><code>color</code>： 精灵颜色<br><code>anchor</code>： 基点<br><code>texture</code>： 图片资源<br><code>sound</code>： 声音资源<br><code>node</code>： 节点</p>
</blockquote>
<hr>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><blockquote>
<p><a href="https://www.cocos.com/" target="_blank" rel="noopener">Cocos Creator</a><br><a href="https://docs.cocos.com/creator/manual/zh/getting-started/basics/editor-overview.html" target="_blank" rel="noopener">Cocos Creator编辑器基础</a><br><a href="https://docs.cocos.com/creator/manual/zh/extension/reference/meta-reference.html?h=meta" target="_blank" rel="noopener">meta文件介绍</a><br><a href="https://docs.cocos.com/creator/manual/zh/components/sprite.html?h=size%20mode" target="_blank" rel="noopener">Sprite精灵组件中的Size Mode属性</a><br><a href="https://docs.cocos.com/creator/manual/zh/asset-workflow/prefab.html?h=prefab" target="_blank" rel="noopener">Prefab介绍</a><br><a href="https://docs.cocos.com/creator/manual/zh/components/animation.html?h=animation" target="_blank" rel="noopener">Animation介绍</a><br><a href="https://docs.cocos.com/creator/manual/zh/animation/animation.html#clip-%E5%8A%A8%E7%94%BB%E5%89%AA%E8%BE%91" target="_blank" rel="noopener">AnimationClip介绍</a><br><a href="https://docs.cocos.com/creator/manual/zh/getting-started/quick-start.html?h=instantiate" target="_blank" rel="noopener">instantiate方法</a><br><a href="https://docs.cocos.com/creator/manual/zh/scripting/access-node-component.html?h=getcomponent" target="_blank" rel="noopener">getComponent方法</a><br><a href="https://docs.cocos.com/creator/manual/zh/scripting/scene-managing.html" target="_blank" rel="noopener">场景切换与加载</a><br><a href="https://docs.cocos.com/creator/manual/zh/scripting/internal-events.html" target="_blank" rel="noopener">节点系统事件</a></p>
</blockquote>
<hr>
<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="引擎基本介绍"><a href="#引擎基本介绍" class="headerlink" title="引擎基本介绍"></a>引擎基本介绍</h3><ul>
<li><p><code>cocos creator</code>是一个完整的游戏开发解决方案，包含了轻量高效的跨平台游戏引擎，以及能让你更快速开发游戏所需要的各种图形界面工具。</p>
</li>
<li><p><code>cocos creator</code>的编辑器是完全为引擎定制打造，包含从设计、开发、预览、调试到发布的整个工作流所需的全功能一体化编辑器。</p>
</li>
<li><p><code>cocos creator</code>支持<code>web</code>、<code>ios</code>、<code>android</code>、各类”小游戏”、<code>pc</code>客户端等平台。</p>
</li>
</ul>
<hr>
<h3 id="游戏基本概念"><a href="#游戏基本概念" class="headerlink" title="游戏基本概念"></a>游戏基本概念</h3><p>在游戏开发的过程中会设定如<code>scene</code>、<code>canvas</code>、<code>prefab</code>、<code>animation</code>、<code>sprite</code>、<code>anchor</code>等基本概念，如果涉及其它概念请参阅官网介绍。</p>
<ul>
<li><p><code>scene</code>：代指游戏中的场景，每个场景都是由不同的物体组合而成的一个集合，可以是建筑、特效、道具等。<br>  在游戏开发过程中场景管理的意义在于方便开发者快速定位到场景中的不同物体、能够处理巨大场景带来的内存开销问题和渲染效率问题、减少判断不同物体边界碰撞的检测效率问题。<br>  对于<code>2d</code>的游戏场景在内存和渲染的开销上都会远远小于<code>3d</code>游戏的场景。</p>
</li>
<li><p><code>canvas</code>：画布可以隶属于任何一个节点下，但是通常情况下在一个<code>scene</code>场景下只应有一个层级最高的<code>canvas</code>，所有的<code>ui</code>和可渲染元素都应设置为层级最高的<code>canvas</code>的子节点。<br>  <code>canvas</code>能够随时获得设备屏幕的实际分辨率并对场景中所有渲染元素进行适当的缩放。</p>
</li>
<li><p><code>prefab</code>：是一种资源类型，是一个能够在项目中反复使用的一个对象，因而当遇到需要反复使用的对象或资源时可以使用<code>prefab</code>，如游戏中的弹出框。<br>  <code>prefab</code>允许放置在多个<code>scene</code>中，也可以在一个<code>scene</code>中使用多个<code>prefab</code>。<br>  当一个<code>prefab</code>被放置在了一个<code>scene</code>中，就相当于在<code>scene</code>中创建了一个<code>prefab</code>实例。<br>  如果一个<code>prefab</code>在不同的<code>scene</code>中被实例化了多次，只需修改<code>prefab</code>就可以达到全部修改的效果。</p>
</li>
<li><p><code>animation</code>：作为动画可以使用在任何一种物体组件上。<br>  一般一个游戏会制作很多种动画，其中一部分可以通过组件自动调用，另一部分也可以通过代码去调用。</p>
</li>
<li><p><code>sprite</code>：精灵是游戏中十分重要的组成部分，每一个物体都可以理解为一个精灵元素，如游戏的背景、人物模型、道具等。<br>  <code>sprite</code>可以是一个允许被用户控制的对象，也可以是一个跟用户操作无关的对象。<br>  <code>sprite</code>的属性包含很多，如<code>position</code>、<code>rotate</code>、<code>scale</code>，<code>opacity</code>，<code>color</code>等。<br>  <code>sprite</code>包括单色精灵和普通精灵，两者的区别在于单色精灵创建后会有个纯白色的背景，通过设置背景颜色可以更改纯白色背景，而普通精灵则是创建了一个透明的背景。<br>  单色精灵和普通精灵在<code>Sprite</code>精灵组件的<code>Size Mode</code>属性上有不同的差异。</p>
</li>
<li><p><code>anchor</code>：基点可以理解为游戏中所有物体或组件的一个对齐点，如果一个游戏中存在多个<code>scene</code>，则允许对<code>scene</code>设置不同的基点。<br>  基点的坐标<code>x: 0, y: 0</code>表示左下角，<code>x: 1, y: 1</code>表示右上角。<br>  基点的改变会影响该<code>node</code>下的所有元素。</p>
</li>
</ul>
<hr>
<h3 id="创建一个基于cocos引擎的项目"><a href="#创建一个基于cocos引擎的项目" class="headerlink" title="创建一个基于cocos引擎的项目"></a>创建一个基于<code>cocos</code>引擎的项目</h3><ul>
<li>打开<code>Cocos Dashboard</code>控制台。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601429624326.jpg" alt="cocos dashboard控制台"></p>
<ul>
<li>点击<code>Cocos Dashboard</code>控制台左侧菜单中的编辑器按钮，下载用于游戏开发<code>CocosCreator</code>编辑器。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601429920794.jpg" alt="CocosCreator编辑器"></p>
<ul>
<li>点击<code>Cocos Dashboard</code>控制台左侧菜单中的项目按钮，点击右下角可以创建一个<code>Creator</code>或<code>Creator 3D</code>项目。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/7814A061-DC9F-4A86-9BD3-19C7DD951B4F.png" alt="创建项目"></p>
<ul>
<li>可以根据自己的需求进行初始的项目模板选择、项目名称、项目路径等，选择后点击创建并打开按钮，即可完成项目的创建。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601430679113.jpg" alt="选择项目模板"></p>
<hr>
<h3 id="项目管理与多人协作"><a href="#项目管理与多人协作" class="headerlink" title="项目管理与多人协作"></a>项目管理与多人协作</h3><ul>
<li><p>通常情况下开发者会使用<code>git</code>进行项目的管理，针对<code>CocosCreator</code>编辑器可视化界面的操作也是可以通过<code>git</code>进行管理的。</p>
</li>
<li><p>在项目创建后开发者可以在编辑器的资源管理器里面看到整个项目的目录结构，开发者只需管理<code>assets</code>目录即可，针对<code>internal</code>目录则是引擎自动为你创建的一个不可变动的目录。</p>
</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601433806377.jpg" alt="资源管理器"></p>
<hr>
<h3 id="项目目录介绍"><a href="#项目目录介绍" class="headerlink" title="项目目录介绍"></a>项目目录介绍</h3><ul>
<li><p><code>assets</code>目录是需要进行代码管理的，这个文件夹下会记录所有在<code>CocosCreator</code>编辑器可视化界面的操作。</p>
</li>
<li><p>之所以能与可视化编辑器做关联是因为在可视化编辑器操作的每一个属性都会与之对应的<code>prefab</code>或<code>scene</code>等资源做关联，可视化编辑器就相当于在操作资源中的某一个对象或属性。</p>
</li>
<li><p>在<code>assets</code>目录下每创建一个文件或者文件夹都会生成一个对应名称的<code>meta</code>文件，<code>meta</code>文件用于记录引擎使用该资源时所需的数据。</p>
</li>
<li><p>在对文件或文件夹执行创建、修改和删除操作的时候建议在<code>CocosCreator</code>编辑器中执行，通过<code>CocosCreator</code>编辑器之外对文件或文件夹的任何操作都无法记录到<code>meta</code>文件。</p>
</li>
<li><p><code>Cocos</code>游戏引擎的资源管理器是按照<code>uid</code>进行区分的，不是传统的按照文件路径进行区分，所以开发者无法设置相同的资源名称，如<code>scripts -&gt; login -&gt; index.js</code>和<code>scripts -&gt; home -&gt; index.js</code>也是会被引擎是别成一个相同的文件。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assets&#x2F;</span><br><span class="line">├─scripts &#x2F;&#x2F; 脚本文件夹</span><br><span class="line">├─scripts.meta</span><br><span class="line">|    ├─utils &#x2F;&#x2F; 公共脚本文件夹</span><br><span class="line">|    ├─utils.meta</span><br><span class="line">├─scenes &#x2F;&#x2F; 场景文件夹</span><br><span class="line">├─scenes.meta</span><br><span class="line">├─resources &#x2F;&#x2F; 静态资源文件夹</span><br><span class="line">├─resources.meta</span><br><span class="line">|    ├─textures &#x2F;&#x2F; 纹理、图片资源文件夹</span><br><span class="line">|    ├─textures.meta</span><br><span class="line">|    ├─sounds &#x2F;&#x2F; 声音资源文件夹</span><br><span class="line">|    ├─sounds.meta</span><br><span class="line">|    ├─fonts &#x2F;&#x2F; 字体资源文件夹</span><br><span class="line">|    ├─fonts.meta</span><br><span class="line">├─prefabs &#x2F;&#x2F; 预制体文件夹</span><br><span class="line">├─prefabs.meta</span><br><span class="line">├─animations &#x2F;&#x2F; 动画文件夹</span><br><span class="line">├─animations.meta</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="scene"><a href="#scene" class="headerlink" title="scene"></a><code>scene</code></h2><ul>
<li><p>在游戏开发的过程中，开发者可以把<code>scene</code>理解为一个<code>html</code>页面，页面之间的切换就是<code>scene</code>之间的切换。</p>
</li>
<li><p><code>html</code>页面中的<code>button</code>、<code>table</code>都可以理解成<code>scene</code>中的一个物体元素组件。</p>
</li>
<li><p>文章下面会介绍如何在<code>scene</code>添加一个背景图片，如果想添加其它组件，其原理和操作方式大相径庭，所以不多做举例。</p>
</li>
</ul>
<hr>
<h3 id="创建scene"><a href="#创建scene" class="headerlink" title="创建scene"></a>创建<code>scene</code></h3><ul>
<li>创建<code>scenes</code>文件夹，并在<code>scenes</code>文件夹下创建一个名为<code>index</code>的<code>scene</code>场景。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/create_scene.png" alt="创建场景"></p>
<hr>
<h3 id="进入scene编辑状态"><a href="#进入scene编辑状态" class="headerlink" title="进入scene编辑状态"></a>进入<code>scene</code>编辑状态</h3><ul>
<li>通过点击创建好的<code>index</code>场景文件，进入场景的可视化编辑。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601444413564.jpg" alt="进入场景编辑状态"></p>
<hr>
<h3 id="设置scene中canvas的尺寸"><a href="#设置scene中canvas的尺寸" class="headerlink" title="设置scene中canvas的尺寸"></a>设置<code>scene</code>中<code>canvas</code>的尺寸</h3><ul>
<li><p>点击层级管理器中的根<code>canvas</code>节点后，属性检查器也对对应的发生变化。</p>
</li>
<li><p>属性检查器会对应当前在层级管理器中选中的节点。</p>
</li>
<li><p>作为开发者没有办法去直接修改一个<code>scene</code>中根<code>canvas</code>节点上的<code>size</code>属性，但是可以通过修改根节点上<code>Canvas</code>组件的画布中的<code>Design Resolution</code>属性的尺寸。</p>
</li>
<li><p><code>scene</code>中<code>canvas</code>的尺寸取决于<code>ui</code>设计图的尺寸。</p>
</li>
<li><p><code>canvas</code>会根据不同的屏幕自动进行一定的适配，但是这并不是最完全的解决方案。</p>
</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601445429445.jpg" alt="修改场景中画布的尺寸"></p>
<hr>
<h3 id="在scene中添加背景图片"><a href="#在scene中添加背景图片" class="headerlink" title="在scene中添加背景图片"></a>在<code>scene</code>中添加背景图片</h3><ul>
<li><p>通常情况下一个<code>scene</code>场景是需要一个甚至多个背景图片的。</p>
</li>
<li><p>在<code>scene</code>中添加背景图片需要在根<code>Canvas</code>组件的节点下创建一个<code>sprite</code>精灵元素，通过给<code>sprite</code>精灵元素设置尺寸与背景图片进而实现场景中有背景图片的效果。</p>
</li>
<li><p>出于要设置<code>scene</code>的背景图片，所以这里选择普通精灵组件进行设置。</p>
</li>
<li><p>更改<code>scene</code>中的根节点上<code>Canvas</code>组件尺寸为<code>1280*720</code>。</p>
</li>
<li><p>创建一个普通的<code>Sprite</code>组件，右键层级选择器中的<code>Sprite</code>组件重命名为<code>background</code>。</p>
</li>
<li><p>将资源管理器中的背景图片拖拽到名为<code>background</code>的<code>Sprite</code>精灵组件中<code>Sprite Frame</code>上。</p>
</li>
<li><p>设置<code>background</code>精灵的大小。</p>
</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601448150617.jpg" alt="设置场景背景图片"></p>
<hr>
<h2 id="prefab"><a href="#prefab" class="headerlink" title="prefab"></a><code>prefab</code></h2><ul>
<li><p><code>prefab</code>是一个想要用在一个或多个项目中一个组件节点。</p>
</li>
<li><p><code>prefab</code>一旦创建后并且层级管理的<code>node</code>节点也被删除后，该<code>node</code>节点的信息不会自动在项目中加入，需要使用脚本进行控制。</p>
</li>
<li><p>当一个节点被拖拽转变成了<code>prefab</code>后，可以在层级管理器对该节点进行删除，如果想要对<code>prefab</code>有更改，可以在资源管理器中双击该<code>prefab</code>。</p>
</li>
<li><p><code>prefab</code>的根节点一般是一个空的<code>Node</code>组件，切该<code>Node</code>组件下允许有多个组件或脚本文件。</p>
</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601453429993.jpg" alt="创建空节点"></p>
<ul>
<li><code>prefab</code>并不能通过资源管理器进行创建，只能将一部分的节点从层级管理器中拖拽到资源管理器的一个目标路径。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601453581158.jpg" alt="拖拽节点成Prefab"></p>
<hr>
<h2 id="animation"><a href="#animation" class="headerlink" title="animation"></a><code>animation</code></h2><ul>
<li><p><code>animation</code>是一个帧动画，它允许控制组件上所有属性动画，如：宽、高、缩放等。</p>
</li>
<li><p>一个<code>animation</code>上允许设置多个属性的动画。</p>
</li>
<li><p><code>animation</code>有两种播放形式，一种为自动播放，另一种为脚本调用。</p>
</li>
<li><p>当你的想从动画编辑器转身去做其它任何操作的时候，一定要关闭动画编辑器，否则会有动画无法保存的情况。</p>
</li>
</ul>
<hr>
<h3 id="创建animation"><a href="#创建animation" class="headerlink" title="创建animation"></a>创建<code>animation</code></h3><ul>
<li><p>点击想要创建动画的节点，并打开动画编辑器。</p>
</li>
<li><p>当节点上没有<code>Animation</code>是，可以通过属性检查器添加或者通过动画编辑器进行添加。</p>
</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601457135329.jpg" alt="创建animation"></p>
<hr>
<h3 id="创建clip"><a href="#创建clip" class="headerlink" title="创建clip"></a>创建<code>clip</code></h3><ul>
<li><code>clip</code>动画剪辑就是一份动画的声明数据，需要将它挂载到<code>Animation</code>组件上，就能够将这份动画数据应用到节点上。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601458180992.jpg" alt="创建clip"></p>
<hr>
<h3 id="绑定clip到animation"><a href="#绑定clip到animation" class="headerlink" title="绑定clip到animation"></a>绑定<code>clip</code>到<code>animation</code></h3><ul>
<li>将创建好的<code>clip</code>从资源管理器拖拽到属性检查器中<code>Animation</code>组件的<code>Default Clip</code>属性上。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601458653128.jpg" alt="绑定clip到animation"></p>
<hr>
<h3 id="打开动画编辑器编辑功能"><a href="#打开动画编辑器编辑功能" class="headerlink" title="打开动画编辑器编辑功能"></a>打开动画编辑器编辑功能</h3><ul>
<li>打开动画编辑器进行编辑，关闭动画编辑器的编辑功能也是该按钮。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601459099288.jpg" alt="打开动画编辑器进行编辑"></p>
<ul>
<li>动画编辑器的节点与<code>Animation</code>组件所在的节点是相同的，并且动画可操作的属性也是<code>Animation</code>组件所属节点的属性。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601599450411.jpg" alt="打开动画编辑器进行编辑"></p>
<hr>
<h3 id="添加一个scale动画"><a href="#添加一个scale动画" class="headerlink" title="添加一个scale动画"></a>添加一个<code>scale</code>动画</h3><ul>
<li><p>这里实现的是一个简单的<code>scale</code>动画，其它类型的动画和动画组合不再讲述。</p>
</li>
<li><p>选择<code>scale</code>制作一个缩放的动画，在修改属性检查器中的<code>Scale</code>属性的时候，动画编辑器会自动为开发者插入一个关键帧。</p>
</li>
<li><p>如果没有开启动画编辑器的编辑状态，则不会动态创建一个关键帧。</p>
</li>
<li><p>在设置<code>Scale</code>属性值为<code>0</code>的时候，则该节点不会进行显示。</p>
</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601601452462.jpg" alt="添加动画第一帧"></p>
<ul>
<li>设置动画结束时间为<code>1.5</code>秒，并将动画编辑器中的播放头（红色竖线）拖拽到<code>0:15</code>的位置。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601601778261.jpg" alt="拖动播放头"></p>
<ul>
<li>设置属性检查器中的<code>Scale</code>属性，将其值为<code>1</code>。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601601913242.jpg" alt="设置结束值"></p>
<ul>
<li>点击动画编辑器中的播放按钮，查看编辑后的动画效果。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/QQ20201002-093007-HD.gif" alt="查看动画效果"></p>
<hr>
<h2 id="预览方式"><a href="#预览方式" class="headerlink" title="预览方式"></a>预览方式</h2><ul>
<li>预览能够帮助开发者查看到当前的效果，通常预览方式有三种，分别为浏览器预览、模拟器预览、真机预览。</li>
</ul>
<hr>
<h3 id="浏览器预览和模拟器预览"><a href="#浏览器预览和模拟器预览" class="headerlink" title="浏览器预览和模拟器预览"></a>浏览器预览和模拟器预览</h3><ul>
<li><p><code>CocosCreator</code>编辑器最顶部中间位置上的播放按钮为浏览器预览和模拟器预览。</p>
</li>
<li><p>浏览器预览不会自动播放背景音乐，需要进行一次点击才会播放。</p>
</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601449503406.jpg" alt="浏览器预览和模拟器预览"></p>
<hr>
<h3 id="真机预览"><a href="#真机预览" class="headerlink" title="真机预览"></a>真机预览</h3><ul>
<li><p>真机预览在<code>CocosCreator</code>编辑器右上角位置。</p>
</li>
<li><p>真机预览可以使用手机上的任何带有扫描二维码功能的软件进行扫码预览。</p>
</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601449536008.jpg" alt="真机局域网预览"></p>
<hr>
<h2 id="脚本操作"><a href="#脚本操作" class="headerlink" title="脚本操作"></a>脚本操作</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul>
<li><p>由于脚本存在一定的逻辑性和业务导向性，所以在这里只做一些简单的介绍，更多的请前往官网查看相关<code>api</code>。</p>
</li>
<li><p><code>Cocos</code>游戏引擎允许开发者使用<code>JavaScript</code>语言进行编写，这点对于前端工作人员是非常友好的，不仅<code>Cocos</code>一家，很多游戏引擎都支持<code>JavaScript</code>。</p>
</li>
<li><p>在游戏的脚本开发中，允许开发者使用代码去实现一些无法通过可视化编辑器操作的业务逻辑，如：接口、动态创建节点、修改节点属性、全局的事件分发机制等。</p>
</li>
</ul>
<hr>
<h3 id="脚本模板"><a href="#脚本模板" class="headerlink" title="脚本模板"></a>脚本模板</h3><ul>
<li><p><code>cc.Class</code>用于声明<code>Cocos Creator</code>中的类。它是一个很常用的<code>api</code>。</p>
</li>
<li><p><code>extends: cc.Component</code>基类，可以是任意创建好的<code>cc.Class</code>。</p>
</li>
<li><p><code>properties</code>用于属性值的定义。</p>
</li>
<li><p><code>onLoad</code>加载节点。</p>
</li>
<li><p><code>start</code>所有节点都执行完<code>onLoad</code>后才执行。</p>
</li>
<li><p><code>update</code>会在场景加载完成后每一帧都执行一次，一般把需要经常计算或及时更新的逻辑内容放在<code>update</code>中。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cc.Class(&#123;</span><br><span class="line">    extends: cc.Component,</span><br><span class="line"></span><br><span class="line">    properties: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    onLoad () &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    start () &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    update (dt) &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="为组件创建脚本"><a href="#为组件创建脚本" class="headerlink" title="为组件创建脚本"></a>为组件创建脚本</h3><ul>
<li><p>在资源管理器中新建一个<code>JavaScript</code>文件。</p>
</li>
<li><p>点击需要此脚本的节点，在属性检查器中点击添加组件 -&gt; 用户脚本组件后，可以看到整个项目中所有的脚本文件。</p>
</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601605395313.jpg" alt="给组件添加脚本"></p>
<hr>
<h3 id="关联脚本变量与资源"><a href="#关联脚本变量与资源" class="headerlink" title="关联脚本变量与资源"></a>关联脚本变量与资源</h3><ul>
<li><p>每一个脚本中都有一个<code>properties</code>对象，该对象可以理解为一个在当前脚本内的一个变量。</p>
</li>
<li><p>通常脚本中的变量有两种使用方式，其一是作为与资源关联的桥梁，其二是可以用作当前脚本内的变量。</p>
</li>
<li><p>在脚本中需要创建一个变量才能与资源做关联，做关联的方式也是直接将资源拖拽到属性检查器脚本组件下的属性中。</p>
</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601605601374.jpg" alt="给组件添加脚本"></p>
<ul>
<li>当作为资源关联桥梁时，需要指定默认值和类型，类型可以是<code>Cocos</code>游戏引擎所有组件的类型。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">properties: &#123;</span><br><span class="line">  soundPrefab: &#123;</span><br><span class="line">    <span class="keyword">default</span>: <span class="literal">null</span>, <span class="comment">// 设置资源默认值</span></span><br><span class="line">    type: cc.Prefab <span class="comment">// 设置资源类型</span></span><br><span class="line">  &#125;,</span><br><span class="line">  count: <span class="number">0</span> <span class="comment">// 计数器，当作脚本内的运行变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="获取prefab"><a href="#获取prefab" class="headerlink" title="获取prefab"></a>获取<code>prefab</code></h3><ul>
<li><p>当把一个节点从层级管理器拖拽到资源管理器中变成一个<code>prefab</code>时，应该将这个节点从层级管理器中删除。</p>
</li>
<li><p><code>prefab</code>无法自动加载到一个<code>sence</code>中的某一个位置，只能通过脚本获取该<code>prefab</code>并将其挂载到一个<code>sence</code>中的一个<code>node</code>下。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">onLoad () &#123;</span><br><span class="line">  <span class="comment">// 使用给定模板在场景中生成一个新的节点</span></span><br><span class="line">  <span class="keyword">this</span>.sound = cc.instantiate(<span class="keyword">this</span>.soundPrefab)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="将prefab添加到node"><a href="#将prefab添加到node" class="headerlink" title="将prefab添加到node"></a>将<code>prefab</code>添加到<code>node</code></h3><ul>
<li><p>通过脚本加载<code>prefab</code>到<code>node</code>上时，不仅需要获取<code>prefab</code>资源，也需要获取<code>node</code>节点。</p>
</li>
<li><p>获取<code>node</code>节点的方式和获取<code>prefab</code>资源的方式相同，先声明一个变量，将其从层级管理器中拖拽到属性检查器中。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">properties: &#123;</span><br><span class="line">  soundPrefab: &#123;</span><br><span class="line">    <span class="keyword">default</span>: <span class="literal">null</span>,</span><br><span class="line">    type: cc.Prefab</span><br><span class="line">  &#125;,</span><br><span class="line">  backgroundNode: &#123;</span><br><span class="line">    <span class="keyword">default</span>: <span class="literal">null</span>,</span><br><span class="line">    type: cc.Node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onLoad () &#123;</span><br><span class="line">  <span class="keyword">this</span>.sound = cc.instantiate(<span class="keyword">this</span>.soundPrefab)</span><br><span class="line">  <span class="comment">// 将prefab挂载在node下</span></span><br><span class="line">  <span class="keyword">this</span>.backgroundNode.addChild(<span class="keyword">this</span>.sound)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="通过脚本获取sprite"><a href="#通过脚本获取sprite" class="headerlink" title="通过脚本获取sprite"></a>通过脚本获取<code>sprite</code></h3><ul>
<li><p>在开发者动态修改、创建一个或多个<code>sprite</code>时，则需要通过脚本获取<code>node</code>下的<code>sprite</code>。</p>
</li>
<li><p>该<code>node</code>也需要通过创建变量后与资源进行关联。</p>
</li>
<li><p>如果一个<code>node</code>只需要获取并没有其它节点需要挂载在该<code>node</code>下时，可以不写<code>instantiate</code>和<code>addChild</code>。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">properties: &#123;</span><br><span class="line">  backgroundNode: &#123;</span><br><span class="line">    <span class="keyword">default</span>: <span class="literal">null</span>,</span><br><span class="line">    type: cc.Node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">onload () &#123;</span><br><span class="line">  <span class="comment">// 获取挂载在该节点下的所有动画</span></span><br><span class="line">  <span class="comment">// cc.Sprite则为Sprite组件</span></span><br><span class="line">  <span class="comment">// Sprite组件可以在该node下的属性检查器中找到</span></span><br><span class="line">  <span class="comment">// 获取挂载在该节点下的所有精灵</span></span><br><span class="line">  <span class="comment">// getComponent也可以获取到同节点的其它组件，如：Animation，Button等</span></span><br><span class="line">  <span class="keyword">this</span>.sprites = <span class="keyword">this</span>.backgroundNode.getComponent(cc.Sprite)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="点击事件"><a href="#点击事件" class="headerlink" title="点击事件"></a>点击事件</h3><ul>
<li><p>在游戏开发过程中，我们需要捕获某些用户的行为后给用户展示不同的信息，针对这种行为我们称之为交互。</p>
</li>
<li><p>交互方式有很多种，在<code>Cocos Creator</code>引擎中，我们把交互事件划分为三大类，它们分别是：系统内置事件、玩家输入事件以及对事件的发射和监听。</p>
</li>
<li><p>点击事件是交互事件中最常见的事件。</p>
</li>
<li><p>点击事件有两种形式，其一是使用<code>Button</code>组件自带的点击事件，其二则是使用脚本动态绑定一个点击事件。</p>
</li>
</ul>
<hr>
<h4 id="通过按钮绑定点击事件"><a href="#通过按钮绑定点击事件" class="headerlink" title="通过按钮绑定点击事件"></a>通过按钮绑定点击事件</h4><ul>
<li>在层级管理器中创建一个<code>Button</code>组件，点击<code>Button</code>组件后可以在属性检查器中找到<code>Click Events</code>属性。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601638944773.jpg" alt="通过按钮增加点击事件"></p>
<ul>
<li>编辑一个脚本文件，在脚本文件内增加一个<code>onClick</code>方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cc.Class(&#123;</span><br><span class="line">    extends: cc.Component,</span><br><span class="line"></span><br><span class="line">    properties: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// LIFE-CYCLE CALLBACKS:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// onLoad () &#123;&#125;,</span></span><br><span class="line"></span><br><span class="line">    onClick () &#123;&#125;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start () &#123;&#125;,</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// update (dt) &#123;&#125;,</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>在属性检查器中添加带有点击方法的用户脚本组件。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601639906991.jpg" alt="添加带有点击方法的用户脚本"></p>
<ul>
<li>在属性检查器中点击<code>Click Events</code>属性右边的上箭头，代表对此按钮增加一个点击事件。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601639670961.jpg" alt="点击按钮增加一个点击事件"></p>
<ul>
<li>将要绑定的按钮事件、用户脚本拖拽到相应位置后选择脚本中的点击方法。</li>
</ul>
<p><img src="/blog/images/CocosCreator%E7%AE%80%E8%BF%B0/1601640060813.jpg" alt="点击按钮绑定节点和脚本"></p>
<hr>
<h4 id="通过脚本创建一个点击事件"><a href="#通过脚本创建一个点击事件" class="headerlink" title="通过脚本创建一个点击事件"></a>通过脚本创建一个点击事件</h4><ul>
<li>通过脚本绑定的点击事件可以应用在任意一个组件节点。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过脚本动态绑定一个点击事件</span></span><br><span class="line">node.on(<span class="string">'touchstart'</span>, <span class="keyword">this</span>.touchStart, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="场景切换"><a href="#场景切换" class="headerlink" title="场景切换"></a>场景切换</h3><ul>
<li><p>对于一个成品的游戏而言，只有一个<code>scene</code>是远远不够的，我们可以在一个游戏中只设置一个场景，但是我们更推荐开发者将场景中的不同表现进行细化。</p>
</li>
<li><p>对于场景的加载，我们可以做到直接加载、预加载、加载回调等。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 直接加载场景</span></span><br><span class="line">cc.director.loadScene(<span class="string">'MyScene'</span>)</span><br><span class="line"><span class="comment">// 加载场景的回调</span></span><br><span class="line">cc.director.loadScene(<span class="string">'MyScene'</span>, onSceneLaunched)</span><br><span class="line"><span class="comment">// 预加载场景</span></span><br><span class="line">cc.director.preloadScene(<span class="string">'MyScene'</span>, () =&gt; &#123;&#125;)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="播放音频"><a href="#播放音频" class="headerlink" title="播放音频"></a>播放音频</h3><ul>
<li>背景音乐无法在浏览器中自动播放。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 播放背景音乐，第一个参数为AudioClip，第二个参数为是否循环播放</span></span><br><span class="line">cc.audioEngine.playMusic(audio, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// 暂停正在播放的所有音乐</span></span><br><span class="line">cc.audioEngine.pauseMusic(audio)</span><br><span class="line"><span class="comment">// 恢复被暂停的音乐</span></span><br><span class="line">cc.audioEngine.resumeMusic(audio)</span><br><span class="line"><span class="comment">// 播放声音（非背景音乐）</span></span><br><span class="line">cc.audioEngine.play(audio, <span class="literal">false</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cocos</category>
      </categories>
      <tags>
        <tag>cocos</tag>
      </tags>
  </entry>
  <entry>
    <title>EventLoop、MicroTasks and MacroTask</title>
    <url>/blog/2019/04/03/EventLoop%E3%80%81Microtasks%20and%20task/</url>
    <content><![CDATA[<p>本篇文章主要讲解一下<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">JavaScript</code>中的事件循环机制以及深入讲解异步任务中的宏任务和微任务。</p>
<blockquote>
<p>[1] 如果你在阅读中发现错误或者存在某些问题可以通过邮件的形式发送到作者的邮箱，再收到邮件后作者会及时处理这些问题。</p>
<p>[2] 阅读文章你需要了解的专业术语有事件循环机制（EventLoop）、栈（Stack）、队列（Queue）、微任务（MicroTasks）、宏任务（MacroTask）、同步任务（Synchronous）、异步任务（Asynchronous）。</p>
</blockquote>
<hr>
<h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>JavaScript是单进程的脚本语言；</li>
<li>EventLoop是JavaScript中的事件循环机制（执行机制）；</li>
<li>Stack栈是一种先进后出（FILO）的数据结构；</li>
<li>Queue队列是一种先进先出（LILO）的数据结构；</li>
<li>Synchronous是JavaScript中的同步任务；</li>
<li>Asynchronous是JavaScript中的异步任务；</li>
<li>MicroTasks是JavaScript异步中的微任务；</li>
<li>MacroTask是JavaScript异步中的宏任务；</li>
</ul>
<hr>
<h4 id="Stack-and-Queue"><a href="#Stack-and-Queue" class="headerlink" title="Stack and Queue"></a>Stack and Queue</h4><h5 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h5><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Stack</code>和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Queue</code>都是两种基本的数据结构，而常用的数据结构有八种，其余六种数据结构分别是：数组（Array）、散列表（Hash）、树（Tree）、链表（Linked List）、堆（Heap）、图（Graph）。</p>
<h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Stack</code>是一种先进后出（FILO）的数据结构，有且只有一个指向栈顶的指针，对栈的操作只能操作栈顶，不能操作栈底。<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Stack</code>是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">EventLoop</code>在执行的上下文中将所有的函数以入栈和出栈的形式进行编排。所有种类函数在执行前进行入栈，执行后进行出栈，如果遇到异步函数操作，V8和JavaScript引擎会将其交给事件表和事件队列（在该环节不做过多解释，可在下一环节找到详细的解释）。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test_1</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test_0</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> test_1(<span class="number">4</span>) * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test_0(<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>我们可以通过下面的图片去了解入栈和出栈的规则，当理解了栈的规则后，就可以很清晰的看出上面代码的输出结果。</p>
<p><img src="/blog/images/EventLoop%E3%80%81Microtasks%20and%20task/stack.gif" alt="栈的执行流程"></p>
<h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Queue</code>是一种先进先出（LILO）的数据结构，拥有一个指向队首和队尾的指针，队列既能操作队首也能操作队尾。</p>
<hr>
<h4 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h4><p>首先我们要知道<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">JavaScript</code>是单线程的。我们可以把单线程理解为一个自动售票机，购票者需要自觉排队购票，如果其中有一个购票者第一次使用自动售票机的情况下会因为不熟练而使得该购票者购票时间相对较长，无论该购票者用了多少时间，后面的人依旧要进行排队购票。</p>
<p><img src="/blog/images/EventLoop%E3%80%81Microtasks%20and%20task/1554278130031.jpg" alt="排队购票示例图"></p>
<p>回归到浏览器和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">JavaScript</code>本身，如果我们有一个新闻页面，如果需要加载大量的图片并且在图片没有完全加载出来的时候我们不能让浏览器卡着什么都不显示，所以就有人提出了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Synchronous</code>和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Asynchronous</code>。</p>
<hr>
<h4 id="Synchronous-and-Asynchronous"><a href="#Synchronous-and-Asynchronous" class="headerlink" title="Synchronous and Asynchronous"></a>Synchronous and Asynchronous</h4><h5 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul>
<li>Synchronous（同步任务）包含：DOM，CSS，promise；</li>
<li>Asynchronous（异步任务）包含：promise的then，setTimeout，setInterval等；</li>
<li>Asynchronous（异步任务）进入事件表注册回调函数到事件队列，此队列是先进先出队列；</li>
<li>JavaScript首先区分同步任务和异步任务，同步任务直接执行，异步任务进入事件表；</li>
<li>JavaScript优先执行同步任务；</li>
<li>进入到事件表的异步任务会注册回调函数到事件队列；</li>
<li>当JavaScript执行完全部的同步任务后，会判断事件队列中是否有待执行的任务；</li>
</ul>
<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>为了更清晰的解释同步和异步的执行，首先我们来看一段代码，通过代码进行理解：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">  test()</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br><span class="line"><span class="comment">// 输出：start，end，setTimeout，test</span></span><br></pre></td></tr></table></figure>

<p>通过上面的代码会发现这和传统理解<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">JavaScript</code>是从上到下执行是相悖的，为此可以查看下面的流程图进行详细的流程分析。</p>
<p><img src="/blog/images/EventLoop%E3%80%81Microtasks%20and%20task/1554282142999.jpg" alt="同步异步执行示例图"></p>
<hr>
<h4 id="MicroTasks-and-Macrotask"><a href="#MicroTasks-and-Macrotask" class="headerlink" title="MicroTasks and Macrotask"></a>MicroTasks and Macrotask</h4><h5 id="基本介绍-2"><a href="#基本介绍-2" class="headerlink" title="基本介绍"></a>基本介绍</h5><ul>
<li>MicroTasks（微任务）包括promise的then；</li>
<li>Macrotask（宏任务）包括script、setTimeout、setInterval；</li>
<li>MicroTasks（微任务）和Macrotask（宏任务）进入的是两个不同的事件队列；</li>
<li>当Synchronous（同步任务）执行完毕后会去判断事件队列中是否有待执行的函数，如果有待执行的函数后要判断事件队列中是否有MicroTasks Queue（微任务队列）和Macrotask Queue（宏任务队列），如果存在则先执行MicroTasks Queue（微任务队列）中的函数；</li>
</ul>
<p>由于这是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">EventLoop</code>中最细致的地方，所以下面会列举出比较常用的例子。</p>
<h5 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h5><p>Synchronous（同步任务）完成后立即执行的setTimeout：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 输出：setTimeout</span></span><br></pre></td></tr></table></figure>

<p>Synchronous（同步任务）完成后延迟立即执行的setTimeout：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">5000</span>);</span><br><span class="line"><span class="comment">// 等待5s后输出：setTimeout</span></span><br></pre></td></tr></table></figure>

<p><span style="color: red;">注：即使我们给setTimeout延迟5s执行，实际的环境中绝大多数是大于这个时间的，例如一个延迟一秒的setTimeout中有个ajax方法，setTimeout会等待ajax请求完毕后再去执行，这段期间即使超过一秒了，但是里面的ajax受网络环境影响并没有及时返回，这时setTimeout的延迟时间。</span></p>
<h5 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h5><p>此函数与<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">setTimeout</code>相似，<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">setInterval</code>是每隔一段时间讲函数注入到事件表中，在判断是什么类型任务进入不同的事件队列。</p>
<h5 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h5><p>promise的功能在此不再赘述，如果想详细了解可以阅读<a href="http://es6.ruanyifeng.com/#docs/promise" target="_blank" rel="noopener" style="color: blue">阮一峰ECMAScript 6 入门中的Promise 对象章节</a>。</p>
<h5 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h5><p>宏任务和微任务进入不同队列且微任务优先执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)    </span><br><span class="line">&#125;)</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 输出：promise1，promise2，setTimeout1，setTimeout2</span></span><br></pre></td></tr></table></figure>

<p>上面的代码的执行流程为：</p>
<ol>
<li>promise1为同步任务直接打印；</li>
<li>promise2进入微任务队列；</li>
<li>setTimeout1进入宏任务队列；</li>
<li>setTimeout2进入宏任务队列；</li>
<li>promise2打印（优先执行微任务）；</li>
<li>setTimeout1打印；</li>
<li>setTimeout2打印；</li>
</ol>
<p>嵌套任务：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise1'</span>)  </span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout2'</span>)</span><br><span class="line">  &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout1'</span>)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Promise2'</span>)    </span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 输出：Promise1，setTimeout1，Promise2，setTimeout2</span></span><br></pre></td></tr></table></figure>

<p>上面的代码的执行流程为：</p>
<ol>
<li>promise1进入微任务队列；</li>
<li>setTimeout1进入宏任务队列；</li>
<li>打印promise1，setTimeout2进入宏任务队列；</li>
<li>打印setTimeout1，promise2进入微任务队列；</li>
<li>打印promise2；</li>
<li>打印setTimeout2；</li>
</ol>
<hr>
<h4 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h4><p>首先我们来看一段终极代码，了解完整的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">EventLoop</code>执行流程：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">	<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">		resolve();</span><br><span class="line">	&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'4'</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'5'</span>);</span><br><span class="line">	resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'6'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'7'</span>)</span><br><span class="line">	setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'8'</span>);</span><br><span class="line">		<span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">			resolve();</span><br><span class="line">		&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="built_in">console</span>.log(<span class="string">'10'</span>)</span><br><span class="line">		&#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'11'</span>)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'12'</span>);</span><br><span class="line">test();</span><br><span class="line"><span class="comment">// 输出：1，5，12，7，6，2，3，4，8，9，11，10</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">JavaScript</code>开始执行时候会将所有函数押入执行栈，其中同步任务按序执行，异步任务加入事件表，事件表把函数分为宏任务和微任务将其回调函数分别压入不同的事件队列。当同步任务执行完毕后，引擎会检查是否存在异步任务，如果不存在则程序结束。如果存在判断是否有微任务，没有的情况下直接执行宏任务队列，有微任务的情况下，优先执行微任务队列里面的函数。</p>
<p><img src="/blog/images/EventLoop%E3%80%81Microtasks%20and%20task/1554364051301.jpg" alt="终极图片"></p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>EventLoop</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
        <tag>Synchronous</tag>
        <tag>Asynchronous</tag>
        <tag>MicroTasks</tag>
        <tag>MacroTask</tag>
      </tags>
  </entry>
  <entry>
    <title>Git代理</title>
    <url>/blog/2018/12/09/Git%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p>很多时候我们进行git clone的速度会很慢，为此我们可以通过代理的方式提高git的速度。</p>
<h5 id="设置http代理"><a href="#设置http代理" class="headerlink" title="设置http代理"></a>设置http代理</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br></pre></td></tr></table></figure>

<h5 id="设置socks5代理"><a href="#设置socks5代理" class="headerlink" title="设置socks5代理"></a>设置socks5代理</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy 'socks5://127.0.0.1:1080' </span><br><span class="line">git config --global https.proxy 'socks5://127.0.0.1:1080'</span><br></pre></td></tr></table></figure>

<h5 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --unset http.proxy</span><br><span class="line">git config --global --unset https.proxy</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git分支的内部运行机制</title>
    <url>/blog/2018/06/07/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>首先我们在深入了解git分支工作原理之前，要了解一下git时间线的概念。</p>
<p>在我们每次提交代码的时候，git都把他们串成一条时间线，这个时间线就是一个分支。在一个项目中如果只有一个时间线，我们把它叫做主分支（master）。而head严格来说不是指向提交，而是指向一个分支，再有这个分支指向提交，所以我们可以理解成head之乡的就是当前的分支。</p>
<p>在只有一个时间线的时候（即只有一个主分支master），git会用head指向分支，再由分支指向最新的提交点。</p>
<p><img src="/blog/images/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/7de4ebc75849494691021c2c86551952.png" alt="7de4ebc75849494691021c2c86551952"></p>
<p>当每次提交的时候git会将head指向的分支向前移动，这样，随着项目不断地更新，时间线也会越来越长。</p>
<p><img src="/blog/images/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/8fb2340888c996459c099483ae905e5e.png" alt="8fb2340888c996459c099483ae905e5e"></p>
<p>当我们去创建一个新分支dev并且使用时，由于项目没有做出任何改变，所以dev分支指向的时间点和master指向的时间点是相同的。</p>
<p><img src="/blog/images/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/173f807d11d39c42a755e1b3320e00dc.png" alt="173f807d11d39c42a755e1b3320e00dc"></p>
<p>在dev分支向仓库提交代码时，向前移动的时间点也是dev分支的时间点，并不是master主分支的时间点。</p>
<p><img src="/blog/images/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/4484d8b1590eb54d933c3faded84b765.png" alt="4484d8b1590eb54d933c3faded84b765"></p>
<p>当我们要进行master和dev分支项目合并时候，我们要切换到master分支，将master分支指向dev分支的时间点上。</p>
<p><img src="/blog/images/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/d63a3cfcc99caf41a5a12490369c943c.png" alt="d63a3cfcc99caf41a5a12490369c943c"></p>
<p>在成功将代码合并后master分支指向的时间点和dev分支指向的时间点是相同的。当我们在pull master的时候我们pull到的项目中就是带有dev分支更改的内容。</p>
<p><img src="/blog/images/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/7bd5fd68f0e28e418edef46fc5f2e5b0.png" alt="7bd5fd68f0e28e418edef46fc5f2e5b0"></p>
<p>在分支合并完成后我们可以选择将dev分支进行删除，删除dev分支就是把dev指针删除。当然，删除dev分支后我们的仓库中也就只有master一个分支了。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令行提交代码</title>
    <url>/blog/2018/05/24/Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<p>上篇文章<a href="http://www.songjian.site:4000/2018/05/10/Git%E9%85%8D%E7%BD%AEssh%E5%85%AC%E9%92%A5/" target="_blank" rel="noopener">Git配置ssh公钥</a>后，我们详细讲解一下如何将自己的代码推送到git服务器。</p>
<h5 id="首先我们要带开GitHub网页，新建一个项目"><a href="#首先我们要带开GitHub网页，新建一个项目" class="headerlink" title="首先我们要带开GitHub网页，新建一个项目"></a>首先我们要带开GitHub网页，新建一个项目</h5><p><img src="/blog/images/Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/c03b4962514cfc4580928f9b05b4b719.png" alt="c03b4962514cfc4580928f9b05b4b719"></p>
<h5 id="为项目起一个名字，然后点击创建项目"><a href="#为项目起一个名字，然后点击创建项目" class="headerlink" title="为项目起一个名字，然后点击创建项目"></a>为项目起一个名字，然后点击创建项目</h5><p><img src="/blog/images/Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/732545bcd42d434dbd3528f08a2b9b1b.png" alt="732545bcd42d434dbd3528f08a2b9b1b"></p>
<h5 id="在新跳转的页面中，我们可以看到一些git-bash的命令，这些命令就是告诉我们在新建的项目中第一次推送代码需要做的事情"><a href="#在新跳转的页面中，我们可以看到一些git-bash的命令，这些命令就是告诉我们在新建的项目中第一次推送代码需要做的事情" class="headerlink" title="在新跳转的页面中，我们可以看到一些git bash的命令，这些命令就是告诉我们在新建的项目中第一次推送代码需要做的事情"></a>在新跳转的页面中，我们可以看到一些git bash的命令，这些命令就是告诉我们在新建的项目中第一次推送代码需要做的事情</h5><p><img src="/blog/images/Git%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81/d560cd64cb98ca4e8640e04f0d428d1d.png" alt="d560cd64cb98ca4e8640e04f0d428d1d"></p>
<h5 id="命令含义"><a href="#命令含义" class="headerlink" title="命令含义"></a>命令含义</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo "# ceshi" &gt;&gt; README.md </span><br><span class="line"><span class="meta">#</span><span class="bash"> 为项目创建一个说明的文档，内容是ceshi，文档格式为markdown，后续可以在此文档中增加对项目的内容介绍</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 对本地的git仓库进行初始化，此时会在执行命令的目录多出一个.git的隐藏文件</span></span><br><span class="line">git add README.md</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将此文件加入到索引库中，此处可以用*代替，表示添加所有文件到索引库</span></span><br><span class="line">git commit -m "first commit"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 为这次提交的文件写一个说明</span></span><br><span class="line">git remote add origin git@github.com:xxxxxxxx/ceshi.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加到git远程仓库</span></span><br><span class="line">git push -u origin master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将本地项目推送到git远程仓库的主分支上</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令以及创建新分支并在新分支进行开发</title>
    <url>/blog/2018/06/07/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%BB%A5%E5%8F%8A%E5%88%9B%E5%BB%BA%E6%96%B0%E5%88%86%E6%94%AF%E5%B9%B6%E5%9C%A8%E6%96%B0%E5%88%86%E6%94%AF%E8%BF%9B%E8%A1%8C%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>这些天因为自己新项目的原因要进行分支的操作，为此想到了博客中还有关于git方面的文章。为此，我在这里详细的介绍下关于git分支的操作。</p>
<p>关于git分支在实际开发中的应用还是很广泛的。普遍来讲，各个公司都不会允许所有码农将代码直接提交到主分支（master）上，主分支只作为为所有码农下载项目（pull）使用。</p>
<p>那么，我们无法将自己写的代码直接提交到master上，应该怎么办。最通常的方式就是将项目从master上pull下来，然后创建一个自己名字命名的分支，然后我们把修改的项目提交到自己的分支上，再有项目经理或者以上级别的人进行分支合并，将所有人的分支合并到master上。这样其他人在pull master的时候就能更新到除了自己以外所有人的代码。</p>
<p>由于前几两篇关于git的文章我并没有对git常用命令进行讲解，所以在操作分支的时候各位也应该是对master push pull有所了解了。</p>
<h5 id="git常用命令"><a href="#git常用命令" class="headerlink" title="git常用命令"></a>git常用命令</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git rm 文件名 <span class="comment"># 删除本地git仓库文件，提交后远程服务器上的文件会被删除</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status <span class="comment"># 查看状态</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add 文件名 <span class="comment"># 添加记录</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add * <span class="comment"># 添加所有文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">"描述此次提交的内容"</span> <span class="comment"># 添加描述</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull origin master <span class="comment"># 从主分支同步数据</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master <span class="comment"># 提交数据到主分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch <span class="comment"># 查看分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch 分支名 <span class="comment"># 创建分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout 分支名 <span class="comment"># 切换分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b 分支名 <span class="comment"># 创建+切换分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d 分支名 <span class="comment"># 删除分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D 分支名 <span class="comment"># 强制删除分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :分支名 <span class="comment"># 删除远程分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout --file <span class="comment"># 撤销修改</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge 分支名 <span class="comment"># 合并某分支到当前分支</span></span></span><br></pre></td></tr></table></figure>

<p>那么，介绍完了常用命令之后，我们应该如何新建分支进行工作</p>
<h5 id="选择master-pull或者新项目直接git-clone默认master"><a href="#选择master-pull或者新项目直接git-clone默认master" class="headerlink" title="选择master pull或者新项目直接git clone默认master"></a>选择master pull或者新项目直接git clone默认master</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout master</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br></pre></td></tr></table></figure>

<h5 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev</span></span><br></pre></td></tr></table></figure>

<h5 id="将新建的分支push到远端"><a href="#将新建的分支push到远端" class="headerlink" title="将新建的分支push到远端"></a>将新建的分支push到远端</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin dev</span></span><br></pre></td></tr></table></figure>

<h5 id="拉取远端分支"><a href="#拉取远端分支" class="headerlink" title="拉取远端分支"></a>拉取远端分支</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line"></span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">git branch --set-upstream-to=origin/&lt;branch&gt; dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当前分支并没有和本地分支关联</span></span><br></pre></td></tr></table></figure>

<h5 id="关联分支"><a href="#关联分支" class="headerlink" title="关联分支"></a>关联分支</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch--<span class="built_in">set</span>-upstream-to=origin/dev</span></span><br></pre></td></tr></table></figure>

<h5 id="再次拉取"><a href="#再次拉取" class="headerlink" title="再次拉取"></a>再次拉取</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br></pre></td></tr></table></figure>

<p>有关git分支内部工作原理的信息，请查看<a href="http://www.songjian.site:4000/2018/06/07/Git%E5%88%86%E6%94%AF%E7%9A%84%E5%86%85%E9%83%A8%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">Git分支的内部运行机制</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git checkout</tag>
        <tag>git branch</tag>
      </tags>
  </entry>
  <entry>
    <title>Git配置ssh公钥</title>
    <url>/blog/2018/05/10/Git%E9%85%8D%E7%BD%AEssh%E5%85%AC%E9%92%A5/</url>
    <content><![CDATA[<p>最近有人希望我对git做一些介绍，为此我特意开出一个大的分类专门记录一些git方向的基本操作和错误总结。而基本的如何去注册、登录git这样的操作也没有什么必要去讲，所以第一篇关于git方向的文章我打算讲一下如何去通过git bash去配置git的ssh公钥。</p>
<h5 id="打开git-bash终端"><a href="#打开git-bash终端" class="headerlink" title="打开git bash终端"></a>打开git bash终端</h5><p><img src="/blog/images/Git%E9%85%8D%E7%BD%AEssh%E5%85%AC%E9%92%A5/TIM%E5%9B%BE%E7%89%8720180514093902.png" alt="TIM图片20180514093902"></p>
<p><img src="/blog/images/Git%E9%85%8D%E7%BD%AEssh%E5%85%AC%E9%92%A5/TIM%E5%9B%BE%E7%89%8720180514093957.png" alt="TIM图片20180514093957"></p>
<h5 id="进行命令输入"><a href="#进行命令输入" class="headerlink" title="进行命令输入"></a>进行命令输入</h5><p>进入文件加查看</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh/</span><br></pre></td></tr></table></figure>

<p>如果提示 “No such file or directory”使用下面命令创建</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir ~/.ssh</span><br></pre></td></tr></table></figure>

<p>配置全局的name和email，这里事GitHub账号和邮箱</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name "you Account" </span><br><span class="line">git config --global user.email "you email"</span><br></pre></td></tr></table></figure>

<p>生成ssh公钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "you email"</span><br></pre></td></tr></table></figure>

<p>查看生成的公钥文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">ll</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/Git%E9%85%8D%E7%BD%AEssh%E5%85%AC%E9%92%A5/8ad702a410ed244db09c45c4d6ffd372.png" alt="8ad702a410ed244db09c45c4d6ffd372"></p>
<p>登录自己的GitHub，点击自己头像下面的setting</p>
<p><img src="/blog/images/Git%E9%85%8D%E7%BD%AEssh%E5%85%AC%E9%92%A5/9b89261ef18cb14fa0545d543cbbc4cd.png" alt="9b89261ef18cb14fa0545d543cbbc4cd"></p>
<p>点击左侧的SSH and GPG keys，然后再点击右上方的new SSH Key </p>
<p><img src="/blog/images/Git%E9%85%8D%E7%BD%AEssh%E5%85%AC%E9%92%A5/d9a6dc081fb9004cbd3004b472fa3c69.png" alt="d9a6dc081fb9004cbd3004b472fa3c69"></p>
<p>拷贝id_rsa.pub文件中的所有内容到下图的key区域，然后在title起一个名字，最后点击Add SSH Key </p>
<p><img src="/blog/images/Git%E9%85%8D%E7%BD%AEssh%E5%85%AC%E9%92%A5/89e88906086d9d40b79361192b53805d.png" alt="89e88906086d9d40b79361192b53805d"></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>JS数组遍历方法</title>
    <url>/blog/2018/12/20/JS%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>所谓的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">JS高阶函数</code>就是《JavaScript高级程序设计》中提到的六种迭代方法，这六种方法有着很广泛的应用，尤其是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">forEach</code>和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">map</code>。其实学会这六种方法之后我们在一些时候就可以完全的抛弃<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">for</code>循环，当然有些时候<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">for</code>循环还是必不可少的东西。但是对于初学者来说这些迭代方法都很像，很难看出来什么区别，不免会觉得头大。</p>
<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>简单理解：让数组通过某种计算产生一个新数组</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item * <span class="number">2</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 返回数组中每一项乘以2后的值</span></span><br></pre></td></tr></table></figure>

<h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><p>简单理解：让数组中的每一项做一件事</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 打印数组中每一项的值</span></span><br></pre></td></tr></table></figure>

<h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>简单理解：筛选出数组中符合条件的项组成新数组</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 返回数组中大于3的项</span></span><br></pre></td></tr></table></figure>

<h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p>简单理解：让数组中的前项和后项做某种计算，并累计最终的值</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> prev + next</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 计算出数组中所有项的和</span></span><br></pre></td></tr></table></figure>

<h5 id="every"><a href="#every" class="headerlink" title="every"></a>every</h5><p>简单理解：检测数组中的每一项是否符合条件</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.every(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 每一项都满足条件才会返回true</span></span><br></pre></td></tr></table></figure>

<h5 id="some"><a href="#some" class="headerlink" title="some"></a>some</h5><p>简单理解：检测数组中是否有某些项符合条件</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">arr.some(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item &gt; <span class="number">0</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 只要数组中有一项符合条件就会返回true</span></span><br></pre></td></tr></table></figure>

<h5 id="set（补充介绍）"><a href="#set（补充介绍）" class="headerlink" title="set（补充介绍）"></a>set（补充介绍）</h5><p>简单理解：用于去重操作，以及构造数据结构</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br><span class="line"><span class="comment">// 对数组中的重复项去重</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>WARNING REMOTE HOST IDENTIFICATION HAS CHANGED</title>
    <url>/blog/2018/08/09/Linux%20SSH%20%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>最近在终端远程一个Linux服务器的时候提示了“WARNING REMOTE HOST IDENTIFICATION HAS CHANGED”错误。</p>
<p>首先，出现这个错误的情况一般是192.168.1.9绑定a机器，但是因为a机器销毁了，ip被b机器占用后，导致本地系统的公钥还是a机器的公钥，所以在连接b机器的时候就会提示这个错误。</p>
<h5 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h5><p>在系统的~路径下，进去.ssh文件夹删除known_hosts这个文件，之后重新连接远程即可</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ~</span><br><span class="line">rm -rf .ssh/known_hosts</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux vim按下ctrl+s导致假死</title>
    <url>/blog/2018/05/17/Linux%20vim%E6%8C%89%E4%B8%8Bctrl+s%E5%AF%BC%E8%87%B4%E5%81%87%E6%AD%BB/</url>
    <content><![CDATA[<p>最近看到同事操作vim编辑器再保存退出的时候经常会按<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;"> ctrl + s </code>然后导致界面卡死，最终选择重新远程连接，这时候Linux会判断你这次vim操作并没有进行保存而强制退出，这时Linux会生成一个缓存文件，导致下次在编辑这个文件的时候进入选择模式，当然我们可以把缓存文件删除，也可以解决这个问题，不过导致这个问题发生归根到底都是不熟悉vim操作造成的。</p>
<p>在vim中如果按下了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;"> ctrl + s </code>会终止屏幕输出（即停止回显） ，在这期间你按的所有按键都是有效的，被记录到文件中的，只不过是你自己看不见而已。</p>
<p>我们可以通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;"> ctrl + q </code>恢复屏幕输出，你刚才敲的都显示出来了 。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>MockJS在vue项目中的基本使用规则（包含增删改查）</title>
    <url>/blog/2019/02/11/MockJS%E5%9C%A8vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>​    在前端开发的过程中我们经常会遇到后端人员因为某些因素导致接口不能使用（例如：后端功能并为编写完成，后端接口出现bug等）。传统的方式是前端开发者去等待后端开发者去解决这些问题后再进行开发。但是这样不仅会大大增加前后端的依赖性，还会加大了开发成本。</p>
<p>​    这时，前端开发者回去思考，有没有什么东西能够去模拟后端的接口返回数据，并且在后端接口尚未编写完成时，使得前后端的依赖耦合降到最低。并且如果在后端接口报错的情况下，前端可以通过搭配axios访问一些看似真实的mock数据，将其展现在页面中。</p>
<h4 id="mock基本语法"><a href="#mock基本语法" class="headerlink" title="mock基本语法"></a>mock基本语法</h4><h5 id="mock语法两层规范"><a href="#mock语法两层规范" class="headerlink" title="mock语法两层规范"></a>mock语法两层规范</h5><ul>
<li>数据模板（DTD）</li>
<li>数据占位符（DPD）</li>
</ul>
<h5 id="DTD规则"><a href="#DTD规则" class="headerlink" title="DTD规则"></a>DTD规则</h5><p>一个完整的DTD模板格式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'name|rule'</span>: value</span><br></pre></td></tr></table></figure>

<ul>
<li>name：属性名</li>
<li>rule：属性规则</li>
<li>value：属性值（属性值类型决定生成数据的类型）</li>
</ul>
<p>七种属性规则</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'name|mix-max'</span>: value</span><br><span class="line"><span class="string">'name|count'</span>: value</span><br><span class="line"><span class="string">'name|mix-max.dmix-dmax'</span>: value</span><br><span class="line"><span class="string">'name|min-max.dcount'</span>: value</span><br><span class="line"><span class="string">'name|count.dmin-dmax'</span>: value</span><br><span class="line"><span class="string">'name|count.dcount'</span>: value</span><br><span class="line"><span class="string">'name|+step'</span>: value</span><br></pre></td></tr></table></figure>

<p>属性值类型为String</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'name|1-3'</span>: <span class="string">'a'</span>, <span class="comment">// 随机生成a, aa, aaa中的一个</span></span><br><span class="line">    <span class="string">'name1|2'</span>: <span class="string">'b'</span> <span class="comment">// 生成bb</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>属性值类型为Number</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'name|+1'</span>: <span class="number">4</span>, <span class="comment">// 初始值为4，每次循环自增1</span></span><br><span class="line">    <span class="string">'name1|7-30'</span>: <span class="number">0</span>, <span class="comment">// 生成一个7-30之间的数，其中0只是为了确定Number类型</span></span><br><span class="line">    <span class="string">'name2|2-456.1-10'</span>: <span class="number">0</span> <span class="comment">// 生成一个整数在2-456之间的数，小数部分为1-10位，其中0只是为了确定Number类型</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>属性值类型为Boolean</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'name|1'</span>： <span class="string">'true'</span>， <span class="comment">// 生成true和false的概率各为1/2，其中true只是为了确定Boolean类型</span></span><br><span class="line">    <span class="string">'name1|2-5'</span>： <span class="string">'true'</span> <span class="comment">// 生成true的概率为2/(2+5)，生成false的概率为5/(2+5)，其中true只是为了确定Boolean类型</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>属性值类型为Object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span>, <span class="attr">d</span>: <span class="number">4</span>, <span class="attr">e</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">let</span> data = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'name|2-4'</span>: obj, <span class="comment">// 从obj中随机选择2-4个属性</span></span><br><span class="line">    <span class="string">'name1|2'</span>: obj <span class="comment">// 从obj中随机选择2个属性</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>属性值类型为Array</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">let</span> data = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'name|1'</span>: arr, <span class="comment">// 从arr中随机选择一个值</span></span><br><span class="line">    <span class="string">'name1|+1'</span>: arr, <span class="comment">// 从arr中顺序选择一个值，第一次循环值为arr[0]的值，第二次为arr[1]的值</span></span><br><span class="line">    <span class="string">'name2|1-3'</span>: arr <span class="comment">// 基于arr重复生成1-3次，组合成新数组</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>属性值类型为Function</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> func = <span class="function">(<span class="params">x</span>) =&gt;</span> &#123;<span class="keyword">return</span> x + <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">let</span> data = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'name'</span>: func(<span class="number">77</span>) <span class="comment">// 得到func的返回值</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>属性值类型为RegExp</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="regexp">/[a-z][A-Z]/</span>,</span><br><span class="line">    <span class="string">'name1'</span>: <span class="regexp">/\d&#123;1,3&#125;/</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="DPD规则"><a href="#DPD规则" class="headerlink" title="DPD规则"></a>DPD规则</h5><p>​    DPD通过使用@标识符去生成一些固定类别的字符串类型的数据，例如生成姓名，句子或者一句话等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> data = Mock.mock(&#123;</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'@province'</span>, <span class="comment">// 省</span></span><br><span class="line">    <span class="string">'name1'</span>: <span class="string">'@city'</span>, <span class="comment">// 市</span></span><br><span class="line">    <span class="string">'name2'</span>: <span class="string">'@county'</span>, <span class="comment">// 县</span></span><br><span class="line">    <span class="string">'name3'</span>: <span class="string">'@url'</span>, <span class="comment">// url</span></span><br><span class="line">    <span class="string">'name4'</span>: <span class="string">'@cname'</span> <span class="comment">// 姓名</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<span style="color:red">
    *文章中列举的只是一小部分，完整使用方式请查阅
</span>[官方文档](http://mockjs.com/)。



<h4 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h4><p>1.通过npm安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install mockjs</span><br></pre></td></tr></table></figure>

<p>2.通过yarn安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yarn add mockjs</span><br></pre></td></tr></table></figure>

<p>3.通过bower安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">bower install mockjs</span><br></pre></td></tr></table></figure>

<p>4.通过cdn方式引入</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://mockjs.com/dist/mock.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    </p>
<h4 id="在vue项目中的使用"><a href="#在vue项目中的使用" class="headerlink" title="在vue项目中的使用"></a>在vue项目中的使用</h4><h5 id="创建及引入"><a href="#创建及引入" class="headerlink" title="创建及引入"></a>创建及引入</h5><p>​    在vue项目的src目录下面创建一个mock的文件夹，并在文件夹中创建一个mock.js的文件，并且在main.js中进行引入。</p>
<p><img src="/blog/images/MockJS%E5%9C%A8vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99/1549892138375.jpg" alt="1549892138375"></p>
<h5 id="编写基本的mock数据"><a href="#编写基本的mock数据" class="headerlink" title="编写基本的mock数据"></a>编写基本的mock数据</h5><p>​    首先我们要实现在vue项目下使用mock数据进行增删改查，就要先去使用规则生成一些数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Mock <span class="keyword">from</span> <span class="string">'mockjs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> testData = Mock.mock(&#123;</span><br><span class="line">	<span class="string">"user|1-4"</span>: [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">'name'</span>: <span class="string">'@cname'</span>,</span><br><span class="line">			<span class="string">'age|18-60'</span>: <span class="number">0</span>,</span><br><span class="line">			<span class="string">'_id|+1'</span>: <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>​    对外暴露接口，使得能够通过axios来对接口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> getData = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> testData</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Mock.mock(<span class="string">'/api/getData'</span>, <span class="string">'get'</span>, getData)</span><br></pre></td></tr></table></figure>



<h5 id="通过GET请求mock数据"><a href="#通过GET请求mock数据" class="headerlink" title="通过GET请求mock数据"></a>通过GET请求mock数据</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">		name: &#39;testMock&#39;,</span><br><span class="line">		mounted() &#123;</span><br><span class="line">			this.getTestData()</span><br><span class="line">		&#125;,</span><br><span class="line">		methods: &#123;</span><br><span class="line">			getTestData () &#123;</span><br><span class="line">				this.axios.get(&#39;&#x2F;api&#x2F;getData&#39;)</span><br><span class="line">						.then(res &#x3D;&gt; &#123;</span><br><span class="line">							console.log(res)</span><br><span class="line">						&#125;)</span><br><span class="line">						.catch(err &#x3D;&gt; &#123;</span><br><span class="line">							console.log(err)</span><br><span class="line">						&#125;)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>



<h5 id="请求成功示例"><a href="#请求成功示例" class="headerlink" title="请求成功示例"></a>请求成功示例</h5><p><img src="/blog/images/MockJS%E5%9C%A8vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99/1550151804716.jpg" alt="1550151804716"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    文中对增删改查只列举了一个查询信息的例子，实际删除，修改，添加和我们实际与后台人员对接接口的逻辑是一样的，在这里就不在介绍了。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>axios</tag>
        <tag>MockJS</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL too many connections 解决方法</title>
    <url>/blog/2018/06/25/MySQL%20too%20many%20connections%20%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>今天在项目中遇到了一个MySQL too many connections的错误，导致项目无法启动，数据库连接工具无法链接。查看了错误之后发现当初在安装完MySQL的时候，忘了更改这些链接配置，下面介绍下怎么去处理这些问题，当然这些设置也可以在成功安装MySQL后就进行配置。</p>
<h5 id="通过输入MySQL的root账号密码进入到MySQL管理"><a href="#通过输入MySQL的root账号密码进入到MySQL管理" class="headerlink" title="通过输入MySQL的root账号密码进入到MySQL管理"></a>通过输入MySQL的root账号密码进入到MySQL管理</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>

<h5 id="查看当前连接数"><a href="#查看当前连接数" class="headerlink" title="查看当前连接数"></a>查看当前连接数</h5><p>可以看到于sleep状态，这些其实是暂时没有用的，所以可以kill id号的方式进行关闭</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show processlist;</span><br></pre></td></tr></table></figure>

<h5 id="查看最大连接数"><a href="#查看最大连接数" class="headerlink" title="查看最大连接数"></a>查看最大连接数</h5><p>查看当前MySQL配置的最大连接数，当所有连接数综合等于最大连接数时，MySQL就会报出too many connections的错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show variables like "max_connections";</span><br></pre></td></tr></table></figure>

<h5 id="修改最大连接数"><a href="#修改最大连接数" class="headerlink" title="修改最大连接数"></a>修改最大连接数</h5><p>我们可以通过调大MySQL最大连接数的方式进行解决，但是出现too many connections的错误时我们不建议去增大最大的连接数，因为连接数的增加会造成更大的MySQL负担，对数据库的冲击也是比较大的，我们应该根据实际开发需求，设置一个比较合理的最大连接数，同时对sleep状态的连接进行kill</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set GLOBAL max_connections=1000;</span><br></pre></td></tr></table></figure>

<h5 id="查看当前MySQL关闭非交互连接的时间"><a href="#查看当前MySQL关闭非交互连接的时间" class="headerlink" title="查看当前MySQL关闭非交互连接的时间"></a>查看当前MySQL关闭非交互连接的时间</h5><p>这个数值指的是MySQL在关闭一个非交互的连接之前要等待的秒数，默认是28800s </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">show global variables like 'wait_timeout';</span><br></pre></td></tr></table></figure>

<h5 id="修改当前非交互连接关闭的时间"><a href="#修改当前非交互连接关闭的时间" class="headerlink" title="修改当前非交互连接关闭的时间"></a>修改当前非交互连接关闭的时间</h5><p>修改这个数值就能更改MySQL关闭一个非交互的连接要等待的秒数，最好控制在几分钟之内</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set global wait_timeout=300;</span><br></pre></td></tr></table></figure>

<h5 id="修改关闭非交互和交互连接的关闭时间"><a href="#修改关闭非交互和交互连接的关闭时间" class="headerlink" title="修改关闭非交互和交互连接的关闭时间"></a><h5 style="color: red;">修改关闭非交互和交互连接的关闭时间</h5></h5><p>当我们修改这个时间的时候一定要进行估量，因为这个连接的时间一到，无论是交互的连接或者非交互的连接都会被关闭</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set global interactive_timeout=500;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>buff/cache内存占用过高</title>
    <url>/blog/2018/02/06/buffcache%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/</url>
    <content><![CDATA[<p>本篇介绍一下CentOS7中buff/cache内存占用过高，导致其他功能或服务无法正常运行大的状况</p>
<p>一、什么是buff/cache</p>
<p>​    <table class="table table-striped table-bordered table-hover"><tbody><tr><td>buff</td><td>cache</td></tr><tr><td>Buffer：缓冲区，用于存储速度不同步的设备或优先级不同的设备之间传输数据；通过buffer可以减少进程间通信需要等待的时间，当存储速度快的设备与存储速度慢的设备进行通信时，存储慢的数据先把数据存放到buffer，达到一定程度存储快的设备再读取buffer的数据，在此期间存储快的设备CPU可搜索以干其他的事情。</td><td>Cache：缓存区，是高速缓存，是位于CPU和主内存之间的容量较小但速度很快的存储器，因为CPU的速度远远高于主内存的速度，CPU从内存中读取数据需等待很长的时间，而 Cache保存着CPU刚用过的数据或循环使用的部分数据，这时从Cache中读取数据会更快，减少了CPU等待的时间，提高了系统的性能。</td> </tr><tr><td>Buffer：一般是用在写入磁盘的，例如：某个进程要求多个字段被读入，当所有要求的字段被读入之前已经读入的字段会先放到buffer中。</td><td>Cache并不是缓存文件的，而是缓存块的(块是I/O读写最小的单元)；Cache一般会用在I/O请求上，如果多个进程要访问某个文件，可以把此文件读入Cache中，这样下一个进程获取CPU控制权并访问此文件直接从Cache读取，提高系统性能。</td></tr></tbody></table></p>
<p>二、手动处理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 3 &gt; /proc/sys/vm/drop_caches</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/buffcache%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98/hh.png" alt="处理前和处理后的对比"></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>buff/cache</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7+docker容器内部署hexo</title>
    <url>/blog/2018/01/19/centos7+docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E7%BD%B2hexo/</url>
    <content><![CDATA[<p>本篇文章记录详细讲解基于Centos7系统下容器化部署hexo静态博客系统，随着近年来容器化部署广泛普及，使得越来越多的人在做一个项目的时候会考虑到容器化部署的方案。而个人构建博客系统我本人也是比较看好docker+hexo的部署方式的。从整个博客系统的渲染速度和维护管理来讲，hexo有着超越wordpress的优越条件，本人也是用过wordpress，近年来wordpress的发展显得过于臃肿。</p>
<ol>
<li><p>在Centos7中安装docker运行环境（此处安装的为docker-ee版本，docker-ce版本也可以）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install docker -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置docker自动启动和启动docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>docker下载hexo镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull ipple1986/hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看docker 镜像是否下载成功（使用docker images看到如下图所示，表示镜像下载成功）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY                  TAG             IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/ipple1986/hexo    latest          8eb73a3f4772        7 months ago        426.7 MB</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动这个镜像（docker默认下载下来的是一个镜像，当这个镜像启动的时候就会创建一个基于这个镜像的容器，这里使用的是容器内部署hexo，如果需要把项目挂载到本机的目录操作，请查看我博客左上角docker分类中的另一篇部署文章）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># --name: 容器名   -p: 端口映射   -d: 以守护进程方式运行（后台）</span></span></span><br><span class="line">docker run -d --name some-hexo -p 4000:4000 ipple1986/hexo </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 执行完命令后看到如下一长串的数字加字母组合，表示容器创建成功</span></span></span><br><span class="line">0d9cee50df329966d679d545167b5c39ba5dc970ac194f582e73f8182df6dd7f</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来查看docker启动的容器信息（docker ps -a是查看所有创建过的容器，包括没启动的容器）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line"></span><br><span class="line">42374e8d1d18        ipple1986/hexo        "hexo server"            22 hours ago        Up 2 hours          0.0.0.0:4000-&gt;4000/tcp   some-hexo</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 看到如上信息表示你的hexo已经创建完毕，通过访问本机ip:4000访问，就能看到默认的hexo的欢迎页面</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注：部署成功后，每次更换主题，发布文章后都要执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g ## 清除缓存，重新构建</span><br><span class="line">exit ## 退出容器内</span><br><span class="line">docker restart 容器名</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>docker</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7+docker容器内部署wordpress集成环境</title>
    <url>/blog/2018/01/19/centos7+docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E7%BD%B2wordpress%E7%BB%A7%E6%89%BF%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>本篇文章记录详细讲解基于Centos7系统下容器化部署wordpress博客系统，传统在Centos7中部署wordpress需要LNMP的集成环境，而使用docker部署，我们只需要一个mysql和wordpress的镜像，然后启动镜像即可。</p>
<ol>
<li><p>在Centos7中安装docker运行环境（此处安装的为docker-ee版本，docker-ce版本也可以）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install docker -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置docker自动启动和启动docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>docker下载wordpress镜像和mysql镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull mysql</span><br><span class="line">docker pull wordpress</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看docker 镜像是否下载成功（使用docker images看到如下图所示，表示镜像下载成功）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY                  TAG             IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/mysql             latest          f008d8ff927d        3 days ago          408.5 MB</span><br><span class="line">docker.io/wordpress         latest          28084cde273b        10 days ago         408.1 MB</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动这个镜像（docker默认下载下来的是一个镜像，当这个镜像启动的时候就会创建一个基于这个镜像的容器，这里使用的是容器内部署hexo，如果需要把项目挂载到本机的目录操作，请查看我博客左上角docker分类中的另一篇部署文章）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># --name: 容器名   -p: 端口映射   -d: 以守护进程方式运行（后台）</span></span></span><br><span class="line">docker run --name mysql_db -e MYSQL_ROOT_PASSWORD=yourpassword -d docker.io/mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 执行完命令后看到如下一长串的数字加字母组合，表示容器创建成功</span></span></span><br><span class="line">0d9cee50df329966d679d545167b5c39ba5dc970ac194f582e73f8182df6dd7f</span><br><span class="line">docker run --name some-wordpress --link mysql_db:mysql -p 80:80 -d docker.io/wordpress</span><br><span class="line">0d9cee50df329966d679d545167b5c39ba5dc970ac194f582e73f8182df6dd7f</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来查看docker启动的容器信息（docker ps -a是查看所有创建过的容器，包括没启动的容器）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line"></span><br><span class="line">2ca12f671c97        docker.io/wordpress   "docker-entrypoint.sh"   14 hours ago        Up 14 hours         0.0.0.0:80-&gt;80/tcp       some-wordpress</span><br><span class="line">7bd5e6166d46        docker.io/mysql       "docker-entrypoint.sh"   14 hours ago        Up 14 hours         3306/tcp                 mysql_db</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 看到如上信息表示你的wordpress集成环境已经创建完毕，通过访问本机ip:80访问，就能看到默认的注册wordpress的欢迎注册页面</span></span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<p><img src="/blog/images/centos7+docker%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E7%BD%B2wordpress%E7%BB%A7%E6%89%BF%E7%8E%AF%E5%A2%83/1234567890.png" alt="wordpress后台管理示例页面"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>docker</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>centos7+docker本机数据挂载容器内部署hexo</title>
    <url>/blog/2018/01/19/centos7+docker%E6%9C%AC%E6%9C%BA%E6%95%B0%E6%8D%AE%E6%8C%82%E8%BD%BD%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E7%BD%B2hexo/</url>
    <content><![CDATA[<p>本篇文章继容器内部署hexo后，有些人为了能够让自己的数据更安全一些，会想到备份的问题，我在这里提供一种方式以同步本机数据和容器内hexo数据，说到底就是以挂载的方式将我们的数据挂载进docker的hexo的容器内。</p>
<ol>
<li><p>在Centos7中安装docker运行环境（此处安装的为docker-ee版本，docker-ce版本也可以）</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">yum install docker -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置docker自动启动和启动docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>docker下载hexo镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull ipple1986/hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看docker 镜像是否下载成功（使用docker images看到如下图所示，表示镜像下载成功）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY                  TAG             IMAGE ID            CREATED             SIZE</span><br><span class="line">docker.io/ipple1986/hexo    latest          8eb73a3f4772        7 months ago        426.7 MB</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动这个镜像（docker默认下载下来的是一个镜像，当这个镜像启动的时候就会创建一个基于这个镜像的容器，这里使用的是容器内部署hexo，如果需要把项目挂载到本机的目录操作，请查看我博客左上角docker分类中的另一篇部署文章）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># --name: 容器名   -p: 端口映射   -d: 以守护进程方式运行（后台）  -v: 挂载目录（本机目录 : 容器内hexo文档目录）</span></span></span><br><span class="line">docker run  -d --name some-hexo -p 4000:4000 -v /home/sj_hexo:/opt/hexo/ipple1986/source/_posts  ipple1986/hexo </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 执行完命令后看到如下一长串的数字加字母组合，表示容器创建成功</span></span></span><br><span class="line">0d9cee50df329966d679d545167b5c39ba5dc970ac194f582e73f8182df6dd7f</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来查看docker启动的容器信息（docker ps -a是查看所有创建过的容器，包括没启动的容器）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps</span><br><span class="line">CONTAINER ID        IMAGE                 COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line"></span><br><span class="line">42374e8d1d18        ipple1986/hexo        "hexo server"            22 hours ago        Up 2 hours          0.0.0.0:4000-&gt;4000/tcp   some-hexo</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 看到如上信息表示你的hexo已经创建完毕，通过访问本机ip:4000访问，就能看到默认的hexo的欢迎页面</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动成功后查看本机挂载目录的内容和hexo容器内文档目录的内容是否一致，一致表示成功（注：如果挂载目录里没有内容页面可能看不到任何效果）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps ## 查看正在运行的容器信息</span><br><span class="line">docker exec -it 容器名 /bin/bash ## 进入容器内部</span><br><span class="line">ll source/_posts/ ## 查看容器内的文章，与第5步启动容器时候的本机目录下的文章做对比</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/centos7+docker%E6%9C%AC%E6%9C%BA%E6%95%B0%E6%8D%AE%E6%8C%82%E8%BD%BD%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E7%BD%B2hexo/20180119142656.png" alt="容器挂载成功图片"></p>
</li>
<li><p>注：部署成功后，每次更换主题，发布文章后都要执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g ## 清除缓存，重新构建</span><br><span class="line">exit ## 退出容器内</span><br><span class="line">docker restart 容器名</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>docker</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>docker部署portainer（单机和集群）</title>
    <url>/blog/2018/01/19/docker%E9%83%A8%E7%BD%B2portainer%EF%BC%88%E5%8D%95%E6%9C%BA%E5%92%8C%E9%9B%86%E7%BE%A4%EF%BC%89/</url>
    <content><![CDATA[<p>近两三年来docker的热度不断上升，很多公司都采用集群化的docker部署方案，也有很多技术爱好者和IT行业人士，使用单机版的docker部署一些自己的博客之列的，在这里我主要介绍以下单机版基于Centos7的docker图形化管理界面portainer的安装和docker swarm集群下portainer的安装。</p>
<p>（一）单机版docker图形化管理界面portainer的安装</p>
<ol>
<li><p>在Centos7中安装docker</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install docker -y</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置docker自动启动和启动docker服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装portainer图形化管理界面，查看portainer容器运行状态（如果成功运行，就可以通过ip:9000访问portainer管理页面了，如果服务启动成功，浏览器查看不到页面，请看第4步）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker volume create portainer_data</span><br><span class="line">docker run -d -p 9000:9000 -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure>
</li>
<li><p>关闭或者使9000端口通过防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable firewalld ## 关闭防火墙开机自启</span><br><span class="line">systemctl stop firewalld ## 关闭防火墙</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">###############################################################</span></span></span><br><span class="line">firewall-cmd --add-port=9000/tcp --permanent ## 永久开放9000端口</span><br><span class="line">firewall-cmd --add-port=9000/tcp </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 开放9000端口（在没有关闭防火墙自启的时候，重启后9000端口将不在防火墙的白名单中）</span></span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<p>（二）集群版docker swarm图形化管理界面portainer的安装</p>
<ol>
<li><p>首先配置三台机器的hosts文件，使（三台机器）docker集群能够互相发现，10.70.23.60作为manager节点，10.70.23.61和10.70.23.62分别作为node1和node2节点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /etc/hosts</span><br><span class="line">127.0.0.1 localhost</span><br><span class="line">10.70.23.60 manager</span><br><span class="line">10.70.23.61 node1</span><br><span class="line">10.70.23.62 node2</span><br></pre></td></tr></table></figure>
</li>
<li><p>在manager机器上配置ssh免密登录，通过ssh-copy-id分发给node1和node2机器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -P ''</span><br><span class="line">ssh-copy-id -i .ssh/id_rsa.pub root@10.70.23.61</span><br><span class="line">ssh-copy-id -i .ssh/id_rsa.pub root@10.70.23.62</span><br></pre></td></tr></table></figure>
</li>
<li><p>在manager机器上安装ansible，通过ansible分发命令（注:这里选择关闭防火墙，实际环境中可自行开放端口）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum -y install ansible</span><br><span class="line">vim /etc/ansible/hosts </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 手动将10.70.23.61和10.70.23.62加入到文件最后，之后用于ansible分发命令使用</span></span></span><br><span class="line">cat /etc/ansible/hosts | grep -v ^# | grep -v ^$ </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 查看ansible/hosts的节点</span></span></span><br><span class="line">[node]</span><br><span class="line">10.70.23.61</span><br><span class="line">10.70.23.62</span><br><span class="line">vim /etc/selinux/config ## 将SELINUX=enforcing替换为SELINUX=disabled</span><br><span class="line">ansible node -m copy -a 'src=/etc/selinux/config dest=/etc/selinux/'</span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">ansible node -a 'systemctl stop firewalld' </span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 通过ansible在manager机器上执行命令，分发给所有node机器</span></span></span><br><span class="line">ansible node -a 'systemctl disable firewalld'</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 通过ansible在manager机器上执行命令，分发给所有node机器</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在manager机器上安装docker，同时设置docker开机自启和启动docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 如果本地有镜像源可以不用操作上面的三条命令</span></span></span><br><span class="line">yum -y install docker-ce</span><br><span class="line">systemctl start docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>
</li>
<li><p>在manager机器上使用ansible在所有node节点上安装docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ansible node -m copy -a 'src=/etc/yum.repos.d/docker-ce.repo dest=/etc/yum.repos.d/'</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 如果本地有镜像源可以不用操作上面的命令</span></span></span><br><span class="line">ansible node -m yum -a "state=present name=docker-ce"</span><br><span class="line">ansible node -a 'systemctl start docker'</span><br><span class="line">ansible node -a 'systemctl enable docker'</span><br></pre></td></tr></table></figure>
</li>
<li><p>在manager机器上创建docker swarm集群</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker swarm init --listen-addr 0.0.0.0</span><br><span class="line">Swarm initialized: current node (a1tno675d14sm6bqlc512vf10) is now a manager.</span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line">    docker swarm join --token SWMTKN-1-3sp9uxzokgr252u1jauoowv74930s7f8f5tsmm5mlk5oim359e-dk52k5uul50w49gbq4j1y7zzb 10.70.23.60:2377</span><br><span class="line">To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.</span><br></pre></td></tr></table></figure>
</li>
<li><p>在manager机器上查看docker swarm节点信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker node ls</span><br><span class="line">ID                           HOSTNAME      STATUS      AVAILABILITY   MANAGER STATUS</span><br><span class="line">a1tno675d14sm6bqlc512vf10 *  manager        Ready         Active           Leader</span><br></pre></td></tr></table></figure>
</li>
<li><p>在manager机器上查看加入manager管理节点的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker swarm join-token manager</span><br><span class="line">To add a manager to this swarm, run the following command:</span><br><span class="line">    docker swarm join --token SWMTKN-1-3sp9uxzokgr252u1jauoowv74930s7f8f5tsmm5mlk5oim359e-7tdlpdnkyfl1bnq34ftik9wxw 10.70.23.60:2377</span><br></pre></td></tr></table></figure>
</li>
<li><p>在各个node机器上执行第八条执行后的命令，使得所有node机器加入manager集群中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker swarm join --token SWMTKN-1-3sp9uxzokgr252u1jauoowv74930s7f8f5tsmm5mlk5oim359e-dk52k5uul50w49gbq4j1y7zzb 10.70.23.60:2377</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 执行上面的命令后提示下面的信息，表示加入node节点加入manager集群成功</span></span></span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure>
</li>
<li><p>在manager上查看node节点是否成功加入集群环境中</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker node ls</span><br><span class="line">ID                        HOSTNAME    STATUS  AVAILABILITY  MANAGER STATUS</span><br><span class="line">7zkbqgrjlsn8c09l3fagtfwre     node1  Ready      Active              </span><br><span class="line">a1tno675d14sm6bqlc512vf10 *   manager  Ready      Active         Leader</span><br><span class="line">apy9zys2ch4dlwbmgdqwc0pn3     node2  Ready      Active</span><br></pre></td></tr></table></figure>
</li>
<li><p>在manager上查看docker swarm的管理网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">05efca714d2f        bridge              bridge              local</span><br><span class="line">c9cd9c37edd7        docker_gwbridge     bridge              local</span><br><span class="line">10ac9e48d81b        host                host                local</span><br><span class="line">n60tdenc5jy7        ingress             overlay             swarm</span><br><span class="line">a9284277dc18        none                null                local</span><br></pre></td></tr></table></figure>
</li>
<li><p>在manager机器上安装portainer</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker service create \</span><br><span class="line">--name portainer \</span><br><span class="line">--publish 9000:9000 \</span><br><span class="line">--constraint 'node.role == manager' \</span><br><span class="line">--mount type=bind,src=//var/run/docker.sock,dst=/var/run/docker.sock \</span><br><span class="line">portainer/portainer \</span><br><span class="line">-H unix:///var/run/docker.sock</span><br><span class="line"></span><br><span class="line">docker images |grep portainer</span><br><span class="line">portainer/portainer  latest  07cde96d4789   2 weeks ago  10.4MB</span><br><span class="line"></span><br><span class="line">docker service ls                    ## 查看集群列表</span><br><span class="line">ID              NAME        MODE     REPLICAS      IMAGE             PORTS</span><br><span class="line">p5bo3n0fmqgz  portainer  replicated    1/1   portainer/portainer:latest   *:9000-&gt;9000/tcp</span><br></pre></td></tr></table></figure>
</li>
<li><p>在浏览器中输入ip:9000访问即可看到</p>
</li>
</ol>
<p><img src="/blog/images/docker%E9%83%A8%E7%BD%B2portainer%EF%BC%88%E5%8D%95%E6%9C%BA%E5%92%8C%E9%9B%86%E7%BE%A4%EF%BC%89/1516354296.jpg" alt="全站搜索示例图片"></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>docker</tag>
        <tag>docker swarm</tag>
        <tag>portainer</tag>
      </tags>
  </entry>
  <entry>
    <title>docker部署tomcat环境</title>
    <url>/blog/2018/01/20/docker%E9%83%A8%E7%BD%B2tomcat/</url>
    <content><![CDATA[<p>本篇文章介绍一下在docker环境中部署tomcat容器，将项目挂载到外部。</p>
<ol>
<li><p>在系统环境中安装docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> yum install docker -y</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置docker自启和启动docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl start docker</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下载tomcat镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker pull tomcat</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>启动tomcat镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker run --name jc_tomcat -v /home/jc_static_page:/usr/<span class="built_in">local</span>/tomcat/webapps/ROOT -p 8080:8080 -d docker.io/tomcat</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>分别查看本机的挂载目录里面的文件和容器内挂载目录里面的文件是否一致（没有文件的情况下，页面上有可能没有内容显示）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker <span class="built_in">exec</span> -it 容器名 /bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 可以通过上面的命令进入tomcat容器内</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开浏览器输入网址IP:8080即可看到tomcat项</p>
</li>
</ol>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>docker</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>docker配置国内镜像源</title>
    <url>/blog/2018/08/08/docker%E9%85%8D%E7%BD%AE%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E6%BA%90/</url>
    <content><![CDATA[<p>由于docker hub是在国外的，我们有时候并不能很快的下载一个image，甚至还有timeout的情况，所以我们会选择去使用中国的docker image，在我们使用中国的镜像源的时候需要进行一些简单的配置。</p>
<h5 id="一-中国有哪些可用的镜像源"><a href="#一-中国有哪些可用的镜像源" class="headerlink" title="一. 中国有哪些可用的镜像源"></a>一. 中国有哪些可用的镜像源</h5><p>docker在中国有四个不错的镜像源，分别是阿里，网易，DaoCloud ，Docker中国区官方镜像 。这些都是可以让大家随意使用的镜像源，同事也是中国最优质的镜像源。</p>
<h5 id="二-配置docker中国区官方镜像"><a href="#二-配置docker中国区官方镜像" class="headerlink" title="二. 配置docker中国区官方镜像"></a>二. 配置docker中国区官方镜像</h5><p>在这里我使用的是Docker中国区官方镜像源，目前该镜像库只包含流行的公有镜像，而私有镜像仍需要从美国镜像库中拉取，通过vi修改/etc/docker/daemon.json文件。</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">	<span class="attr">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三-重新加载修改过的docker配置文件"><a href="#三-重新加载修改过的docker配置文件" class="headerlink" title="三. 重新加载修改过的docker配置文件"></a>三. 重新加载修改过的docker配置文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>

<h5 id="四-重启docker服务"><a href="#四-重启docker服务" class="headerlink" title="四. 重启docker服务"></a>四. 重启docker服务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<h5 id="五-重新拉取镜像"><a href="#五-重新拉取镜像" class="headerlink" title="五. 重新拉取镜像"></a>五. 重新拉取镜像</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull &lt;imagename&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>flex实例</title>
    <url>/blog/2018/07/25/flex%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>最近由于换工作，没留出时间去打理博客，在上篇博客中我说要写一篇关于flex实例的博客，这篇博客包含几种常用的flex布局的方式。在后续维护中，我还会去丰富博客中的文章内容等。</p>
<h5 id="导航栏制作"><a href="#导航栏制作" class="headerlink" title="导航栏制作"></a>导航栏制作</h5><p>例如，我们制作一个五条信息的导航栏，如果使用普通的栅格布局，并没有直接的方式去实现，所以我们会使用flex布局。</p>
<p>技术点：</p>
<p>flex: 1;</p>
<p>源码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.menu</span> &#123;</span></span><br><span class="line">            display: flex</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.menu</span>&gt;<span class="selector-tag">dd</span> &#123;</span></span><br><span class="line">            flex: 1;</span><br><span class="line">            margin-left: 0px;</span><br><span class="line">            line-height: 100px;</span><br><span class="line">            text-align: center;</span><br><span class="line">            background-color: green;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dl</span> <span class="attr">class</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>菜单一<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>菜单二<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>菜单三<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>菜单四<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>菜单五<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>效果展示：</p>
<p><img src="/blog/images/flex%E5%AE%9E%E4%BE%8B/1532516311.jpg" alt="flex导航栏展示图"></p>
<h5 id="列宽固定"><a href="#列宽固定" class="headerlink" title="列宽固定"></a>列宽固定</h5><p>在一些特殊的情况下，我们会对flex的其中一列进行固定宽度的设置，让剩余列进行等分。</p>
<p>技术点：</p>
<p>flex: 0 0 50%; </p>
<p>源码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        dl &#123;</span><br><span class="line">            display: flex;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dd &#123;</span><br><span class="line">            flex: 1;</span><br><span class="line">            margin: 0px;</span><br><span class="line">            text-align: center;</span><br><span class="line">            line-height: 100px;</span><br><span class="line">            background-color: pink;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-tag">dd</span><span class="selector-pseudo">:nth-of-type(1)</span> &#123;</span></span><br><span class="line">            flex: 0 0 50%;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>菜单一<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>菜单二<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>菜单三<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>菜单四<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>菜单五<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>效果展示：</p>
<p><img src="/blog/images/flex%E5%AE%9E%E4%BE%8B/1532516344.jpg" alt="flex列宽固定展示图"></p>
<h5 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h5><p>很多时候我们在网页的布局中需要用到元素的水平垂直居中，我们一般有很多的方式去实现，在这里我们使用flex进行实现。</p>
<p>技术点：</p>
<p>justify-content: center;</p>
<p>align-items: center;</p>
<p>源码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.flex_container</span> &#123;</span></span><br><span class="line">            display: flex;</span><br><span class="line">            justify-content: center;</span><br><span class="line">            align-items: center;</span><br><span class="line">            width: 500px;</span><br><span class="line">            height: 300px;</span><br><span class="line">            border: 1px solid pink;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.content</span> &#123;</span></span><br><span class="line">            width: 160px;</span><br><span class="line">            height: 160px;</span><br><span class="line">            border: 1px solid green;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"flex_container"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>内容展示内容展示内容展示内容展示内容展示内容展示内容展示内容展示内容展示内容展示内容展示内容展示内容展示<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>效果展示：</p>
<p><img src="/blog/images/flex%E5%AE%9E%E4%BE%8B/1532516397.jpg" alt="flex水平垂直居中展示图"></p>
<h5 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h5><p>我们可以通过flex构建流式布局的页面结构。</p>
<p>技术点：</p>
<p>flex-wrap: wrap;</p>
<p>align-content: flex-start;</p>
<p>源码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.demo</span> &#123;</span></span><br><span class="line">            width: 350px;</span><br><span class="line">            height: 350px;</span><br><span class="line">            display: flex;</span><br><span class="line">            flex-wrap: wrap;</span><br><span class="line">            align-content: flex-start;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.items</span> &#123;</span></span><br><span class="line">            width: 100px;</span><br><span class="line">            height: 100px;</span><br><span class="line">            border: 1px solid red;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"items"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"items"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"items"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"items"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"items"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"items"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"items"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"items"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>效果展示：</p>
<p><img src="/blog/images/flex%E5%AE%9E%E4%BE%8B/1532516372.jpg" alt="flex流式布局展示图"></p>
<h5 id="左图右信息"><a href="#左图右信息" class="headerlink" title="左图右信息"></a>左图右信息</h5><p>很多时候我们要制作卡片结构的网站，如果使用flex会比不适用flex简单很多。</p>
<p>技术点：</p>
<p>justify-content: space-around; </p>
<p>flex: none; </p>
<p>源码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.demo</span> &#123;</span></span><br><span class="line">            width: 400px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            display: flex;</span><br><span class="line">            justify-content: space-around;</span><br><span class="line">            border: 1px solid pink;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.demo</span>&gt;<span class="selector-tag">div</span> &#123;</span></span><br><span class="line">            flex: none;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.left</span> &#123;</span></span><br><span class="line">            width: 60px;</span><br><span class="line">            height: 100%;</span><br><span class="line">            background-color: green;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.btn</span> &#123;</span></span><br><span class="line">            align-items: center;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h3</span>&gt;</span>这是一个h3<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>这是一个span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>这是一个span<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"btn"</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>效果展示：</p>
<p><img src="/blog/images/flex%E5%AE%9E%E4%BE%8B/1532516438.jpg" alt="flex左图右信息展示图"></p>
<h5 id="两端对齐"><a href="#两端对齐" class="headerlink" title="两端对齐"></a>两端对齐</h5><p>可以抛弃掉float控制两端对齐的传统方式。</p>
<p>技术点：</p>
<p>flex-direction: row;<br>justify-content: space-between;</p>
<p>源码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.demo</span> &#123;</span></span><br><span class="line">            width: 400px;</span><br><span class="line">            height: 200px;</span><br><span class="line">            display: flex;</span><br><span class="line">            flex-direction: row;</span><br><span class="line">            justify-content: space-between;</span><br><span class="line">            border: 1px solid blueviolet;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>效果展示：</p>
<p><img src="/blog/images/flex%E5%AE%9E%E4%BE%8B/1544519349.jpg" alt="flex两端对齐展示图"></p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>html</tag>
        <tag>css</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab CI对vue项目进行持续集成</title>
    <url>/blog/2018/10/16/gitlabCI%E5%AF%B9vue%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<h4 id="什么是持续集成"><a href="#什么是持续集成" class="headerlink" title="什么是持续集成"></a>什么是持续集成</h4><p>​    在软件工程中，持续集成（CI）是指将所有开发者的工作副本每天多次合并到主干的做法。Grady Booch 在1991年的 Booch method 中首次命名并提出了 CI 的概念，尽管在当时他并不主张每天多次集成。而 XP（Extreme programming，极限编程）采用了 CI 的概念，并提倡每天不止一次集成。</p>
<h4 id="使用Gitlib-CI持续集成"><a href="#使用Gitlib-CI持续集成" class="headerlink" title="使用Gitlib CI持续集成"></a>使用Gitlib CI持续集成</h4><p>​    在七月份的时候离职来到了一个初创型的公司，参与了不少的公司基础环境配置。对代码管理使用了本地Gitlib，使用docker pull下来的Gitlib镜像。所以对于我司项目的持续集成开始也考虑过Jenkins等，但是最后决定使用Gitlib的CI进行持续集成，不仅缩小了硬件资源，而且Gitlib本身集成了CI，使用起来会更方便。</p>
<h4 id="使用Gitlib-CI的基本流程"><a href="#使用Gitlib-CI的基本流程" class="headerlink" title="使用Gitlib CI的基本流程"></a>使用Gitlib CI的基本流程</h4><p>​    对于前四步我在这里就不进行介绍了，主要从Runner机器的环境配置开始一步步的介绍。</p>
<p>​    1.安装至少两台CentOS7系统的机器</p>
<p>​    2.在一台机器上面安装docker</p>
<p>​    3.然后在docker环境中安装Gitlib</p>
<p>​    4.准备一个vue项目，提交到Gitlib中</p>
<p>​    5.在另一台机器中安装Runner</p>
<p>​    6.将Runner与Gitlib中的vue项目进行关联</p>
<p>​    7.更改docker服务tcp</p>
<p>​    8.编写CI文件</p>
<p>​    9.编写Dockerfile文件</p>
<p>​    9.反复的提交，更改直到解决问题</p>
<h4 id="安装Runner"><a href="#安装Runner" class="headerlink" title="安装Runner"></a>安装Runner</h4><h5 id="参考网址"><a href="#参考网址" class="headerlink" title="参考网址"></a>参考网址</h5><p><a href="https://docs.gitlab.com/runner/install/" target="_blank" rel="noopener"> Gitlib Runner </a>官网</p>
<p><a href="https://docs.gitlab.com/runner/install/docker.html#docker-image-installation-and-configuration" target="_blank" rel="noopener"> Gitlib Runner Docker </a>环境安装文档</p>
<p><a href="https://docs.gitlab.com/runner/register/index.html#docker" target="_blank" rel="noopener"> Gitlib Runner Docker </a>注册</p>
<h5 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1.安装docker"></a>1.安装docker</h5><p>​    安装docker环境，建议使用官网的安装方式，不要使用yum等其他方式。因为官网的脚本对系统环境进        行了一些基础的配置。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -sSL https://get.docker.com/ | sh</span><br></pre></td></tr></table></figure>

<h5 id="2-编写安装脚本install-sh"><a href="#2-编写安装脚本install-sh" class="headerlink" title="2.编写安装脚本install.sh"></a>2.编写安装脚本install.sh</h5><p>​    我们可以看到，官网的安装命令其实很长的，为此我们可以封装一个shell脚本，每次通过sh命令去执行脚本进行安装。而且按照官网的安装方式还会有一个bug，我们在文章的最后会进行介绍，当然你也可以先去查看<a href="#gitlab-runner"> gitlab-runner </a>。</p>
<p>​    <img src="/blog/images/gitlabCI%E5%AF%B9vue%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/1.png" alt="1">    </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop gitlab-runner</span><br><span class="line">docker rm gitlab-runner</span><br><span class="line"></span><br><span class="line">docker run -d --name gitlab-runner --restart always \</span><br><span class="line">  -v /srv/runner/config:/etc/gitlab-runner \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure>

<h5 id="3-编写注册脚本register-sh"><a href="#3-编写注册脚本register-sh" class="headerlink" title="3.编写注册脚本register.sh"></a>3.编写注册脚本register.sh</h5><p>​    在我们把安装完Runner的镜像后，我们要进行Runner机器的注册。通过注册，我们能够与Gitlib的项目进行绑定。但是由于使用命令行注册很麻烦，所以我们要将注册编写成一个shell脚本，在这里要对url和token等一系列信息进行设置。<p style="color: red;">秘钥来自于Gitlib中你所选择的项目中的秘钥。</p></p>
<p><img src="/blog/images/gitlabCI%E5%AF%B9vue%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/2.png" alt="2"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm -t -i -v &#x2F;srv&#x2F;runner&#x2F;config:&#x2F;etc&#x2F;gitlab-runner --name gitlab-runner gitlab&#x2F;gitlab-runner register \</span><br><span class="line">  --non-interactive \</span><br><span class="line">  --executor &quot;docker&quot; \</span><br><span class="line">  --docker-image alpine:latest \</span><br><span class="line">  --url &quot;http:&#x2F;&#x2F;git.star&#x2F;&quot; \</span><br><span class="line">  --registration-token &quot;-my3Ce2mNjw1ByU56BAG&quot; \</span><br><span class="line">  --description &quot;docker-runner&quot; \</span><br><span class="line">  --tag-list &quot;admin&quot; \</span><br><span class="line">  --run-untagged \</span><br><span class="line">  --locked&#x3D;&quot;false&quot;</span><br></pre></td></tr></table></figure>

<h5 id="4-首先执行注册脚本，然后在执行安装脚本"><a href="#4-首先执行注册脚本，然后在执行安装脚本" class="headerlink" title="4.首先执行注册脚本，然后在执行安装脚本"></a>4.首先执行注册脚本，然后在执行安装脚本</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sh register.sh</span><br><span class="line">sh install.sh</span><br></pre></td></tr></table></figure>

<h5 id="5-查看Runner是否创建成功"><a href="#5-查看Runner是否创建成功" class="headerlink" title="5.查看Runner是否创建成功"></a>5.查看Runner是否创建成功</h5><p>​    出现绿色圆圈表示创建成功。</p>
<p><img src="/blog/images/gitlabCI%E5%AF%B9vue%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/3.jpg" alt="3"></p>
<h4 id="修改Runner机器中docker服务的tcp"><a href="#修改Runner机器中docker服务的tcp" class="headerlink" title="修改Runner机器中docker服务的tcp"></a>修改Runner机器中docker服务的tcp</h4><p>​    使用vim找到/lib/systemd/system/docker.service这个文件，进行编辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service</span><br></pre></td></tr></table></figure>

<p>​    找到这段代码ExecStart=/usr/bin/dockerd，在后面添加。</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H unix:///var/run/docker.sock -H tcp://<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">2375</span></span><br></pre></td></tr></table></figure>

<p>​    重新加载配置文件，重启docker服务。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>



<h4 id="编写CI文件"><a href="#编写CI文件" class="headerlink" title="编写CI文件"></a>编写CI文件</h4><p><a href="https://fennay.github.io/gitlab-ci-cn/gitlab-ci-yaml.html" target="_blank" rel="noopener"> CI文件 </a>文档</p>
<h5 id="1-在根目录中创建一个名问-gitlab-ci-yml的文件"><a href="#1-在根目录中创建一个名问-gitlab-ci-yml的文件" class="headerlink" title="1.在根目录中创建一个名问.gitlab-ci.yml的文件"></a>1.在根目录中创建一个名问.gitlab-ci.yml的文件</h5><h5 id="2-编写CI文件"><a href="#2-编写CI文件" class="headerlink" title="2.编写CI文件"></a>2.编写CI文件</h5><p>​    在文件中涉及到了一个dind的镜像，这个镜像允许我们在dind容器中使用docker命令，在文章的最后我会对其进行讲解，当然你也可以现在去查看<a href="#dind"> dind </a>。</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">docker:stable</span> <span class="comment"># 基础镜像</span></span><br><span class="line"></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">DOCKER_HOST:</span> <span class="string">tcp://dev.star:2376</span> <span class="comment"># tcp</span></span><br><span class="line">  <span class="attr">DOCKER_DRIVER:</span> <span class="string">overlay2</span> <span class="comment"># 驱动</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span> <span class="comment"># 整个持续集成分成两步</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">build</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build project:</span> <span class="comment"># job name</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">node</span> <span class="comment"># 使用node镜像</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">-g</span> <span class="string">cnpm</span> <span class="string">--registry=https://registry.npm.taobao.org</span> <span class="comment"># cnpm</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cnpm</span> <span class="string">install</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cnpm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cp</span> <span class="string">-r</span> <span class="string">Dockerfile</span> <span class="string">admin</span> <span class="comment"># 拷贝dockerfile文件</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">node_modules/</span> <span class="comment"># 为node_modules增加缓存</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">expire_in:</span> <span class="number">1</span> <span class="string">week</span> <span class="comment"># 生成文件保存周期</span></span><br><span class="line">    <span class="attr">paths:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dist</span> <span class="comment"># 编译后生成的文件夹名</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">docker:dind</span> <span class="comment"># docker in docker Gitlib官方推荐支持docker命令的docker容器，关于docker in docker我们会在文章最后进行讲解</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy project:</span> <span class="comment"># job name</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker</span> <span class="string">build</span> <span class="string">-t</span> <span class="string">hema-admin-page</span> <span class="string">.</span> <span class="comment"># 通过dockerfile构建docker images</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker</span> <span class="string">stop</span> <span class="string">hema-admin-page</span> <span class="string">||</span> <span class="literal">true</span> <span class="comment"># 通过true解决流水线重启后容器依旧存在问题</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker</span> <span class="string">rm</span> <span class="string">hema-admin-page</span> <span class="string">||</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">docker</span> <span class="string">run</span> <span class="string">--rm</span> <span class="string">-d</span> <span class="string">-p</span> <span class="number">8082</span><span class="string">:80</span> <span class="string">--name</span> <span class="string">hema-admin-page</span> <span class="string">hema-admin-page</span> <span class="comment"># 启动这个镜像</span></span><br></pre></td></tr></table></figure>



<h4 id="编写Dockerfile文件"><a href="#编写Dockerfile文件" class="headerlink" title="编写Dockerfile文件"></a>编写Dockerfile文件</h4><p>​    在上面的CI文件中，我们看到了Dockerfile文件，这个文件也是在根目录下创建。<p style="color: red;">但是需要用命令创建，因为windows本身不支持创建不带文件后缀名的文件，当然也可以不用windows。</p>至于这个Dockerfile文件的用途就是pull一个nginx镜像，然后将我们在CI文件中编译出来的dist文件夹里面的内容拷贝到nginx的html目录中，然后在CI中的deploy环节build，run。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> nginx</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> ./dist/ /usr/share/nginx/html</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>



<h4 id="提交代码测试"><a href="#提交代码测试" class="headerlink" title="提交代码测试"></a>提交代码测试</h4><p>​    接下来我们要把.gitlab-ci.yml和Dockerfile文件提交到代码仓库，这时候在对应的项目中我们点击CI/CD能看到我们的持续集成的任务跑起来，但是有成功，有失败，很难一次成功，所以要反复的调试。</p>
<p><img src="/blog/images/gitlabCI%E5%AF%B9vue%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/4.jpg" alt="4"></p>
<p>​    我们可以点击状态进入终端模式查看CI文件执行到了哪一步。</p>
<p><img src="/blog/images/gitlabCI%E5%AF%B9vue%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/5.jpg" alt="5"></p>
<br>

<p><img src="/blog/images/gitlabCI%E5%AF%B9vue%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/6.jpg" alt="6"></p>
<h4 id="有坑的环节"><a href="#有坑的环节" class="headerlink" title="有坑的环节"></a>有坑的环节</h4><h5 id="1-Gitlib-runner"><a href="#1-Gitlib-runner" class="headerlink" title="1.Gitlib runner"></a><p id="gitlab-runner">1.Gitlib runner</p></h5><p>​    我们在安装好docker的时候，官网推荐我们通过下面的这个命令下载并启动这个镜像容器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d --name gitlab-runner --restart always \</span><br><span class="line">  -v /srv/runner/config:/etc/gitlab-runner \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure>

<p>​    但是我们使用这个命令后，到了注册环节，官网给出的注册方式竟然也带了启动命令，看下面这段代码，但是这个容器并不会被创建，因为在下载的时候我们已经进行了容器的启动，所以会提示当前已经有个gitlab-runner的容器正在运行了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --rm -t -i -v &#x2F;srv&#x2F;runner&#x2F;config:&#x2F;etc&#x2F;gitlab-runner --name gitlab-runner gitlab&#x2F;gitlab-runner register</span><br></pre></td></tr></table></figure>

<p>​    为此，我想到了一种解决办法。我们去执行第一条命令下载并启动容器的命令后通过stop和rm命令，将容器停止并删除<p style="color: red;">（一定要先停止容器，在删除容器，否则会报错，这是docker运行机制决定的，或者可以强制删除容器）</p>，然后执行注册的命令，这时候容器已经启动，我们可以docker ps进行查看，到这里并不是结束，如果不去执行第一条命令，我们的会看到这个结果。</p>
<p><img src="/blog/images/gitlabCI%E5%AF%B9vue%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/7.png" alt="7"></p>
<p>​    这个三角形感叹号出现表示秘钥连接成功，但是我们的容器并不是在真正的运行，说白了，就是没有挂载第一条命令中的docker.sock文件，所以我们将容器停止删除掉后，再去执行第一条命令。</p>
<p>​    之所以要通过shell脚本进行安装和注册，就是因为中间的过程坑比较多。</p>
<h5 id="2-dind"><a href="#2-dind" class="headerlink" title="2.dind"></a><p id="dind">2.dind</p></h5><p>​    首先，我们为什么要用到dind这个镜像，因为我们在CI文件中的deploy环节中，如果直接使用nginx镜像，我们提交到仓库后，这个镜像默认是自动启动的，切没有指定tcp端口，所以我们在页面中无法查看。你也可能说我们可以将docker命令写到这个环节中，但是这样会报出一个没有docker命令的错误。导致这个错误产生的原因就是我们的nginx镜像已经启动，并且进去了这个容器中，但是这个nginx容器并没有docker命令。</p>
<p>​    <img src="/blog/images/gitlabCI%E5%AF%B9vue%E9%A1%B9%E7%9B%AE%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/8.jpg" alt="8"></p>
<p>​    所以，我们需要在docker容器中使用docker命令去下载一个nginx镜像，然后对这个镜像进行run。而Gitlib官方推荐我们的方式就是使用dind镜像，我们通过启动这个镜像，将我们的Dockerfile文件build出来一个新的镜像，然后去启动这个镜像。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    对于持续集成在开发和部署过程中起到了非常大的作用，在第一次环境部署的过程中可能会很繁琐，但是在以后开发，团队协作的过程中，减少了团队的耦合性。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>CentOS7</tag>
        <tag>Gitlab runner</tag>
        <tag>Gitlab ci</tag>
        <tag>Shell</tag>
        <tag>tcp</tag>
        <tag>Docker</tag>
        <tag>Dockerfile</tag>
      </tags>
  </entry>
  <entry>
    <title>Git规范</title>
    <url>/blog/2019/11/29/git%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a><a style="color: #4078c0;">导读</a></h4><blockquote>
<p>为了避免歧义，文档大量使用了「能愿动词」，对应的解释如下：</p>
<ul>
<li><strong>必须</strong>（Must） - 只能这样子做，请无条件遵循，没有别的选项；</li>
<li><strong>绝不</strong>（Must Not）- 严令禁止，在任何情况下都不能这样做；</li>
<li><strong>应该</strong>（Should） - 强烈建议这样做，但是不强求；</li>
<li><strong>不应该</strong>（Should Not） - 强烈建议不这样做，但是不强求；</li>
<li><strong>可以</strong>（May） - 选择性高一点</li>
</ul>
<p>参考：<a href="https://www.ietf.org/rfc/rfc2119.txt" target="_blank" rel="noopener">RFC 2119</a></p>
</blockquote>
<h4 id="branch"><a href="#branch" class="headerlink" title="branch"></a><a style="color: #4078c0;">branch</a></h4><h5 id="长期分支"><a href="#长期分支" class="headerlink" title="长期分支"></a>长期分支</h5><ul>
<li><p>master —— 主分支，<strong>必须</strong>也是线上最新代码的分支。</p>
</li>
<li><p>dev —— 开发人员的基础分支，所有的开发功能分支（feat）都<strong>必须</strong>从dev分支上进行拉取，同时也<strong>必须</strong>合并到dev分支。</p>
</li>
<li><p>test —— 测试分支，需要将dev分支合并到测试分支，进行功能的测试，如果没有问题，再将test分支合并到dev上，进行新功能的上线。</p>
</li>
</ul>
<h5 id="短期分支"><a href="#短期分支" class="headerlink" title="短期分支"></a>短期分支</h5><ul>
<li>hotfixes —— 紧急分支，用于修改master分支上的错误，修改后<strong>必须</strong>将此分支合并到master和dev分支。</li>
<li>feature —— 功能分支，功能分支<strong>必须</strong>从dev分支切出，完成后提交pr，review后<strong>必须</strong>合并到dev。</li>
<li>fix —— bug分支，用与修改非生产环境出现的bug。</li>
</ul>
<h5 id="分支规范"><a href="#分支规范" class="headerlink" title="分支规范"></a>分支规范</h5><h6 id="feature分支"><a href="#feature分支" class="headerlink" title="feature分支"></a>feature分支</h6><p>feature分支命名<strong>必须</strong>遵循feat-{yourname}/{featurename}#{issues}</p>
<h6 id="hotfixes分支"><a href="#hotfixes分支" class="headerlink" title="hotfixes分支"></a>hotfixes分支</h6><p>hotfixes分支命名<strong>必须</strong>遵循hotfix-{yourname}/{hotfixname}#{issues}</p>
<h6 id="fix分支"><a href="#fix分支" class="headerlink" title="fix分支"></a>fix分支</h6><p>fix分支命名<strong>必须</strong>遵循fix-{yourname}/{fixname}#{issues}</p>
<p style="color: red;">*注：</p>
- yourname —— 姓名
- featurename —— 功能分支名
- hotfixes —— 紧急分支名
- fix —— bug分支名
- issues —— 对应的issues，如果存在就写



<h4 id="commit"><a href="#commit" class="headerlink" title="commit"></a><a style="color: #4078c0;">commit</a></h4><h5 id="commit分类"><a href="#commit分类" class="headerlink" title="commit分类"></a>commit分类</h5><ul>
<li>feat —— 功能，feat: 添加登陆功能</li>
<li>fix —— bug，fix: 修改登录接口错误</li>
<li>hotfix —— 紧急，hotfix: 修改生产环境登录接口错误</li>
<li>docs —— 文档，docs: 修改README</li>
<li>style —— 不影响代码含义的更改（空格、格式、缺少分号等）style: 删除空格，删除console</li>
<li>perf —— 提高性能的代码更改 perf: 优化打包后的文件大小</li>
<li>test —— 添加缺失测试或纠正现有测试 test: 添加对什么方法为0的单元测试</li>
<li>build —— 影响生成系统或外部依赖项的更改（示例范围：gulp、broccoli、npm）build: 修改webpack打包配置 / build: 添加js-cookies包</li>
<li>ci —— 对CI配置文件和脚本的更改 ci: 修改xxx.yaml文件</li>
<li>chore —— 其他不修改src或测试文件的更改，如在根目录下的其他文件 chore: 修改时间格式化函数</li>
<li>refactor —— 既不修复错误也不添加功能的代码更改 refactor: 添加.gitignore</li>
<li>revert —— 还原以前的提交 revert: #62</li>
</ul>
<h4 id="pull-request"><a href="#pull-request" class="headerlink" title="pull request"></a><a style="color: #4078c0;">pull request</a></h4><ul>
<li>pr<strong>必须</strong>提交到dev分支，并由组长或项目管理人员进行review后没有问题进行合并</li>
<li>pr遇到冲突时，<strong>必须</strong>应该自己解决</li>
<li>pr<strong>应该</strong>简述功能信息</li>
</ul>
<h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a><a style="color: #4078c0;">merge</a></h4><ul>
<li><p>dev分支</p>
<p>代码通过提交pr（同时写明信息）后，<strong>必须</strong>有至少一个人进行review，review后没有问题可以合并到dev分支</p>
</li>
<li><p>hotfix分支</p>
<p>代码应从master分支切出，修改完成后<strong>必须</strong>提交两个pr分别到master和dev，在reviewer审查没问题后合并到master和dev</p>
</li>
<li><p>fix分支</p>
<p>代码从dev分支切出，在修改完成后<strong>必须</strong>提交pr（同时写明信息）后，在reviewer审查没问题后合并到dev</p>
</li>
<li><p>feat分支</p>
<p>代码从dev分支切出，在功能完成后<strong>必须</strong>提交pr（同时写明信息）后，在reviewer审查没问题后合并到dev</p>
</li>
<li><p>test分支</p>
<p>代码<strong>必须</strong>从dev分支合并进来</p>
</li>
</ul>
<h4 id="tag"><a href="#tag" class="headerlink" title="tag"></a><a style="color: #4078c0;">tag</a></h4><p>格式：vx.y.z，如v1.0.0。其中x代表主版本号，y代表次版本号，z代表补丁号</p>
<p>如果只修改了bug则对z进行加一</p>
<p>新增功能，向下兼容，没有删除功能对y进行加一</p>
<p>不向下兼容，删除功能对x进行加一</p>
<ul>
<li><p>master分支</p>
<p>master分支在每次更新生产环境时<strong>必须</strong>打tag，同时<strong>应该</strong>标注出基本信息</p>
</li>
</ul>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><a style="color: #4078c0;">注意事项</a></h4><ul>
<li><strong>绝不</strong>能直接提交代码到master，dev，test分支</li>
<li><strong>必须</strong>有一个reviewer</li>
<li>合并到master和test应由reviewer进行</li>
<li>除master，dev，test分支，其他所有分支<strong>应该</strong>在使用完成后进行销毁删除</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo文章图片显示</title>
    <url>/blog/2018/01/19/hexo%E6%96%87%E7%AB%A0%E5%9B%BE%E7%89%87%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<p>本篇文章介绍一下在hexo的框架内，想要在页面文章中显示图片的方法。</p>
<ol>
<li><p>把主页配置文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p>
</li>
<li><p>在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image --save</code>，这是下载安装一个可以上传本地图片的插件</p>
</li>
<li><p>清除缓存重新构建后，创建文章后会在文章同级的目录中有一个跟文章名一样的文件夹，图片放在里面就行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo添加全站搜索功能</title>
    <url>/blog/2018/01/19/hexo%E6%B7%BB%E5%8A%A0%E5%85%A8%E7%AB%99%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/</url>
    <content><![CDATA[<p>本篇文章介绍一下hexo的全站搜索插件，功能是十分强大的，能够查看出所有包含带有与你输入关键字相同的文章。</p>
<p><img src="/blog/images/hexo%E6%B7%BB%E5%8A%A0%E5%85%A8%E7%AB%99%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD/1516351788.jpg" alt="全站搜索示例图片"></p>
<ol>
<li><p>在hexo根目录安装插件</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改站点配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主题配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Parsing error x-invalid-end-tag</title>
    <url>/blog/2018/08/08/iview%E5%9B%9E%E6%A0%87%E7%AD%BE%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>最近在使用vue2.0整合iview3.0的时候遇到了个“Parsing error: x-invalid-end-tag”问题，说白了就是eslint检查工具的问题。iview将标签渲染为原生html标签时，由于这些标签是自闭合的，所以有end标签会报错。 </p>
<h5 id="一-问题日志"><a href="#一-问题日志" class="headerlink" title="一. 问题日志"></a>一. 问题日志</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">✘  https:&#x2F;&#x2F;google.com&#x2F;#q&#x3D;vue%2Fno-parsing-error  Parsing error: x-invalid-end-tag</span><br><span class="line">  src\components\register.vue:45:11</span><br><span class="line">            &lt;&#x2F;Input&gt;</span><br><span class="line">             ^</span><br></pre></td></tr></table></figure>

<h5 id="二-解决方案"><a href="#二-解决方案" class="headerlink" title="二. 解决方案"></a>二. 解决方案</h5><p>根目录下找到 eslintrc.js 文件，在这个文件中找到 rules 选项，在下面添加以下信息，然后重启服务器。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">'vue/no-parsing-error'</span>: [<span class="number">2</span>, &#123;<span class="string">'x-invalid-end-tag'</span>: <span class="literal">false</span>&#125;]</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/iview%E5%9B%9E%E6%A0%87%E7%AD%BE%E6%8A%A5%E9%94%99/666.png" alt="666"></p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>iview</tag>
        <tag>eslint</tag>
      </tags>
  </entry>
  <entry>
    <title>iview点击按钮清空select组件默认选中</title>
    <url>/blog/2018/08/28/iview%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%B8%85%E7%A9%BAselect%E7%BB%84%E4%BB%B6%E9%BB%98%E8%AE%A4%E9%80%89%E4%B8%AD/</url>
    <content><![CDATA[<p>最近的项目使用的是八月份更新的iview3的ui组件框架。使用了一段时间，如何去评价这个框架呢，只能说是组件比较多，源码比较渣，文档介绍不全。不过现在项目已经用上了，不能重新编写，只能硬着头皮继续了。</p>
<p>今天这个问题也是让我很头疼，就是如何在点击重置按钮时候对select组件进行选中项的清空操作。</p>
<h5 id="1-查看文档的api介绍"><a href="#1-查看文档的api介绍" class="headerlink" title="1. 查看文档的api介绍"></a>1. 查看文档的api介绍</h5><pre><code>官网的示例中并没有介绍清空select的操作，我们可以在文档中查看到这两个参数项。要想做到清空操作就要把两个参数同时使用上。</code></pre><p><img src="/blog/images/iview%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%B8%85%E7%A9%BAselect%E7%BB%84%E4%BB%B6%E9%BB%98%E8%AE%A4%E9%80%89%E4%B8%AD/1535442437.jpg" alt="1535442437"></p>
<p><br><br></p>
<p><img src="/blog/images/iview%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%B8%85%E7%A9%BAselect%E7%BB%84%E4%BB%B6%E9%BB%98%E8%AE%A4%E9%80%89%E4%B8%AD/1535442402.jpg" alt="1535442402"></p>
<h5 id="2-代码"><a href="#2-代码" class="headerlink" title="2. 代码"></a>2. 代码</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;Select v-model&#x3D;&quot;selectCouponStatus&quot; placeholder&#x3D;&quot;可用优惠券&quot; clearable ref&#x3D;&quot;oselect&quot; style&#x3D;&quot;width:200px&quot;&gt;</span><br><span class="line">        &lt;Option v-for&#x3D;&quot;item in couponStatus&quot; :value&#x3D;&quot;item.couponStatus&quot; :key&#x3D;&quot;item.couponStatus&quot;&gt;&lt;&#x2F;Option&gt;</span><br><span class="line">	&lt;&#x2F;Select&gt;</span><br><span class="line">	&lt;Button type&#x3D;&quot;warning&quot; icon&#x3D;&quot;ios-calendar-outline&quot; @click&#x3D;&quot;emptyCouponList&quot; on-clear&gt;重置&lt;&#x2F;Button&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        emptyCouponList () &#123;</span><br><span class="line">            this.$refs.oselect.clearSingleSelect()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>iview</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery / JavaScript / es6作用域、变量权限提升、暂时性死区问题</title>
    <url>/blog/2018/04/23/jQuery%20%20JavaScript%20%20es6%E4%BD%9C%E7%94%A8%E5%9F%9F%E3%80%81%E5%8F%98%E9%87%8F%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E3%80%81%E6%9A%82%E6%97%B6%E6%80%A7%E6%AD%BB%E5%8C%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>继上篇文章<a href="http://120.79.151.66:4000/2018/04/23/jQuery%20%20JavaScript%E5%BE%AA%E7%8E%AF%E8%BF%AD%E4%BB%A3%E5%8F%98%E9%87%8F%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">jQuery / JavaScript循环迭代变量导致内存泄漏问题</a>后，有很多的问题没有给大家解释清楚，这篇文章将会详细的介绍三种关于变量的遗留性问题，需要大家在编写代码的时候提高警惕性。</p>
<h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>在<a href="http://120.79.151.66:4000/2018/04/23/jQuery%20%20JavaScript%E5%BE%AA%E7%8E%AF%E8%BF%AD%E4%BB%A3%E5%8F%98%E9%87%8F%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/" target="_blank" rel="noopener">jQuery / JavaScript循环迭代变量导致内存泄漏问题</a>文章中我们提到了作用域的问题，在这里会进行更详细的讲解。</p>
<p>首先，<span style="red">在JavaScript和jQuery中只有全局作用域和函数作用域，es6中新增了块级作用域</span>，同样es6引入了一个新的定义变量的方式是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">let</code>。这个变量的声明只会作用于当前的作用域之中，如果用这个变量声明的方式去一个变量，那么这个变量就存在块级作用域。我们可以看看下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"><span class="comment">// 输出结果：a = 10</span></span><br><span class="line"><span class="comment">// 输出结果：b is not defined</span></span><br></pre></td></tr></table></figure>

<br />

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：a = 10</span></span><br><span class="line"><span class="comment">// 输出结果：b is not defined</span></span><br></pre></td></tr></table></figure>

<p>经过上面的两段代码我们可以看出JavaScript和jQuery的弊端，及用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">var</code>生命的变量不存在块级作用域。而用es6声明方式定义的变量存在块级的作用域，在其他的代码块中无法使用该变量。</p>
<h5 id="变量权限提升"><a href="#变量权限提升" class="headerlink" title="变量权限提升"></a>变量权限提升</h5><p>变量的权限提升指的是在没有声明变量的时候就对变量进行使用，这里需要注意的是，我们都知道<span style="red">JavaScript、jQuery、es6都是按照顺序从上到下执行的语言，当中间某一行出现错误，程序将中指，不会继续运行</span>。而在JavaScript和jQuery中如果出现变量权限的提升情况，控制台并不会进行报错，而会输出一个undefined，程序并不会终止，将会继续运行。在es6中如果出现这种情况，控制台会输出ReferenceError错误，我们可以看下面的代码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bar);</span><br><span class="line"><span class="keyword">let</span> bar = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 输出结果：foo = undefined</span></span><br><span class="line"><span class="comment">// 输出结果：bar is note defined</span></span><br></pre></td></tr></table></figure>

<h5 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h5><p>所谓暂时性死区是指只要块级作用域内存在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">let</code>命令，那么这个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">let</code>就绑定了这个块级作用域，当这个块级作用域内存在对<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">let</code>的变量权限提升就称之为暂时性死区</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    tmp = <span class="string">'abc'</span>;</span><br><span class="line">    <span class="keyword">let</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：tmp is note defined</span></span><br></pre></td></tr></table></figure>

<p>关于暂时性死区的其他情况我们可以查看<a href="http://es6.ruanyifeng.com/#docs/let" target="_blank" rel="noopener">es6官方文档</a></p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>JavaScript</tag>
        <tag>ECMAScript 6</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery / JavaScript循环迭代变量导致内存泄漏问题</title>
    <url>/blog/2018/04/23/jQuery%20%20JavaScript%E5%BE%AA%E7%8E%AF%E8%BF%AD%E4%BB%A3%E5%8F%98%E9%87%8F%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h5 id="jQuery-JavaScript循环迭代变量导致内存泄漏问题"><a href="#jQuery-JavaScript循环迭代变量导致内存泄漏问题" class="headerlink" title="jQuery / JavaScript循环迭代变量导致内存泄漏问题"></a>jQuery / JavaScript循环迭代变量导致内存泄漏问题</h5><p>这篇文章讲解下jQuery / JavaScript的弊端导致的内存泄漏问题，这个问题很容易被忽略，如果不被重视网站安全会有很大的危险性，希望各位能够认真对待。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通常情况下我们使用jQuery / JavaScript去做一个循环的时候，我们会这样写。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时，很多人就会问，“这个很正常啊，我们都写了很多年了，难不成还有什么问题”——来自我的一个工作了三年的同事。当然存在问题了，而且是很大的问题，在如今的信息化时代，网络安全性是很重要的，这样定义变量会存在很严重的内存泄漏问题。我们可以这样修改下程序，增加个输出的口</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">// 输出结果：10</span></span><br></pre></td></tr></table></figure>

<p>这时发现问题了，为什么我定义在for循环里的迭代变量在循环外为什么会有值，别着急，我们可以走下断点查看</p>
<p><img src="/blog/images/jQueryJavaScript%E5%BE%AA%E7%8E%AF%E8%BF%AD%E4%BB%A3%E5%8F%98%E9%87%8F%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/1-firstfor.png" alt="第一次循环i的值"></p>
<p><img src="/blog/images/jQueryJavaScript%E5%BE%AA%E7%8E%AF%E8%BF%AD%E4%BB%A3%E5%8F%98%E9%87%8F%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98/1-secondfor.png" alt="第二次循环i的值"></p>
<p>这时，细心的人一定发现了，为什么在循环外的i会有值输出，当然还会有更认真的人去调试这段程序，这时你会发现，代码会循环10次，每次的值分别是（1，2，3，4，5，6，7，8，9，10）。</p>
<p>当然出现这种问题的原因是作用域，JavaScript和jQuery只有全局作用域和函数体内作用域，没有块级作用域。块级的作用域是在es6中引入的，所以我们的循环变量i相当于一个全局变量，在任何地方都能取到值。我们可以看下面的两个例子</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ceshi(i);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ceshi</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果：10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> ceshi = <span class="function">(<span class="params">params</span>) =&gt;</span> params * params;</span><br><span class="line"><span class="built_in">console</span>.log(ceshi(i));</span><br><span class="line"><span class="comment">// 输出结果：100</span></span><br></pre></td></tr></table></figure>

<p>如果我们想要改善这段代码，最好的方式就是用es6的let方式定义循环的迭代变量，我们可以这样写。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line"><span class="comment">// 输出结果：i is not defined</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery案例（一）动态添加表单，获取表单的值，封装Json</title>
    <url>/blog/2018/01/26/jQuery%E6%A1%88%E4%BE%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E8%A1%A8%E5%8D%95%EF%BC%8C%E8%8E%B7%E5%8F%96%E8%A1%A8%E5%8D%95%E7%9A%84%E5%80%BC%EF%BC%8C%E5%B0%81%E8%A3%85json/</url>
    <content><![CDATA[<p>本篇文章介绍一下jQuery动态添加表单，获取表单的值，封装Json的方法（代码命名带有一些娱乐性，本段代码完全是在给朋友讲解的过程中手敲的，起名并不太规则），jQuery请自行引用。（注：代码可能不是最精简的方式）</p>
<p>HTML代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">name</span>=<span class="string">"chuxianba"</span> <span class="attr">id</span>=<span class="string">"chuxianba"</span>&gt;</span>chuxianba<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">id</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"tijiao"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"input-frame"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>jQuery代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> onclickNum = <span class="number">0</span>; <span class="comment">// 迭代变量</span></span><br><span class="line"><span class="keyword">var</span> getInputName = []; <span class="comment">// Json的键</span></span><br><span class="line"><span class="keyword">var</span> getInputval = []; <span class="comment">// Json的值</span></span><br><span class="line"><span class="keyword">var</span> html = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">var</span> toJson = <span class="string">''</span>;</span><br><span class="line"><span class="comment">// 动态添加网页输入框结构</span></span><br><span class="line">$(<span class="string">"#chuxianba"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  onclickNum ++;</span><br><span class="line">  html += <span class="string">'&lt;div id="frame'</span> + onclickNum + <span class="string">'"&gt;&lt;input type="text" name="hh'</span> + onclickNum + <span class="string">'"&gt;&lt;/div&gt;'</span>;</span><br><span class="line">  $(<span class="string">".input-frame"</span>).html(html);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 直接循环拼装成Json，没有用到字符串转Json方式，当然也可以使用</span></span><br><span class="line">$(<span class="string">"#submit"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  toJson += <span class="string">'[&#123;'</span>;</span><br><span class="line">  <span class="keyword">for</span> ( ; onclickNum &gt; <span class="number">0</span>; onclickNum --)&#123;</span><br><span class="line">    <span class="comment">// 动态拼接选择器，获取input的name值给getInputName数组</span></span><br><span class="line">    getInputName[onclickNum] = $(<span class="string">"#frame"</span> + onclickNum +  <span class="string">"&gt; input"</span>).attr(<span class="string">"name"</span>); </span><br><span class="line">    <span class="comment">// 动态拼接选择器，获取input的输入值</span></span><br><span class="line">    getInputval[onclickNum] = $(<span class="string">"#frame"</span> + onclickNum +  <span class="string">"&gt; input"</span>).val();</span><br><span class="line">    <span class="comment">// 迭代器默认为0（没有使用状态），第一次使用为1，累加。所以根据Json格式，最后一个是没有“，”号的，所以迭代器小于2的时候是没有“，”号的拼接</span></span><br><span class="line">    <span class="keyword">if</span>(onclickNum &lt; <span class="number">2</span>)&#123;</span><br><span class="line">      toJson += <span class="string">'"'</span> + getInputName[onclickNum] + <span class="string">'":"'</span> + getInputval[onclickNum] + <span class="string">'"'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      toJson += <span class="string">'"'</span> + getInputName[onclickNum] + <span class="string">'":"'</span> + getInputval[onclickNum] + <span class="string">'",'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  toJson += <span class="string">'&#125;]'</span>;</span><br><span class="line">  <span class="comment">// 弹出拼接好的Json串</span></span><br><span class="line">  alert(toJson);</span><br><span class="line">  <span class="built_in">window</span>.location.reload();</span><br><span class="line">  <span class="comment">// 没有后台的时候使用重载页面的方式，如果有后台form提交到action的时候需要return返回一个页面，返回页面实际就是重新载入页面，ajax提交成功的时候，会清空表单，重新等待下一条信息的输入，所以会选择重载页面（在不是动态添加表单数量的时候且用ajax提交的时候，我们可以在提交成功的时候直接清空表单数据也是可以的）</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>Json</tag>
        <tag>动态添加表单</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery案例（二）动态添加删除搜索标签，封装标签文本到数组</title>
    <url>/blog/2018/02/05/jQuery%E6%A1%88%E4%BE%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4%E6%90%9C%E7%B4%A2%E6%A0%87%E7%AD%BE%EF%BC%8C%E5%B0%81%E8%A3%85%E6%A0%87%E7%AD%BE%E6%96%87%E6%9C%AC%E5%88%B0%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>本篇文章介绍一下jQuery动态添加搜索标签，删除搜索标签，封装标签文本到数组（需要引bootstrap和jQuery查看效果），在实际开发项目中有很大的可能性遇到标签搜索的功能，通过这个例子可以为大家提供一个针对标签搜索的思路</p>
<p>HTML代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"bootstrap-3.3.7-dist/css/bootstrap.min.css"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="selector-class">.add_fljl</span>&#123;</span></span><br><span class="line">			margin: 20px 0px;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.fljl_list</span> &gt; <span class="selector-tag">div</span>&#123;</span></span><br><span class="line">			float: left;</span><br><span class="line">			max-width: 200px; </span><br><span class="line">			margin-bottom: 20px;</span><br><span class="line">			margin-right: 20px;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.a_fljl</span>&#123;</span></span><br><span class="line">			padding: 7px 10px;</span><br><span class="line"><span class="css">			<span class="selector-tag">background-color</span>: <span class="selector-id">#337ab7</span>;</span></span><br><span class="line"><span class="css">			<span class="selector-tag">color</span>: <span class="selector-id">#ffffff</span>;</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.a_fljl</span> &gt; <span class="selector-tag">span</span><span class="selector-pseudo">:first-child</span>&#123;</span></span><br><span class="line">			padding: 0px 5px;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.a_fljl</span> &gt; <span class="selector-tag">span</span><span class="selector-pseudo">:last-child</span>&#123;</span></span><br><span class="line">			padding: 0px 5px;</span><br><span class="line">			cursor: pointer;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery-3.3.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"bootstrap-3.3.7-dist/css/bootstrap.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-12"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">form</span> <span class="attr">class</span>=<span class="string">"form-inline add_fljl"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"form-group"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">label</span>&gt;</span>关键词标签：<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"fljl_input"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"search_fljl"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"添加关键词"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"up_chart"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"封装成数组"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"fljl_list"</span>&gt;</span></span><br><span class="line">			</span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">		$(<span class="string">".search_fljl"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">if</span>($(<span class="string">".fljl_input"</span>).val() == <span class="string">''</span>)&#123; <span class="comment">// 判断输入是不是空</span></span></span><br><span class="line"><span class="actionscript">				alert(<span class="string">"请在输入框内输入需要搜索的名字标签"</span>);</span></span><br><span class="line"><span class="actionscript">			&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="handlebars"><span class="xml">				$(".fljl_list").append("<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">a_fljl</span>\"&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">fljl_name</span>\"&gt;</span>" + $(".fljl_input").val() + "<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">onclick</span>=<span class="string">\</span>"<span class="attr">del_fljl</span>(<span class="attr">this</span>);\"&gt;</span><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">\</span>"<span class="attr">glyphicon</span> <span class="attr">glyphicon-trash</span>\"  <span class="attr">aria-hidden</span>=<span class="string">\</span>"<span class="attr">true</span>\"&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>");</span></span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"><span class="actionscript">		<span class="comment">// 删除一个标签</span></span></span><br><span class="line"><span class="actionscript">		<span class="function"><span class="keyword">function</span> <span class="title">del_fljl</span><span class="params">(self)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> m = confirm(<span class="string">"是否删除"</span> + $(self).prev().text() + <span class="string">"标签"</span>);</span></span><br><span class="line"><span class="actionscript">			<span class="keyword">if</span> (m == <span class="literal">true</span>)&#123;</span></span><br><span class="line"><span class="actionscript">				alert(<span class="string">"已删除"</span>);</span></span><br><span class="line"><span class="javascript">				$(self).parent().parent().remove();</span></span><br><span class="line"><span class="actionscript">			&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="actionscript">				alert(<span class="string">"已取消删除"</span>);</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="actionscript">		<span class="comment">// 封装成数组</span></span></span><br><span class="line"><span class="javascript">		$(<span class="string">".up_chart"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="actionscript">			<span class="keyword">var</span> goto_action = [];</span></span><br><span class="line"><span class="javascript">			$(<span class="string">'.fljl_list'</span>).find(<span class="string">'.fljl_name'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">				goto_action.push($(<span class="keyword">this</span>).text());</span></span><br><span class="line">			&#125;);</span><br><span class="line">			alert(goto_action);</span><br><span class="line">		&#125;);</span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><br><br></p>
<p><img src="/blog/images/jQuery%E6%A1%88%E4%BE%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E5%88%A0%E9%99%A4%E6%90%9C%E7%B4%A2%E6%A0%87%E7%AD%BE%EF%BC%8C%E5%B0%81%E8%A3%85%E6%A0%87%E7%AD%BE%E6%96%87%E6%9C%AC%E5%88%B0%E6%95%B0%E7%BB%84/zhanshi.gif" alt="效果展示"></p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>push</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery概览（一）——简单玩转jQuery</title>
    <url>/blog/2018/01/26/jQuery%E6%A6%82%E8%A7%88%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E7%8E%A9%E8%BD%ACjQuery/</url>
    <content><![CDATA[<p>本篇文章介绍一下基本的jQuery的使用规则，包含常用的选择器，属性操作等等，如果在后续还有更新，我会在这篇文章中的相应位置进行增加，请大家继续关注我的博客</p>
<p>一、选择器</p>
<p>基本选择器：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"*"</span>) <span class="comment">// 选中所有元素 </span></span><br><span class="line">$(<span class="string">"#ceshi"</span>); <span class="comment">// 选中id为ceshi的元素</span></span><br><span class="line">$(<span class="string">".ceshi"</span>); <span class="comment">// 选中class为ceshi的元素</span></span><br><span class="line">$(<span class="string">"div"</span>); <span class="comment">// 选中所有div元素</span></span><br><span class="line">$(<span class="string">"#ceshi &gt; div:first"</span>); <span class="comment">// 选中id为ceshi下的第一个div元素</span></span><br><span class="line">$(<span class="string">"#ceshi, div"</span>); <span class="comment">// 选中id为ceshi的元素和所有div元素</span></span><br><span class="line">$(<span class="string">"div:first"</span>); <span class="comment">// 选中第一个div</span></span><br><span class="line">$(<span class="string">"div:last"</span>); <span class="comment">// 选中最后一个div</span></span><br><span class="line">$(<span class="string">"div:even"</span>); <span class="comment">// 选中索引为偶数的div（从0开始）</span></span><br><span class="line">$(<span class="string">"div:odd"</span>); <span class="comment">// 选中索引为奇数的div（从0开始）</span></span><br><span class="line">$(<span class="string">"div:eq(1)"</span>); <span class="comment">// 选中索引为1的div元素</span></span><br><span class="line">$(<span class="string">"div:gt(3)"</span>); <span class="comment">// 选中索引值大于3的div元素（不包括索引值为3的div元素）</span></span><br><span class="line">$(<span class="string">"div:lt(3)"</span>); <span class="comment">// 选中索引值小于3的div元素（不包括索引值为3的div元素）</span></span><br><span class="line">$(<span class="string">"input:focus"</span>); <span class="comment">// 选中当前聚焦的input元素</span></span><br><span class="line">$(<span class="string">"div:animated"</span>); <span class="comment">// 选中当前正在执行动画的div元素</span></span><br><span class="line">$(<span class="string">"div:hidden"</span>); <span class="comment">// 选中所有隐藏的div元素</span></span><br><span class="line">$(<span class="string">"div:visible"</span>); <span class="comment">// 选中所有可见的div元素</span></span><br><span class="line">$(<span class="string">"[id]"</span>); <span class="comment">// 选中所有带有id属性的元素</span></span><br><span class="line">$(<span class="string">"[class='ceshi']"</span>); <span class="comment">// 选中所有为ceshi类的元素</span></span><br><span class="line">$(<span class="string">"[class!='ceshi']"</span>); <span class="comment">// 选中所有不为ceshi类的元素</span></span><br><span class="line">$(<span class="string">"[class$='ceshi']"</span>); <span class="comment">// 选中所有带有ceshi字符的类</span></span><br></pre></td></tr></table></figure>

<p>内容选择器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div:contains('ceshi')"</span>); <span class="comment">// 选中文本带有ceshi的所有的div</span></span><br><span class="line">$(<span class="string">"div:empty"</span>); <span class="comment">// 选中所有不包含子元素或者空文本的div</span></span><br><span class="line">$(<span class="string">"div:parent"</span>); <span class="comment">// 选中所有包含子元素或者文本元素的div</span></span><br><span class="line">$(<span class="string">"div:has(p)"</span>); <span class="comment">// 选中所有包含p元素的div元素</span></span><br></pre></td></tr></table></figure>

<p>表单选择器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">":input"</span>); <span class="comment">// 选中所有 input, textarea, select 和 button 元素</span></span><br><span class="line">$(<span class="string">":text"</span>); <span class="comment">// 选中所有 type="text" 的 &lt;input&gt; 元素</span></span><br><span class="line">$(<span class="string">":password"</span>); <span class="comment">// 选中所有 type="password" 的 &lt;input&gt; 元素</span></span><br><span class="line">$(<span class="string">":radio"</span>); <span class="comment">// 选中所有 type="radio" 的 &lt;input&gt; 元素</span></span><br><span class="line">$(<span class="string">":checkbox"</span>); <span class="comment">// 选中所有 type="checkbox" 的 &lt;input&gt; 元素</span></span><br><span class="line">$(<span class="string">":submit"</span>); <span class="comment">// 选中所有 type="submit" 的 &lt;input&gt; 元素</span></span><br><span class="line">$(<span class="string">":reset"</span>); <span class="comment">// 选中所有 type="reset" 的 &lt;input&gt; 元素</span></span><br><span class="line">$(<span class="string">":button"</span>); <span class="comment">// 选中所有 type="button" 的 &lt;input&gt; 元素</span></span><br><span class="line">$(<span class="string">":file"</span>); <span class="comment">// 选中所有 type="file" 的 &lt;input&gt; 元素</span></span><br><span class="line">$(<span class="string">":image"</span>); <span class="comment">// 选中所有 type="image" 的 &lt;input&gt; 元素 （出场率最低的type类型）</span></span><br><span class="line">$(<span class="string">":enabled"</span>); <span class="comment">// 选中所有激活的input元素</span></span><br><span class="line">$(<span class="string">":disabled"</span>); <span class="comment">// 选中所有禁用的input元素</span></span><br><span class="line">$(<span class="string">":selected"</span>); <span class="comment">// 选中所有被选取的input元素</span></span><br><span class="line">$(<span class="string">":checked"</span>); <span class="comment">// 选中所有被选中的input元素</span></span><br><span class="line">$(<span class="string">"#upparent_name"</span>).find(<span class="string">"option:selected"</span>).text() <span class="comment">// 获得id=upparent_name的下拉框选中的option的文本内容</span></span><br></pre></td></tr></table></figure>

<br>

<p>二、属性操作</p>
<p>基本属性操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).attr(<span class="string">"class"</span>); <span class="comment">// 返回文档中所有div元素的class属性值</span></span><br><span class="line">$(<span class="string">"div"</span>).attr(<span class="string">"class"</span>,<span class="string">"ceshi"</span>); <span class="comment">// 设置所有div的class属性值为ceshi</span></span><br><span class="line">$(<span class="string">"div"</span>).removeAttr(<span class="string">"class"</span>); <span class="comment">// 删除文档中所有div的class属性 （不建议使用）</span></span><br><span class="line">$(<span class="string">"img"</span>).removeProp(<span class="string">"src"</span>); <span class="comment">// 删除img的src属性 （建议使用）</span></span><br><span class="line">$(<span class="string">"input[type='checkbox']"</span>).prop(<span class="string">"checked"</span>, <span class="literal">true</span>); <span class="comment">// 选择所有被选中的复选框</span></span><br><span class="line">$(<span class="string">"input[type='checkbox']"</span>).prop(<span class="string">"checked"</span>, <span class="literal">false</span>); <span class="comment">// 选择所有没被选中的复选框</span></span><br></pre></td></tr></table></figure>

<p>CSS属性操作</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).addClass(<span class="string">"selected"</span>); <span class="comment">// 为div元素加上 'selected' 类</span></span><br><span class="line">$(<span class="string">"div"</span>).removeClass(<span class="string">"selected"</span>); <span class="comment">// 从div元素中删除 'selected' 类</span></span><br><span class="line">$(<span class="string">"div"</span>).toggleClass(<span class="string">"selected"</span>); <span class="comment">// 如果存在就删除,否则就添加</span></span><br></pre></td></tr></table></figure>

<p>HTML获取值和写入信息操作</p>
<blockquote>
<p>.html()是用来读取元素的html内容（包括html标签）；</p>
<p>.text()用来读取元素的纯文本内容，包括其后代元素；</p>
<p>.val()是用来读取表单元素的”value”值；</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'p'</span>).html(); <span class="comment">// 返回p元素的html内容</span></span><br><span class="line">$(<span class="string">"p"</span>).html(<span class="string">"ceshi &lt;b&gt;ceshi&lt;/b&gt;!"</span>); <span class="comment">// 设置p元素的html内容</span></span><br><span class="line">$(<span class="string">'p'</span>).text(); <span class="comment">// 返回p元素的文本内容</span></span><br><span class="line">$(<span class="string">"p"</span>).text(<span class="string">"ceshi"</span>); <span class="comment">// 设置p元素的文本内容</span></span><br><span class="line">$(<span class="string">"input"</span>).val(); <span class="comment">// 获取文本框中的值</span></span><br><span class="line">$(<span class="string">"input"</span>).val(<span class="string">"ceshi"</span>); <span class="comment">// 设置文本框中的内容</span></span><br></pre></td></tr></table></figure>

<br>

<p>三、jQuery对CSS的操作</p>
<p>样式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).css(<span class="string">"color"</span>); <span class="comment">// 获得p元素的color属性值</span></span><br><span class="line">$(<span class="string">"p"</span>).css(<span class="string">"color"</span>,<span class="string">"green"</span>); <span class="comment">// 为p元素设置color为green</span></span><br><span class="line">$(<span class="string">"p"</span>).css(&#123; <span class="string">"color"</span>: <span class="string">"green"</span>, <span class="string">"background"</span>: <span class="string">"yellow"</span> &#125;); <span class="comment">// 为p元素设置字体颜色和背景颜色，设置多属性的时候要使用&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>位置</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">'p'</span>).offset(); <span class="comment">// 获得p元素相对于当前视口的偏移（相对于浏览器左上角窗口）</span></span><br><span class="line">$(<span class="string">'p'</span>).offset().top; <span class="comment">// 获得p元素距离当前视口顶部偏移值</span></span><br><span class="line">$(<span class="string">'p'</span>).offset().left; <span class="comment">// 获得p元素距离当前视口左侧偏移值</span></span><br><span class="line">$(<span class="string">"p"</span>).position(); <span class="comment">// 获得p元素相对于父元素的偏移位置（可见元素才有效）</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollTop(); <span class="comment">// 获取鼠标滚轮滑动的高度</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollLeft(); <span class="comment">// 获取鼠标滚轮滑动的宽度</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollTop(<span class="string">'100'</span>); <span class="comment">// 设置垂直偏移100</span></span><br><span class="line">$(<span class="built_in">window</span>).scrollLeft(<span class="string">'100'</span>); <span class="comment">// 设置水平偏移100</span></span><br></pre></td></tr></table></figure>

<p>大小尺寸</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).height(); <span class="comment">// 获取p元素的高</span></span><br><span class="line">$(<span class="string">"p"</span>).width(); <span class="comment">// 获取p元素的宽</span></span><br><span class="line">$(<span class="string">"p:first"</span>).innerHeight(); <span class="comment">// 获得第一个p元素的区域高度（包含上下padding，不包含上下border和margin）</span></span><br><span class="line">$(<span class="string">"p:first"</span>).innerWidth(); <span class="comment">// 获得第一个p元素的区域宽度</span></span><br><span class="line">$(<span class="string">"p:first"</span>).outerHeight(); <span class="comment">// 获得第一个p元素（包括padding，border，margin）</span></span><br><span class="line">$(<span class="string">"p:first"</span>).outerWidth(); <span class="comment">// 获得第一个p元素</span></span><br><span class="line">$(<span class="string">"p:first"</span>).outerHeight(<span class="literal">true</span>); <span class="comment">// 为true时包括边距</span></span><br></pre></td></tr></table></figure>

<br>

<p>四、jQuery对文档的处理</p>
<p>内部插入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).append(<span class="string">"&lt;b&gt;ceshi&lt;/b&gt;"</span>); <span class="comment">// 在每个p元素内的最后面追加内容</span></span><br><span class="line">$(<span class="string">"&lt;b&gt;ceshi&lt;/b&gt;"</span>).appendTo(<span class="string">"p"</span>); <span class="comment">// 将内容追加到p元素的最后面</span></span><br><span class="line">$(<span class="string">"p"</span>).prepend(<span class="string">"&lt;b&gt;ceshi&lt;/b&gt;"</span>); <span class="comment">// 在每个p元素内的最前面追加内容</span></span><br><span class="line">$(<span class="string">"&lt;b&gt;ceshi&lt;/b&gt;"</span>).prependTo(<span class="string">"p"</span>); <span class="comment">// 将内容追加到p元素的最前面</span></span><br></pre></td></tr></table></figure>

<p>外部插入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).after(<span class="string">"&lt;p&gt;ceshi&lt;/p&gt;"</span>); <span class="comment">// 在同级div元素的最后插入内容</span></span><br><span class="line">$(<span class="string">"div"</span>).before(<span class="string">"&lt;p&gt;ceshi&lt;/p&gt;"</span>); <span class="comment">// 在同级div元素的最前面插入内容</span></span><br><span class="line">$(<span class="string">"p"</span>).insertAfter(<span class="string">"#ceshi"</span>); <span class="comment">// 所有p元素插入到id为ceshi元素的后面</span></span><br><span class="line">$(<span class="string">"p"</span>).insertBefore(<span class="string">"#ceshi"</span>); <span class="comment">// 所有p元素插入到id为ceshi元素的后面</span></span><br></pre></td></tr></table></figure>

<p>替换</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).replaceWith(<span class="string">"&lt;b&gt;ceshi. &lt;/b&gt;"</span>); <span class="comment">// 将匹配到的所有p元素替换成&lt;b&gt;ceshi. &lt;/b&gt;（可以是文档内容和标签元素）</span></span><br><span class="line">$(<span class="string">"&lt;b&gt;ceshi. &lt;/b&gt;"</span>).replaceAll(<span class="string">"p"</span>); <span class="comment">// 将元素或内容替换给所有选中的p元素</span></span><br></pre></td></tr></table></figure>

<p>删除</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"div"</span>).empty(); <span class="comment">// 删除匹配的div元素中所有的子节点，不包括本身</span></span><br><span class="line">$(<span class="string">"div"</span>).remove(); <span class="comment">// 删除所有匹配的元素，包括本身</span></span><br><span class="line">$(<span class="string">"div"</span>).detach(); <span class="comment">// 删除所有匹配的元素（和remove()不同的是:所有绑定的事件、附加的数据会保留下来）</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).clone(); <span class="comment">// 生成被选元素的副本，包含子节点、文本和属性</span></span><br><span class="line">$(<span class="string">"p"</span>).clone(<span class="literal">true</span>); <span class="comment">// 可选，布尔值，规定是否复制元素的所有事件处理，默认地，副本中不包含事件处理器。</span></span><br></pre></td></tr></table></figure>

<br>

<p>五、事件</p>
<p>页面载入事件（两种最常见的方式，推荐第一种方法）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>常用事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"button"</span>).click(); <span class="comment">// 单击事件</span></span><br><span class="line">$(<span class="string">"button"</span>).dblclick(); <span class="comment">// 双击事件</span></span><br><span class="line">$(<span class="string">"input[type=text]"</span>).focus(); <span class="comment">// input元素获得焦点时，触发focus事件</span></span><br><span class="line">$(<span class="string">"input[type=text]"</span>).blur(); <span class="comment">// input元素失去焦点时，触发blur事件</span></span><br><span class="line">$(<span class="string">"button"</span>).mousedown(); <span class="comment">// 当鼠标按下时触发事件</span></span><br><span class="line">$(<span class="string">"button"</span>).mouseup(); <span class="comment">// 按钮上松开鼠标按键时触发的事件</span></span><br><span class="line">$(<span class="string">"p"</span>).mousemove(); <span class="comment">// 当鼠标指针在指定元素中移动时触发的事件</span></span><br><span class="line">$(<span class="string">"p"</span>).mouseover(); <span class="comment">// 当鼠标指针位于元素上方时触发事件</span></span><br><span class="line">$(<span class="string">"p"</span>).mouseout(); <span class="comment">// 当鼠标指针从元素上方移开时触发事件</span></span><br><span class="line">$(<span class="built_in">window</span>).keydown(); <span class="comment">// 当键盘按钮被按下时触发事件</span></span><br><span class="line">$(<span class="built_in">window</span>).keypress(); <span class="comment">// 当键盘或按钮被按下时触发事件，每输入一个字符都触发一次</span></span><br><span class="line">$(<span class="string">"input"</span>).keyup(); <span class="comment">// 当按钮松开时触发事件</span></span><br><span class="line">$(<span class="built_in">window</span>).scroll(); <span class="comment">// 当窗口发生滚动时触发事件</span></span><br><span class="line">$(<span class="built_in">window</span>).resize(); <span class="comment">// 当浏览器窗口大小发生改变时触发事件</span></span><br><span class="line">$(<span class="string">"input[type='text']"</span>).change(); <span class="comment">// 当元素的值发生改变时触发事件</span></span><br><span class="line">$(<span class="string">"input"</span>).select(); <span class="comment">// 当元素中的内容被选中时触发事件</span></span><br><span class="line">$(<span class="string">"form"</span>).submit(); <span class="comment">// 当提交表单时触发事件</span></span><br><span class="line">$(<span class="built_in">window</span>).unload(); <span class="comment">// 当用户离开页面时触发事件</span></span><br></pre></td></tr></table></figure>

<p>（event object）对象，所有事件函数都可以传入event参数方便处理事件</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">event.pageX <span class="comment">// 事件发生时，鼠标距离网页左上角的水平距离</span></span><br><span class="line">event.pageY <span class="comment">// 事件发生时，鼠标距离网页左上角的垂直距离</span></span><br><span class="line">event.type <span class="comment">// 事件的类型</span></span><br><span class="line">event.which <span class="comment">// 按下了哪一个键</span></span><br><span class="line">event.data <span class="comment">// 在事件对象上绑定数据，然后传入事件处理函数</span></span><br><span class="line">event.target <span class="comment">// 事件针对的网页元素</span></span><br><span class="line">event.preventDefault() <span class="comment">// 阻止事件的默认行为(比如点击链接，会自动打开新页面)</span></span><br><span class="line">event.stopPropagation() <span class="comment">// 停止事件向上层元素冒泡</span></span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">$(<span class="string">"p"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">  alert(event.type); <span class="comment">// 弹出"click"  </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<br>

<p>六、动画效果</p>
<p>基本</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).show(); <span class="comment">// 显示匹配的元素</span></span><br><span class="line">$(<span class="string">"p"</span>).show(<span class="string">"slow"</span>); <span class="comment">// 参数表示速度,("slow","normal","fast"),也可为1000毫秒</span></span><br><span class="line">$(<span class="string">"p"</span>).hide(); <span class="comment">// 隐藏匹配的元素</span></span><br><span class="line">$(<span class="string">"p"</span>).toggle(); <span class="comment">// 切换匹配元素的显示和隐藏</span></span><br></pre></td></tr></table></figure>

<p>滑动</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).slideDown(<span class="string">"1000"</span>); <span class="comment">// 用1000毫秒的时间将元素滑下</span></span><br><span class="line">$(<span class="string">"p"</span>).slideUp(<span class="string">"1000"</span>); <span class="comment">// 用1000毫秒的时间将元素滑上</span></span><br><span class="line">$(<span class="string">"p"</span>).slideToggle(<span class="string">"1000"</span>); <span class="comment">// 用1000毫秒的时间将元素滑上滑下</span></span><br></pre></td></tr></table></figure>

<p>淡入淡出</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).fadeIn(<span class="string">"1000"</span>); <span class="comment">// 用1000毫秒的时间将元素淡入</span></span><br><span class="line">$(<span class="string">"p"</span>).fadeOut(<span class="string">"1000"</span>); <span class="comment">// 用1000毫秒的时间将元素淡出</span></span><br><span class="line">$(<span class="string">"p"</span>).fadeToggle(<span class="string">"1000"</span>); <span class="comment">// 用1000毫秒的时间将元素淡入淡出</span></span><br><span class="line">$(<span class="string">"p"</span>).fadeTo(<span class="string">"slow"</span>, <span class="number">0.6</span>); <span class="comment">// 用900毫秒的时间将元素的透明度调整到0.6</span></span><br></pre></td></tr></table></figure>

<br>

<p>对象访问控制</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.trim(); <span class="comment">// 去除字符串两端的空格</span></span><br><span class="line">$.each(); <span class="comment">// 遍历一个数组或对象，for循环</span></span><br><span class="line">$.inArray(); <span class="comment">// 返回一个值在数组中的索引位置，不存在返回-1  </span></span><br><span class="line">$.grep(); <span class="comment">// 返回数组中符合某种标准的元素</span></span><br><span class="line">$.extend(); <span class="comment">// 将多个对象，合并到第一个对象</span></span><br><span class="line">$.makeArray(); <span class="comment">// 将对象转化为数组</span></span><br><span class="line">$.type(); <span class="comment">// 判断对象的类别（函数对象、日期对象、数组对象、正则对象等等）</span></span><br><span class="line">$.isArray(); <span class="comment">// 判断某个参数是否为数组</span></span><br><span class="line">$.isEmptyObject(); <span class="comment">// 判断某个对象是否为空(不含有任何属性)</span></span><br><span class="line">$.isFunction(); <span class="comment">// 判断某个参数是否为函数</span></span><br><span class="line">$.isPlainObject(); <span class="comment">// 判断某个参数是否为用"&#123;&#125;"或"new Object"建立的对象</span></span><br><span class="line">$.support(); <span class="comment">// 判断浏览器是否支持某个特性</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>选择器</tag>
        <tag>属性操作</tag>
        <tag>CSS操作</tag>
        <tag>jQuery对CSS样式的操作</tag>
        <tag>jQuery对HTML文档结构的操作</tag>
        <tag>事间</tag>
        <tag>动画效果</tag>
        <tag>对象访问控制</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery概览（二）——简单玩转jQuery实例</title>
    <url>/blog/2018/02/02/jQuery%E6%A6%82%E8%A7%88%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E7%8E%A9%E8%BD%ACjQuery%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<p>本文介绍一下基本的jQuery的经典案例，大家可以用来参考，本文具有一定的参考价值，在实际的开发中会遇到很多类似的功能，我在这里实现了一些常用功能，可以供大家参考，后续还会在这篇文章中更新其他常用功能，大家可以收藏我的博客，继续关注</p>
<p>一、返回顶部效果</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>向上滚动<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="selector-class">.divB</span>&#123;</span></span><br><span class="line">			height: 2500px; </span><br><span class="line">			width: 100%;</span><br><span class="line">			background-color: green;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.divG</span>&#123;</span></span><br><span class="line">			width: 50px;</span><br><span class="line">			height: 50px;</span><br><span class="line"><span class="css">			<span class="selector-tag">color</span>: <span class="selector-id">#ffffff</span>;</span></span><br><span class="line">			position: fixed;</span><br><span class="line">			bottom: 30px;</span><br><span class="line">			right: 30px;</span><br><span class="line">			background-color: red;</span><br><span class="line">			cursor: pointer;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.hideG</span>&#123;</span></span><br><span class="line">			display: none;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery-3.3.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"divB"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"divG hideG"</span> <span class="attr">onclick</span>=<span class="string">"gotoTop();"</span>&gt;</span>返回顶部<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">		$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> returnTop = $(<span class="built_in">window</span>).scrollTop();</span></span><br><span class="line">			if (returnTop &gt; 180) &#123;</span><br><span class="line"><span class="javascript">				$(<span class="string">".divG"</span>).removeClass(<span class="string">'hideG'</span>);</span></span><br><span class="line"><span class="actionscript">			&#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">				$(<span class="string">".divG"</span>).addClass(<span class="string">'hideG'</span>);</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"><span class="actionscript">		<span class="function"><span class="keyword">function</span> <span class="title">gotoTop</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">			$(<span class="built_in">window</span>).scrollTop(<span class="number">0</span>);</span></span><br><span class="line">		&#125;;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p>二、左侧导航菜单</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>左侧菜单<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="selector-class">.hide</span>&#123;</span></span><br><span class="line">			display: none;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery-3.3.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"showMenu(this);"</span>&gt;</span>菜单一<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"con"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"showMenu(this);"</span>&gt;</span>菜单二<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"con hide"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"showMenu(this);"</span>&gt;</span>菜单三<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"con hide"</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">		<span class="function"><span class="keyword">function</span> <span class="title">showMenu</span><span class="params">(self)</span></span>&#123;</span></span><br><span class="line"><span class="javascript">         	$(self).next().removeClass(<span class="string">'hide'</span>).parent().siblings().children(<span class="string">'.con'</span>).addClass(<span class="string">'hide'</span>);</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<br>

<p>三、tab切换</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>tab切换<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="selector-class">.hide</span>&#123;</span></span><br><span class="line">			display: none;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="css">		<span class="selector-class">.clickMenu</span>&#123;</span></span><br><span class="line">			color: red;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery-3.3.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"tab"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">ol</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">zidingyi</span>=<span class="string">"c1"</span> <span class="attr">class</span>=<span class="string">"clickMenu"</span> <span class="attr">onclick</span>=<span class="string">"clickMenu(this);"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">zidingyi</span>=<span class="string">"c2"</span> <span class="attr">onclick</span>=<span class="string">"clickMenu(this);"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">li</span> <span class="attr">zidingyi</span>=<span class="string">"c3"</span> <span class="attr">onclick</span>=<span class="string">"clickMenu(this);"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"c1"</span>&gt;</span>c1内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"c2"</span> <span class="attr">class</span>=<span class="string">"hide"</span>&gt;</span>c2内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"c3"</span> <span class="attr">class</span>=<span class="string">"hide"</span>&gt;</span>c3内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">		<span class="function"><span class="keyword">function</span> <span class="title">clickMenu</span><span class="params">(self)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">			$(self).addClass(<span class="string">'clickMenu'</span>).siblings().removeClass(<span class="string">'clickMenu'</span>);</span></span><br><span class="line"><span class="javascript">			$(<span class="string">"#"</span> + $(self).attr(<span class="string">'zidingyi'</span>)).removeClass(<span class="string">'hide'</span>).siblings().addClass(<span class="string">'hide'</span>);</span></span><br><span class="line">		&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>返回顶部效果</tag>
        <tag>左侧导航菜单</tag>
        <tag>tab切换</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery调试方式</title>
    <url>/blog/2018/04/23/jQuery%E8%B0%83%E8%AF%95%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h5 id="调试工具介绍（谷歌浏览器的js调试方式）"><a href="#调试工具介绍（谷歌浏览器的js调试方式）" class="headerlink" title="调试工具介绍（谷歌浏览器的js调试方式）"></a>调试工具介绍（谷歌浏览器的js调试方式）</h5><p>首先，我要讲解的是jQuery的常见问题和弊端，那就离不开能够调试jQuery的debug工具，由于jQuery是脚本化的客户端程序，所以很多ide都没有对jQuery提供debug程序，当然我相信未来还是会有的。不过这些都没有关系，我们可以试用谷歌浏览器的js调试程序对jQuery的运行进行调试。</p>
<p>我在浏览器中打开了一个名为es6.html的页面，里面的内容为sublime中的内容</p>
<p><img src="/blog/images/jQuery%E8%B0%83%E8%AF%95%E6%96%B9%E5%BC%8F/webOpenHtml.png" alt="浏览器打开es6.html页面"></p>
<p><img src="/blog/images/jQuery%E8%B0%83%E8%AF%95%E6%96%B9%E5%BC%8F/sublimeOpenHtml.png" alt="sublime打开es6.html页面"></p>
<p>然后在浏览器中按F12调用调试台，点击Sources选项，之后在代码的行号位置，可以通过单击的方式选择断点的位置</p>
<p><img src="/blog/images/jQuery%E8%B0%83%E8%AF%95%E6%96%B9%E5%BC%8F/caozuo.png" alt="打开控制台选择Sources选项，之后在代码想要调试的行号进行单击"></p>
<p>之后可以在右上角找到调试的基本操作，在这里我就不多说了，大家可以自己进行尝试</p>
<p><img src="/blog/images/jQuery%E8%B0%83%E8%AF%95%E6%96%B9%E5%BC%8F/debug.png" alt="debug"></p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>jQuery debug</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用工具类——多线程（一）线程和进程</title>
    <url>/blog/2018/01/23/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p>本篇文章介绍一下Java常用工具类——多线程，在学习多线程的时候我们一定要明确两个知识点，什么是进程、线程，只有在明确进程和线程的区别之后才能更好的理解Java多线程的概念</p>
<p>（一）什么是进程</p>
<p>​    <img src="/blog/images/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/1516676550.jpg" alt="进程的举例图片"></p>
<p>​    首先我们可以看一下上面的图片，这个图片是在windows操作系统下任务管理器看到的界面，其中红色箭头指向的就是当前机器上的所有进程显示的列表。</p>
<p>​    那么什么是进程，之前有人问我什么是进程，我就告诉他打开任务管理器点击进程下面你能看到的列表的应用程序都是进程。这么说没错，但是还是举个例子比较好。</p>
<p>​    假如身为程序员的你，坐在电脑前，一边写着代码、一边听着网易云音乐、谷歌浏览器搜索着什么是线程（进程和线程的区别）那么你很有可能搜到我这篇文章偶、另一边由于业务打开QQ进行聊天，你所有开着的任务能够都是当前系统的进程。例如记事本是单进程，而比较大的软件，例如数据库是由多个进程组成的。在早期的操作系统中我们的电脑都是单任务的，就是你打开的QQ和浏览器，只能运行一个，这个运行完才能运行下一个。而现在的操作系统都是多任务的，允许你同时运行很多个应用程序。</p>
<p>（二）什么是线程</p>
<p>​    线程我们可以理解为比进程还要小的运行单位，一个进程包含多个线程，线程可以看作是一个子程序</p>
<p>（三）那么问题来了程序的运行是靠cpu处理的，我只有一个cpu，它是怎么去处理很多应用程序的多进程和其中一个应用程序的多线程</p>
<br>

<p><img src="/blog/images/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/151667776.jpg" alt="linux系统下查看cpu的信息"></p>
<div style="text-align: center;font-size:13px;">linux系统下查看cpu的信息</div>

<br>

<p><img src="/blog/images/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/1516677835.jpg" alt="windows系统下查看cpu的信息"></p>
<div style="text-align: center;font-size:13px;">windwos系统下查看cpu的信息</div>

<br>

<p>​    首先我们可以了解以下cpu的基本信息，在公司运行项目的服务器中，一般采用的都是linux的操作系统，可以看到我们服务器的主板是插了两个cpu的，每块cpu是十二个核心，每个核心是两个线程（即一块cpu是十二核心二十四线程），所以这个服务器是有两块十二核心二十四线程构成的四十八线程的cpu。而对于我们的个人电脑多数是采用windows系统（所以附上两张图片），一般主板只支持一颗cpu，而我的这颗cpu是四核心八线程的。</p>
<p>​    这里我们可以把cpu的所有线程想象成时间，每个线程都是一个很小的时间片，时间片的时间可以非常短，因为cpu的运算是很快的。所以这些程序会在很短的时间内轮流使用cpu，它使用的时间会非常短，所以我们很难察觉到。而我们的多任务操作系统，就是应用程序快速的轮转使用cpu的一个核心或者线程，从而达成的多任务操作的。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用工具类——多线程（三）线程相关</title>
    <url>/blog/2018/01/23/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>本篇文章介绍一下Java多线程的其他概念和相关的操作方式</p>
<br>

<p>（一）多线程分为五个状态：新建、可运行（就绪状态）、正在运行、阻塞、终止</p>
<br>

<p>（二）所谓线程的生命周期就是线程的五个状态的相互转换的过程。终止线程的stop()方法在新的jdk中已经不推荐使用了</p>
<p><img src="/blog/images/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3/xiancheng.png" alt="线程生命周期图"></p>
<br>

<p>（三）sleep()方法是Thread类中的一个方法，通过以下方式调用，作用是在制定毫秒内让正在执行的线程休眠（暂停执行）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span></span>;</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 实现接口就要去实现它里面的方法，这里就是去实现Runnable接口里面的run()方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"执行第"</span> + i + <span class="string">"次"</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 防止在休眠期间线程中断</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于getName()方法是Thread类中的方法，我们没有继承Thread，而是通过Runnable接口的方式，所以要通过Thread.currentThread().getName()这个获取线程名称，这句话的意思是：调用Thread类的一个静态方法currentThread()代指当前线程，再去调用getName()方法，即获取当前正在运行的线程的线程名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SleepDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">    t.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>（四）join()方法也是Thread类的一个方法，通过以下方式进行调用，作用是等待调用该方法的线程结束后才能执行（调用该方法的线程优先执行，执行后其它没有调用该方法的线程才会执行），join()方法是一种抢占资源的方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span>; </span><br><span class="line"><span class="comment">// 等待该线程终止的最长时间为millis毫秒，例：a线程调用join(1000)，表示不管a线程是否执行完，只要执行到1000毫秒就去实行其它线程，即millis毫秒后交出a线程的使用权，之后的线程执行顺序变无序</span></span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(getName() + <span class="string">"正在运行"</span> + i + <span class="string">"次"</span>);</span><br><span class="line">      <span class="comment">// 因为该方法继承于Thread，所以可以直接调用Thread的getName()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mt.join();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(<span class="string">"主线程正在运行"</span> + i + <span class="string">"次"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"主线程运行结束了"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果，调用join()方法的线程优先执行</span></span><br><span class="line">Thread-<span class="number">0</span>正在运行<span class="number">0</span>次</span><br><span class="line">Thread-<span class="number">0</span>正在运行<span class="number">1</span>次</span><br><span class="line">...</span><br><span class="line">Thread-<span class="number">0</span>正在运行<span class="number">9</span>次</span><br><span class="line">主线程正在运行<span class="number">0</span>次</span><br><span class="line">主线程正在运行<span class="number">1</span>次</span><br><span class="line">...</span><br><span class="line">主线程正在运行<span class="number">9</span>次</span><br></pre></td></tr></table></figure>

<br>

<p>（五）线程优先级</p>
<p>1.Java为线程类提供10个优先级等级</p>
<p>2.优先级可以用1-10的正数表示，超出范围内的数字会抛出IllegalArgumentException异常</p>
<p>3.主线程默认优先级是5</p>
<p>4.数字越大表示的优先级越高</p>
<p>5.优先级常量</p>
 <div class="table-responsive"><table class="table table-striped table-bordered table-hover"><tr><td>线程优先级常量</td><td>说明</td></tr><tr><td>MIN_PRIORITY = 1</td><td>线程的最低优先级1</td>
 </tr><tr><td>NORM_PRIORITY = 5</td><td>线程的默认优先级5</td></tr><tr><td>MAX_PRIORITY = 10</td><td>线程的最高优先级10</td></tr></table></div>

<p>6.线程优先级的相关方法</p>
 <div class="table-responsive"><table class="table table-striped table-bordered table-hover"><tr><td>线程优先级的方法</td><td>说明</td></tr><tr><td>public int getPriority()</td><td>获取线程优先级的方法</td></tr><tr><td>public void setPriority(int newPriority)</td><td>设置线程优先级的方法</td></tr></table></div>

<p>7.例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Mythread</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 构造方法为线程名赋值</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(name + <span class="string">"正在运行第"</span> + i + <span class="string">"次"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mainPriority = Thread.currentThread().getPriority();</span><br><span class="line">    <span class="comment">// 获取主线程优先级，使用Thread.currentThread().getPriority()是因为，主线程是当前正在运行的线程</span></span><br><span class="line">    System.out.println(<span class="string">"主线程的优先级为："</span> + mainPriority);</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread(<span class="string">"线程1"</span>);</span><br><span class="line">    <span class="comment">// 给自定义线程起名，赋给mt对象</span></span><br><span class="line">    mt.setPriority(<span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 等价于mt.setPriority(Thread.MAX_PRIORITY);</span></span><br><span class="line">    <span class="comment">// 设置自定义线程为最高优先级</span></span><br><span class="line">    mt.start();</span><br><span class="line">    System.out.println(<span class="string">"线程1的优先级为："</span> + mt.getPriority());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果，根据操作系统和系统环境的不同，不能保证高优先级的线程一定优先执行</span></span><br><span class="line">主线程的优先级为：<span class="number">5</span></span><br><span class="line">线程<span class="number">1</span>正在运行第<span class="number">0</span>次</span><br><span class="line">线程<span class="number">1</span>正在运行第<span class="number">1</span>次</span><br><span class="line">...</span><br><span class="line">线程<span class="number">1</span>正在运行第<span class="number">9</span>次</span><br><span class="line">线程<span class="number">1</span>的优先级为：<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修改主方法，MyThread方法不动，增加一个自定义线程 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">"线程1"</span>);</span><br><span class="line">    MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">"线程2"</span>);</span><br><span class="line">    mt1.setPriority(<span class="number">10</span>);</span><br><span class="line">    mt2.setPriority(<span class="number">1</span>);</span><br><span class="line">    mt1.start();</span><br><span class="line">    mt2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果虽然两个线程优先级不一样，但是依然存在乱序的可能性</span></span><br></pre></td></tr></table></figure>

<br>

<p>（六）线程同步</p>
<p>谈到线程同步，不得不说我们在之前的学习中遇到的问题</p>
<p>1.各个线程是通过竞争cpu的时间而获得运行机会的</p>
<p>2.各线程什么时候得到cpu的时间、占用多久是不可预测的</p>
<p>3.一个正在运行的进程在什么地方被暂停是不确定的</p>
<p>为保证一个线程能够从头到尾执行完毕，我们要对这个线程进行锁定，使用关键字synchronized实现，synchronized关键字可以用在成员方法、静态方法、语句块中，例如银行的一个账户存取款的问题</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>线程</tag>
        <tag>线程的状态和生命周期</tag>
        <tag>sleep方法</tag>
        <tag>join方法</tag>
        <tag>线程的优先级</tag>
        <tag>线程同步</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用工具类——多线程（二）Thread和Runnable的基本介绍和创建方式</title>
    <url>/blog/2018/01/23/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89Thread%E5%92%8CRunnable%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>本篇文章介绍一下Java的Thread线程对象和Runnable接口实现类</p>
<div class="table-responsive"><table class="table table-striped table-bordered table-hover"><tr><td>构造方法</td><td>说明</td></tr><tr><td>Thread()</td><td>创建一个线程对象</td>
</tr><tr><td>Thread(String name)</td><td>创建一个指定名称的线程对象</td></tr><tr><td>Thread(Runnable target)</td><td>创建一个基于Runnable接口实现类的线程对象</td></tr><tr><td>Thread(Runnable target, String name)</td><td>创建一个基于Runnable接口实现类，并具有指定名称的线程对象</td></tr></table></div>

<p>Thread()构造方法中包含以下四种方法</p>
<div class="table-responsive"><table class="table table-striped table-bordered table-hover"><tr><td>方法</td><td>说明</td></tr><tr><td>public void run()</td><td>线程相关代码写在该方法中（一般需要重写）</td>
</tr><tr><td>public void start()</td><td>启动线程方法</td></tr><tr><td>public static void sleep(long m)</td><td>线程休眠m毫秒的方法</td></tr><tr><td>public void join()</td><td>优先执行调用join()方法的线程</td></tr></table></div>

<p>Runnable则只有一个run()方法，Runnable是Java中用以实现现成的接口，任何实现线程功能的类都必须实现该接口</p>
<br>

<p>（一）通过继承Thread类创建线程，在下面的代码中自定义线程类是占用一个线程，主函数默认占用一个线程，主函数的线程内容会先于自定义线程中的内容执行</p>
<p>例1：简单的创建一个线程类，打印输出字符串，观察线程执行顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义线程类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(getName() + <span class="string">"  该线程正在运行"</span>);</span><br><span class="line">    <span class="comment">// 调用Thread的getName()方法是获得线程名称</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过主函数启动自定义的线程类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"这是主线程的第一个输出，用来测试线程执行顺序"</span>);</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    <span class="comment">// 初始化MyThread线程类，定义名称为mt</span></span><br><span class="line">    mt.start();</span><br><span class="line">    <span class="comment">// 启动自定义线程类</span></span><br><span class="line">    System.out.println(<span class="string">"这是主线程的第二个输出，用来测试线程执行顺序"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">这是主线程的第一个输出，用来测试线程执行顺序</span><br><span class="line">这是主线程的第二个输出，用来测试线程执行顺序</span><br><span class="line">Thread-<span class="number">0</span>  该线程正在运行</span><br></pre></td></tr></table></figure>

<p>例2：创建一个较为复杂的线程类，通过循环打印输出的方式查看两个自定义线程类的运行状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span> <span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="comment">// 调用Thread类的方法</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(getName() + <span class="string">"正在运行"</span> + i + <span class="string">"次"</span>);</span><br><span class="line">      <span class="comment">// 因为该方法继承于Thread，所以可以直接调用Thread的getName()方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt1 = <span class="keyword">new</span> MyThread(<span class="string">"线程1"</span>);</span><br><span class="line">    MyThread mt2 = <span class="keyword">new</span> MyThread(<span class="string">"线程2"</span>);</span><br><span class="line">    mt1.start();</span><br><span class="line">    mt2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果（线程1和线程2交替无序的运行，每个线程运行10次）</span></span><br><span class="line">线程<span class="number">1</span>正在运行<span class="number">0</span>次</span><br><span class="line">线程<span class="number">1</span>正在运行<span class="number">1</span>次</span><br><span class="line">线程<span class="number">2</span>正在运行<span class="number">0</span>次</span><br><span class="line">线程<span class="number">2</span>正在运行<span class="number">1</span>次</span><br><span class="line">线程<span class="number">2</span>正在运行<span class="number">2</span>次</span><br><span class="line">线程<span class="number">2</span>正在运行<span class="number">3</span>次</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<br>

<p>（二）通过实现Runnable接口的方式创建线程（为什么要通过Runnable接口实现创建线程：Java不支持多继承，假设一个方法继承了另一个方法，就不能在继承Thread类了；或者就是不打算重写Thread类的其他方法，一般我们只是使用run()方法，如果不打算重写Thread类的其他方法，只想修改run()方法，我们就可以使用Runnable接口的方式创建线程；Runnable接口中的run()方法支持多线程共享，即可以在多线程处理同一问题的情况下使用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">  <span class="comment">// 实现接口就要去实现它里面的方法，这里就是去实现Runnable接口里面的run()方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread().getName() + <span class="string">"正在运行，第"</span> + i + <span class="string">"次"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由于getName()方法是Thread类中的方法，我们没有继承Thread，而是通过Runnable接口的方式，所以要通过Thread.currentThread().getName()这个获取线程名称，这句话的意思是：调用Thread类的一个静态方法currentThread()代指当前线程，再去调用getName()方法，即获取当前正在运行的线程的线程名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    PrintRunnable pr1 = <span class="keyword">new</span> PrintRunnable();</span><br><span class="line">    <span class="comment">// 创建PrintRunnable类对象</span></span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(pr1);</span><br><span class="line">    <span class="comment">// 创建Thread类的对象，将pr接口当参数存进t的对象中</span></span><br><span class="line">    t1.start();</span><br><span class="line">    PrintRunnable pr2 = <span class="keyword">new</span> PrintRunnable();</span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(pr2);</span><br><span class="line">    t2.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果（两个和两个以上线程运行起来具有随机性，先后顺序无法确定）</span></span><br><span class="line">Thread-<span class="number">1</span>正在运行，第<span class="number">0</span>次</span><br><span class="line">Thread-<span class="number">0</span>正在运行，第<span class="number">0</span>次</span><br><span class="line">Thread-<span class="number">1</span>正在运行，第<span class="number">1</span>次</span><br><span class="line">Thread-<span class="number">1</span>正在运行，第<span class="number">2</span>次</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Thread</tag>
        <tag>Runnable</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用工具类——输入输出流（一）基本介绍</title>
    <url>/blog/2018/01/26/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>本篇文章介绍一下Java输入输出流，我们可以通过以下两张图看出输出输入流的基本流程方式。</p>
<br>

<h4 style="color: rgb(42,111,160);">1.Java流的分类</h4>

<blockquote>
<p>按流向分:</p>
<p>输入流: 程序可以从中读取数据的流。<br>输出流: 程序能向其中写入数据的流。</p>
<p>按数据传输单位分:</p>
<p>字节流: 以字节为单位传输数据的流<br>字符流: 以字符为单位传输数据的流</p>
<p>按功能分:</p>
<p>节点流: 用于直接操作目标设备的流<br>过滤流: 是对一个已存在的流的链接和封装，通过对数据进行处理为程序提供功能强大、灵活的读写功能。</p>
</blockquote>
<br>

<h4 style="color: rgb(42,111,160);">2.什么是I/O</h4>

<blockquote>
<p>​    Java中I/O操作主要是指使用Java进行输入，输出操作. Java所有的I/O机制都是基于数据流进行输入输出，这些数据流表示了字符或者字节数据的流动序列。Java的I/O流提供了读写数据的标准方法。任何Java中表示数据源的对象都会提供以数据流的方式读写它的数据的方法。  </p>
<p>​    Java.io是大多数面向数据流的输入/输出类的主要软件包。此外，Java也对块传输提供支持，在核心库 java.nio中采用的便是块IO。</p>
<p>　　流IO的好处是简单易用，缺点是效率较低。块IO效率很高，但编程比较复杂。<br>     Java IO模型  :<br>​        Java的IO模型设计非常优秀，它使用Decorator模式，按功能划分Stream，您可以动态装配这些Stream，以便获得您需要的功能。例如，您需要一个具有缓冲的文件输入流，则应当组合使用FileInputStream和BufferedInputStream。</p>
</blockquote>
<br>

<p><img src="/blog/images/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/1516931978.jpg" alt="输出流"></p>
<br>

<p><img src="/blog/images/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/1516932106.jpg" alt="输入流"></p>
<br>

<h4 style="color: rgb(42,111,160);">3.如何选择IO流模式</h4>

<p>1）确定数据源和数据目标位置（输入和输出）</p>
<p>源 / 输入：InputStream   Reader</p>
<p>目标位置 / 输出： OutputStream   Writer</p>
<p>2）明确操作对象是否是纯文本（判断字符字节流）</p>
<p>是 / 字符流：Reader   Writer</p>
<p>否 / 字节流：InputStream   OutputStream</p>
<p>3）明确设备</p>
<div class="table-responsive"><table class="table table-striped table-bordered table-hover"><tbody><tr><td></td><td>数据源 / 输入</td><td>目标位置 / 输出</td></tr><tr><td>键盘</td><td>System.in</td><td>System.out</td></tr><tr><td>硬盘</td><td>File</td><td>File</td></tr><tr><td>网络</td><td>socket.getInputStream()</td><td>socket.getOutputStream()</td></tr><tr><td>内存</td><td>byte型数组：ByteArrayInputStream<br>char型数组：CharArrayReader</td><td>byte型数组：ByteArrayOutputStream<br>char型数组：CharArrayWriter</td></tr></tbody></table></div>

<p>4）是否需要转换流</p>
<p>是，就使用转换流，从Stream转化为Reader，Writer：InputStreamReader，OutputStreamWriter </p>
<p>5）是否需要缓冲提高效率</p>
<p>是就加上Buffered：BufferedInputStream, BufferedOuputStream, BuffereaReader, BufferedWriter</p>
<br>

<h4 style="color: rgb(42,111,160);">4.IOException异常的子类</h4>

<p>针对IOException的异常又三个子类，分别是</p>
<p>1）EOFException： 非正常到达文件尾或输入流尾时，抛出的异常</p>
<p>2）FileNotFoundException： 当文件找不到时，抛出的异常</p>
<p>3）InterruptedIOException：当I/O操作被中断时，抛出的异常</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>输入输出流</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用工具类——输入输出流（二）File类介绍和常用方法</title>
    <url>/blog/2018/02/22/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88%E4%BA%8C%EF%BC%89File%E7%B1%BB%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>作为2018年的第一篇文章（阴历），将继续为大家写一些关于计算机各个方面的文档，大家可以查看，也可以将问题、意见等通过Email的方式发送给我，我的Email为<a href="mailto:1778651752@qq.com">1778651752@qq.com</a>。</p>
<p>本篇文章介绍一下Java输出输出的File类。File——文件，文件可认为是相关记录或放在一起的数据集合；在Java中，使用java.io.File类对文件进行操作</p>
<p>例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建File对象，方法一</span></span><br><span class="line">    File file1 = <span class="keyword">new</span> File(<span class="string">"c:\\filestudy\\study.txt"</span>); <span class="comment">// Window系统路径的写法</span></span><br><span class="line">    <span class="comment">// File file1 = new File("/home/study.txt"); Linux系统的写法</span></span><br><span class="line">    <span class="comment">// 创建File对象，方法二</span></span><br><span class="line">    <span class="comment">// File file1 = new File("c:\\filestudy", "study.txt");</span></span><br><span class="line">    <span class="comment">// 创建File对象，方法三</span></span><br><span class="line">    <span class="comment">// File file = new File("c:\\filestudy");</span></span><br><span class="line">    <span class="comment">// File file1 = new File(file, "study.txt");</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是文件还是目录</span></span><br><span class="line">    System.out.println(<span class="string">"是否是目录："</span> + file1.isDirectory());</span><br><span class="line">    System.out.println(<span class="string">"是否是文件："</span> + file1.isFile());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建单级目录</span></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">"c:\\filestudy"</span>, <span class="string">"hashset"</span>);</span><br><span class="line">    <span class="comment">// 判断是否filestudy下是否有hashset目录</span></span><br><span class="line">    <span class="keyword">if</span>(!file2.exists())&#123;</span><br><span class="line">      file2.mkdir();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建多级目录</span></span><br><span class="line">    File file2 = <span class="keyword">new</span> File(<span class="string">"c:\\filestudy\\set\\hashset"</span>);</span><br><span class="line">    <span class="comment">// 判断是否filestudy下是否有hashset目录</span></span><br><span class="line">    <span class="keyword">if</span>(!file2.exists())&#123;</span><br><span class="line">      file2.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建文件</span></span><br><span class="line">    File file3 = <span class="keyword">new</span> File(<span class="string">"c:\\filestudy\\newStudy.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span>(file3.exists())&#123;</span><br><span class="line">      <span class="keyword">try</span>&#123;</span><br><span class="line">        file3.createNewFile();</span><br><span class="line">      &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>输入输出流</tag>
        <tag>File类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用工具类——集合（一）ArrayList</title>
    <url>/blog/2018/01/22/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94%E9%9B%86%E5%90%88ArrayList/</url>
    <content><![CDATA[<p>本篇文章介绍一下Java常用工具类中的ArrayList，ArrayList是有序的允许有重复数据的集合。ArrayList底层是由数组构成的，所以支持有序的排列方式。ArrayList和数组的区别在于，ArrayList是支持动态增长的</p>
<ol>
<li><p>导入List和ArrayList需要的包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先要想使用ArrayList需要在主函数（或者函数）中对ArrayList进行初始化，其中list为自己定义的ArrayList名，在下面对该ArrayList进行操作的时候都是以list的名字代指这个ArrayList的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure>
</li>
<li><p>对ArrayList进行添加数据操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(<span class="string">"java"</span>); <span class="comment">// 当add方法只有一个参数时，表示在ArrayList末尾添加内容</span></span><br><span class="line">list.add(<span class="string">"c++"</span>);</span><br><span class="line">list.add(<span class="string">"go"</span>);</span><br><span class="line">list.add(<span class="number">1</span>, <span class="string">"c"</span>); <span class="comment">// 当add方法有两个参数的时候，表示在指定位置插入，这样写表示在java和c++中间插入一个c</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改ArrayList中最后一个元素go的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.set(<span class="number">3</span>, <span class="string">"今年最火语言是go语言"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获得ArrayList中的元素个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.size();</span><br></pre></td></tr></table></figure>
</li>
<li><p>移除列表中的元素（可以通过删除下标的方式，也可以通过删除对象的方式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.remove(<span class="number">0</span>); <span class="comment">// 通过删除下标的方式删除元素</span></span><br><span class="line">list.remove(<span class="string">"java"</span>); <span class="comment">// 通过删除对象的方式删除元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>删除ArrayList中的所有值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.clear();</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看ArrayList某一个位置的元素内容（通过get方法的下标方式进行查看）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对ArrayList的数据进行遍历输出（一般提到数组的遍历输出，List的遍历输出我们一般都是通过for循环的方式，循环数组或者List的长度进行输出）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">  Systemctl.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于ArrayList中的其他方法可以参阅java官方文档，本文列举的是ArrayList的出现率最高的几个方法。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java常用工具类</tag>
        <tag>List</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用工具类——集合（三）HashMap</title>
    <url>/blog/2018/01/23/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94%E9%9B%86%E5%90%88HashMap/</url>
    <content><![CDATA[<p>本篇文章介绍一下Java常用工具类中的HashMap，HashMap是基于哈希表的Map接口的一个实现类，它是以键值对的方式存储的（无序存储），并且允许拥有一对空的键值且key值不允许重复。</p>
<ol>
<li><p>导入Map和HashMap需要的包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对HashMap进行初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line"><span class="comment">// HashMap泛型指定键值对数据类型</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>map添加数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.put(key, value); </span><br><span class="line"><span class="comment">// 这里为要填入的键值对数据，通过put方法添加到名为map的HashMap列表中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打印输出map中的值，使用迭代器打印输出，首先导入Iterator包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过迭代器输出HashMap中的value</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; it = map.values().iterator(); <span class="comment">// 获取map中所有的value存到it中</span></span><br><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">  Systemctl.out.print(<span class="string">" "</span> + it.next() + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过entrySet方法获得HashMap中的key、value</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 导入Set需要的包</span></span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="comment">// 将HashMap通过entrySet方法赋值给set，Set类型是Entry类型，Entry类型是HashMap的String数据类型</span></span><br><span class="line">Set&lt;Entry&lt;String, String&gt;&gt; set = map.entrySet();</span><br><span class="line"><span class="comment">// 通过增强型for循环遍历输出</span></span><br><span class="line"><span class="keyword">for</span>(Entry&lt;String, String&gt; entry:entrySet)&#123;</span><br><span class="line">  Systemctl.out.print(entry.getKey()); </span><br><span class="line">  <span class="comment">// 通过增强型for循环对Entry类型的重命名（entry）获取到key值</span></span><br><span class="line">  Systemctl.out.print(entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>本文讲解的是HashMap的常用方法，如果想了解其他方法可以查阅官网的文档</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java常用工具类</tag>
        <tag>Map</tag>
        <tag>HashMap</tag>
        <tag>Iterator</tag>
        <tag>Set</tag>
        <tag>entrySet</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常用工具类——集合（二）HashSet</title>
    <url>/blog/2018/01/22/java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB%E2%80%94%E2%80%94%E9%9B%86%E5%90%88HashSet/</url>
    <content><![CDATA[<p>本篇文章介绍一下Java常用工具类中的HashSet：HashSet是Set的一个重要实现类，称为哈希集；HashSet是无序的不允许有重复数据的集合；HashSet中只允许有一个null元素（因为HashSet是不允许有重复数据的，所以HashSet只能有一个空元素）；HashSet具有良好的存取和查找性能。</p>
<ol>
<li><p>导入Set和HashSet需要的包</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br></pre></td></tr></table></figure>
</li>
<li><p>首先要想使用HashSet需要在主函数（或者函数）中对HashSet进行初始化，其中Set为自己定义的HashSet名，在下面对该HashSet进行操作的时候都是以Set的名字代指这个HashSet的数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set set = <span class="keyword">new</span> HashSet();</span><br></pre></td></tr></table></figure>
</li>
<li><p>对HashSet进行添加数据操作，不同于ArrayList的是HashSet是无序存储，所以没有办法指定在某个元素和某个元素的下一个元素中间插入一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set.add(<span class="string">"java"</span>);</span><br><span class="line">set.add(<span class="string">"c++"</span>);</span><br><span class="line">set.add(<span class="string">"go"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器Iterator，是HashSet进行遍历输出的一个接口，在使用Iterator前，要进行包的导入。其中Iterator下有两个方法，一个是hasNext()作用于判断当前元素是否还有下一个元素，一个是next()作用于返回当前元素的下一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化迭代器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator it = set.iterator();</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过迭代器遍历输出HashSet中的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">  Systemctl.out.print(<span class="string">" "</span> + it.next() + <span class="string">" "</span>); <span class="comment">// 空格是在区分没个元素，给每个元素增加间距</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除HashSet中的一个元素（由于HashSet是无序组合，所以只能通过remove对象的方式进行删除，无法通过下标方式删除）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">set.remove(<span class="string">"java"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果要add一个相同元素，编译器并不会报错，依然能够运行，但是重复的元素不会被插入到HashSet中</p>
</li>
<li><p>本文讲解的是HashSet的常用方法，如果想了解其他方法可以查阅官网的文档</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java常用工具类</tag>
        <tag>Iterator</tag>
        <tag>Set</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title>linux服务器之间远程拷贝文件及文件夹</title>
    <url>/blog/2018/02/28/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
    <content><![CDATA[<p>本篇介绍一下关于linux服务器之间拷贝文件的方法，在实际生产环境中使用率还是很高的。因为我们不可能把文件从linux服务器上拷贝到主机，再把主机文件拷贝到另一台服务器上。这样操作不仅时间成本大大增加，而且工作效率还会大打折扣。</p>
<p>首先要使用远程拷贝文件，建议首先安装ssh免密钥登录，这样在后续的拷贝文件中，就不用再去输入密码了。常用的依赖ssh的命令有scp、sftp、openssh等</p>
<p>（一）ssh免密钥登录方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ssh-keygen // 生成私钥公钥对，一直输入回车即可</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9/db9c2660786be447af615832e167ed6b.png" alt="生成私钥公钥对"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /root/.ssh/id_rsa.pub // 查看生成的公钥</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9/0fc598c8a5fd5342810132e322d32bee.png" alt="查看生成的公钥"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ssh-copy-id -i ~/.ssh/id_rsa.pub 10.2.18.30 // 将公钥推送到远端服务器上，第一次需要验证密码</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E9%97%B4%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D%E6%96%87%E4%BB%B6%E5%8F%8A%E6%96%87%E4%BB%B6%E5%A4%B9/42ddefd9660658418a901b2a8b1fd2e7.png" alt="将公钥推送到远端服务器上"></p>
<p>（二）scp拷贝文件及文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> scp -r /home/<span class="built_in">test</span>/ root@10.2.8.124:/root/ // 拷贝本机/home/<span class="built_in">test</span>整个目录至远程主机10.2.8.124的/root目录下</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> scp /home/test.txt root@10.2.8.124:/root/ // 拷贝单个文件至远程主机</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> scp root@10.2.8.124:/home/a.txt /home // 从远程主机拷贝文件至本机</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> scp -r root@10.2.8.124:/home/web /home // 从远程主机拷贝文件夹至本机</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>scp</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>nuxt整合iView</title>
    <url>/blog/2018/09/12/nuxt%E6%95%B4%E5%90%88iView/</url>
    <content><![CDATA[<p>最近使用vue做项目的时候，需要对页面进行seo优化，众所周知spa对seo支持很不友好。所以，最开始的解决方式是vue-meta-info和prerender-spa-plugin的组合，通过预渲染的方式进行。但是经过实际的实践操作，发现预渲染并不能很好的处理大量的异步请求和大量路由页面的项目。为此只好去踩坑nuxt了。</p>
<p>关于nuxt在github上面有一个简单的demo我们可以安装下来进行查看。</p>
<p><img src="/blog/images/nuxt%E6%95%B4%E5%90%88iView/1536737877.jpg" alt="1536737877"></p>
<p>项目成功跑起来后我们可以通过localhost:3000端口进行查看。</p>
<p><img src="/blog/images/nuxt%E6%95%B4%E5%90%88iView/1536737963.jpg" alt="1536737963"></p>
<h5 id="1-下载iView"><a href="#1-下载iView" class="headerlink" title="1. 下载iView"></a>1. 下载iView</h5><p>在package.json文件中的dependencies下面添加iview版本号信息。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="string">"iview"</span>: <span class="string">"^3.0.0"</span></span><br></pre></td></tr></table></figure>

<p>然后在命令行终端执行cnpm install后会在node_modules目录下面多处一个iview的文件夹。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install</span><br></pre></td></tr></table></figure>

<h5 id="2-创建并编写Iview-js配置文件"><a href="#2-创建并编写Iview-js配置文件" class="headerlink" title="2. 创建并编写Iview.js配置文件"></a>2. 创建并编写Iview.js配置文件</h5><p>由于nuxt项目结构和我们普通的vue项目结构不同，这时很多人下载了iview并不知道怎么去引用到我们的项目中，实际在nuxt官网上面，已经对各个文件夹有了说明，其中的plugins文件夹为实例化之前需要运行的 Javascript 插件。</p>
<p><img src="/blog/images/nuxt%E6%95%B4%E5%90%88iView/1536740176.jpg" alt="1536740176"></p>
<p>我们需要在plugins文件夹下创建一个Iview.js的文件，这个文件的文件名首字母必须大写，否则在运行的时候会报错。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Iview <span class="keyword">from</span> <span class="string">'iview'</span></span><br><span class="line">Vue.use(Iview)</span><br></pre></td></tr></table></figure>

<h5 id="3-在nuxt-config-js中引用"><a href="#3-在nuxt-config-js中引用" class="headerlink" title="3. 在nuxt.config.js中引用"></a>3. 在nuxt.config.js中引用</h5><p>我们要把Iview的文件在nuxt的配置文件中进行引入，同时也要导入iView的css文件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">plugins: [&#123;</span><br><span class="line">    src: <span class="string">'~plugins/Iview.js'</span>,</span><br><span class="line">    ssr: <span class="literal">true</span>,</span><br><span class="line">&#125;],</span><br><span class="line">css: [</span><br><span class="line">    <span class="string">'iview/dist/styles/iview.css'</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="4-防止iView被webpack打包多次"><a href="#4-防止iView被webpack打包多次" class="headerlink" title="4. 防止iView被webpack打包多次"></a>4. 防止iView被webpack打包多次</h5><p>我们需要在nuxt.config.js中的build方法中，添加一个参数，防止多次打包。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">vendor:[<span class="string">'iview'</span>]</span><br></pre></td></tr></table></figure>

<h5 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h5><p>到iView官网中找到一个按钮，放到我们项目中pages文件夹下的index.vue文件中，打开浏览器就能看到iView的组件了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Button type&#x3D;&quot;primary&quot;&gt;Primary&lt;&#x2F;Button&gt;</span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/nuxt%E6%95%B4%E5%90%88iView/1536740765.jpg" alt="1536740765"></p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>nuxt</tag>
        <tag>iView</tag>
      </tags>
  </entry>
  <entry>
    <title>session存储</title>
    <url>/blog/2018/05/15/session%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<p>在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象（默认情况下）。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。 </p>
<h5 id="导入依赖包"><a href="#导入依赖包" class="headerlink" title="导入依赖包"></a>导入依赖包</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</span><br></pre></td></tr></table></figure>

<h5 id="使用request-获取session"><a href="#使用request-获取session" class="headerlink" title="使用request 获取session"></a>使用request 获取session</h5><p>HttpSession是不能new出来的，要从HttpServletRequest中调用getSession方法得到。一般也就是request.getSession(); </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span><br></pre></td></tr></table></figure>

<h5 id="对session的操作"><a href="#对session的操作" class="headerlink" title="对session的操作"></a>对session的操作</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">session.setAttribute(<span class="string">"key"</span>, value); <span class="comment">// 设置</span></span><br><span class="line">session.getAttribute(<span class="string">"key"</span>); <span class="comment">// 获取</span></span><br><span class="line">session.removeAttribute(<span class="string">"key"</span>); <span class="comment">// 移出</span></span><br><span class="line">session.invalidate(); <span class="comment">// 删除所有session中保存的键</span></span><br></pre></td></tr></table></figure>

<h5 id="jsp中获取session"><a href="#jsp中获取session" class="headerlink" title="jsp中获取session"></a>jsp中获取session</h5><figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%= session.getAttribute(<span class="string">"key"</span>) %&gt;</span><br></pre></td></tr></table></figure>

<h5 id="后台示例"><a href="#后台示例" class="headerlink" title="后台示例"></a>后台示例</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/getBigDatalist.action"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="function"><span class="keyword">public</span> AjaxBean <span class="title">getBigDatalist</span><span class="params">(Integer page,HttpServletResponse response, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    response.setCharacterEncoding(<span class="string">"UTF=8"</span>); <span class="comment">// 设置响应的编码方式</span></span><br><span class="line">    response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>); <span class="comment">// 设置响应的内容类型</span></span><br><span class="line">    HttpSession session = request.getSession(); <span class="comment">// 创建一个session对象</span></span><br><span class="line">    Page&lt;dashujvBean&gt; list = service.getBigDatalist(<span class="keyword">new</span> RowBounds(page, <span class="number">10</span>));</span><br><span class="line">    session.setAttribute(<span class="string">"pageSize"</span>, list.getPageSize());</span><br><span class="line">    <span class="keyword">long</span> count = list.getTotal();</span><br><span class="line">    ajaxBean = <span class="keyword">new</span> AjaxBean();</span><br><span class="line">    ajaxBean.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">    ajaxBean.setData(list);</span><br><span class="line">    ajaxBean.setCount(count);</span><br><span class="line">    <span class="keyword">return</span> ajaxBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>java</tag>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>ssm通过poi导出word</title>
    <url>/blog/2018/02/28/ssm%E9%80%9A%E8%BF%87poi%E5%AF%BC%E5%87%BAword/</url>
    <content><![CDATA[<p>应公司开发项目的需求，需要编写一个，通过前台传入的id查询数据库中的title和abs字段的信息，以word的形式下载到本地进行查看。这里我通过poi的方式进行数据封装word，同时进行word排版，最后进行下载。在后续的开发中可能回遇到下载成excal表格，到时候我会定期更新。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value =<span class="string">"/downloadforreport.action"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xiazaiword</span><span class="params">(HttpServletResponse response)</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		XWPFDocument doc = <span class="keyword">new</span> XWPFDocument(); <span class="comment">// 创建一个word文档</span></span><br><span class="line">		XWPFParagraph p1 = doc.createParagraph(); <span class="comment">// 创建一个段落为p1</span></span><br><span class="line">		p1.setAlignment(ParagraphAlignment.CENTER); <span class="comment">// p1段落内容设置居中</span></span><br><span class="line">		XWPFParagraph p2 = doc.createParagraph(); <span class="comment">// 创建另一个段落为p2</span></span><br><span class="line">		XWPFRun r1 = p1.createRun(); <span class="comment">// 为p1段落创建文本内容r1</span></span><br><span class="line">		r1.setText(<span class="string">"hahahaha"</span>); <span class="comment">// 为r1设置内容</span></span><br><span class="line">		r1.setFontSize(<span class="number">20</span>); <span class="comment">// r1字体大小为20</span></span><br><span class="line">		r1.setBold(<span class="keyword">true</span>); <span class="comment">// r1字体加粗</span></span><br><span class="line">		XWPFRun r2 = p2.createRun(); <span class="comment">// 为p2段落创建文本内容r2</span></span><br><span class="line">		r2.setText(<span class="string">"xixixixixi"</span>); <span class="comment">// 为r2设置内容</span></span><br><span class="line">		response.setCharacterEncoding(<span class="string">"utf-8"</span>); <span class="comment">// 设置编码格式</span></span><br><span class="line">		response.setContentType(<span class="string">"multipart/form-data"</span>); <span class="comment">// java中通用下载文件</span></span><br><span class="line">		response.setHeader(<span class="string">"Content-Disposition"</span>, <span class="string">"attachment;fileName=downfile.docx"</span> ); <span class="comment">// 设置文件头和文件名</span></span><br><span class="line">		OutputStream out = response.getOutputStream(); <span class="comment">// 创建一个输出流</span></span><br><span class="line">		doc.write(out); <span class="comment">// 开始写入</span></span><br><span class="line">		out.close(); <span class="comment">// 关闭输出流</span></span><br><span class="line">	&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<br>

<p>接下来通过浏览器访问方法名进行测试</p>
<br>

<p><img src="/blog/images/ssm%E9%80%9A%E8%BF%87poi%E5%AF%BC%E5%87%BAword/64dd3ac9ad9c294b849b31d1e1f5f724.png" alt="测试方法是否成功"></p>
<br>

<p>对于其它word的格式设置，可以百度”poi导出word“相关文章进行查看。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>ssm</tag>
        <tag>poi</tag>
      </tags>
  </entry>
  <entry>
    <title>this、apply、call and bind</title>
    <url>/blog/2019/05/13/this%E3%80%81apply%E3%80%81call%E3%80%81bind/</url>
    <content><![CDATA[<p>本篇文章会详细讲解<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">JavaScript</code>中的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">this</code>相关的问题。</p>
<blockquote>
<p>[1] 如果你在阅读中发现错误或者存在某些问题可以通过邮件的形式发送到作者的邮箱，再收到邮件后作者会及时处理这些问题。</p>
<p>[2] 阅读文章后你能了解到的有this 指向、apply、call和bind方法。</p>
</blockquote>
<hr>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>在深入了解<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">this</code>前，我们要知道<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">this</code>在调用函数时能够控制使用不同的上下文环境，同时<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">this</code>永远指向最后调用它的对象，在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">EcmaScript</code>中已经有效的规避的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">this</code>容易产生的错误，但是在我们阅读某个框架源码的时候，还是要深入了解下<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">this</code>。</p>
<hr>
<h4 id="理解this指向"><a href="#理解this指向" class="headerlink" title="理解this指向"></a>理解this指向</h4><p>我们通过例子去理解this指向的问题。</p>
<p>例如我们拥有一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">USER</code>的对象，并且通过点号的形式进行调用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> USER = &#123;</span><br><span class="line">  name: <span class="string">'Taylor'</span>,</span><br><span class="line">  age: <span class="number">34</span>,</span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;USER.name&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">USER.greet()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// name: Taylor</span></span><br><span class="line"><span class="comment">// name: Taylor</span></span><br></pre></td></tr></table></figure>

<p>可以看到我们在调用方法的时候相当于把<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">this</code>指向了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">USER</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> STUDENT = &#123;</span><br><span class="line">  name: <span class="string">'Taylor'</span>,</span><br><span class="line">  age: <span class="number">12</span>,</span><br><span class="line">  greet() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;STUDENT.name&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  mother: &#123;</span><br><span class="line">    name: <span class="string">'Swift'</span>,</span><br><span class="line">    age: <span class="number">35</span>,</span><br><span class="line">    greet() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;STUDENT.mother.name&#125;</span>`</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">STUDENT.greet()</span><br><span class="line">STUDENT.mother.greet()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：</span></span><br><span class="line"><span class="comment">// name: Taylor</span></span><br><span class="line"><span class="comment">// name: Taylor</span></span><br><span class="line"><span class="comment">// name: Swift</span></span><br><span class="line"><span class="comment">// name: Swift</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="改变this指向"><a href="#改变this指向" class="headerlink" title="改变this指向"></a>改变this指向</h4><p>能够改变<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">this</code>指向的操作有：</p>
<ul>
<li><p>箭头函数</p>
</li>
<li><p>函数内部使用_this = this</p>
</li>
<li><p>apply</p>
</li>
<li><p>call</p>
</li>
<li><p>bind</p>
</li>
<li><p>new一个对象</p>
</li>
</ul>
<h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OBJ = &#123;</span><br><span class="line">  name: <span class="string">'Taylor'</span>,</span><br><span class="line">  time1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>) <span class="comment">// name: windowName</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  time2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`name: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>) <span class="comment">// name: Taylor</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OBJ.time1()</span><br><span class="line">OBJ.time2()</span><br></pre></td></tr></table></figure>



<h5 id="函数内部使用-this-this"><a href="#函数内部使用-this-this" class="headerlink" title="函数内部使用_this = this"></a>函数内部使用_this = this</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OBJ = &#123;</span><br><span class="line">  name: <span class="string">'Taylor'</span>,</span><br><span class="line">  time1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`NAME: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>) <span class="comment">// name: windowName</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  time2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`NAME: <span class="subst">$&#123;_this.name&#125;</span>`</span>) <span class="comment">// name: Taylor</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OBJ.time1()</span><br><span class="line">OBJ.time2()</span><br></pre></td></tr></table></figure>



<h5 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OBJ = &#123;</span><br><span class="line">  name: <span class="string">'Taylor'</span>,</span><br><span class="line">  time1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`NAME: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>) <span class="comment">// name: windowName</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  time2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`NAME: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>) <span class="comment">// name: Taylor</span></span><br><span class="line">    &#125;.apply(OBJ), <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OBJ.time1()</span><br><span class="line">OBJ.time2()</span><br></pre></td></tr></table></figure>



<h5 id="call"><a href="#call" class="headerlink" title="call"></a>call</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OBJ = &#123;</span><br><span class="line">  name: <span class="string">'Taylor'</span>,</span><br><span class="line">  time1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`NAME: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>) <span class="comment">// name: windowName</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  time2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`NAME: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>) <span class="comment">// name: Taylor</span></span><br><span class="line">    &#125;.call(OBJ), <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OBJ.time1()</span><br><span class="line">OBJ.time2()</span><br></pre></td></tr></table></figure>



<h5 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OBJ = &#123;</span><br><span class="line">  name: <span class="string">'Taylor'</span>,</span><br><span class="line">  time1: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`NAME: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>) <span class="comment">// name: windowName</span></span><br><span class="line">    &#125;, <span class="number">0</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  time2: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`NAME: <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>) <span class="comment">// name: Taylor</span></span><br><span class="line">    &#125;.bind(OBJ)(), <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OBJ.time1()</span><br><span class="line">OBJ.time2()</span><br></pre></td></tr></table></figure>



<h5 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> func = <span class="keyword">new</span> User(<span class="string">'Taylor'</span>, <span class="number">27</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="apply和call的区别"><a href="#apply和call的区别" class="headerlink" title="apply和call的区别"></a>apply和call的区别</h4><ul>
<li>apply接受一个包含多个参数的数组</li>
<li>call接受多个参数</li>
</ul>
<h5 id="apply传参"><a href="#apply传参" class="headerlink" title="apply传参"></a>apply传参</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OBJ =&#123;</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b) <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = OBJ.fn;</span><br><span class="line">func.apply(OBJ, [<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>



<h5 id="call传参"><a href="#call传参" class="headerlink" title="call传参"></a>call传参</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OBJ =&#123;</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b) <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = OBJ.fn;</span><br><span class="line">func.call(OBJ, <span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="bind和apply、call的区别"><a href="#bind和apply、call的区别" class="headerlink" title="bind和apply、call的区别"></a>bind和apply、call的区别</h4><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">bind</code>方法创建一个新的函数, 当<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">bind</code>被调用时，将其<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">this</code>指向为<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">bind</code>的第一个参数，在调用新函数时提供剩余参数序列。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> OBJ =&#123;</span><br><span class="line">  fn: <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a + b) <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> func = OBJ.fn;</span><br><span class="line">func.bind(OBJ, <span class="number">1</span>, <span class="number">2</span>)()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>this</tag>
        <tag>apply</tag>
        <tag>call</tag>
        <tag>bind</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router介绍以及历史模式404问题</title>
    <url>/blog/2019/03/12/vue-router%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%8E%86%E5%8F%B2%E6%A8%A1%E5%BC%8F404%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h4 id="vue-router实现原理"><a href="#vue-router实现原理" class="headerlink" title="vue-router实现原理"></a>vue-router实现原理</h4><p>​    路由这个概念早期是后端开发人员提出来的，在传统的模版引擎中，我们经常可以看到如下网址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.xxx.com&#x2F;login</span><br></pre></td></tr></table></figure>

<p>​    在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue-router</code>中我们有两种路由模式<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">hash</code>，<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">history</code>。这两种模式都属于浏览器的自身特性，利用这两个特性，通过调用浏览器提供的接口来实现路由的功能。简单来说路由就是用来跟后端服务器进行交互的一种方式，通过不同的路径，来请求不同的资源，请求不同的页面是路由的其中一种功能。</p>
<p>​    但是在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue-router</code>中我们还有一种模式叫<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">abstract</code>。该模式支持所有<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">javascript</code>运行模式。如果发现没有浏览器的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">API</code>，路由会自动强制进入这个模式，在此篇文章中不做过多解释。</p>
<p>​    随着<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">ajax</code>的技术的流行，我们能够通过不刷新浏览器页面的情况下进行数据的交互操作，甚至更高级的单页面应用——<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">SPA</code>，能够办到不仅仅是页面交互无刷新，还可以是页面跳转无刷新，因此在现如今的前端开发中也就有了路由的概念，但是在2014年前，大家都是通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">hash</code>来实现路由的。</p>
<h4 id="hash介绍"><a href="#hash介绍" class="headerlink" title="hash介绍"></a>hash介绍</h4><p>​    <code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">hash</code>模式路由使用的是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">URL</code>的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">hash</code>值来作为路由，该模式的路由地址中会存在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">#</code>号，能够支持所有的浏览器，并且兼容<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">IE8</code>。该模式背后的原理是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">onhashchange</code>，在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">window</code>上我们能够通过编写方法监听该事件。</p>
<p>​    <code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">#</code>号后面的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">hash</code>值的变化，并不会导致浏览器向服务器发出请求，浏览器不发出请求，就不会刷新页面。同时<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">hash</code>的变化会出发<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">onhashchange</code>时间，通过这个事件我们就会知道<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">hash</code>值发生了哪些变化，通过这些变化来实现页面部分内容的操作。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-id">#bg-color</span> &#123;</span></span><br><span class="line">            width: 200px;</span><br><span class="line">            height: 200px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bg-color"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.location.hash = <span class="string">'yellow'</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.onhashchange = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(event.oldURL, event.newURL)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> hash = location.hash.slice(<span class="number">1</span>)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> hash1 = <span class="built_in">window</span>.location.hash</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(hash, hash1)</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'bg-color'</span>).style.backgroundColor = hash</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/blog/images/vue-router%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E5%8E%86%E5%8F%B2%E6%A8%A1%E5%BC%8F404%E9%97%AE%E9%A2%98/1552403988863.jpg" alt="1552403988863"></p>
<h4 id="history介绍"><a href="#history介绍" class="headerlink" title="history介绍"></a>history介绍</h4><p>​    在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">h5</code>发布之后，多出了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">pushState</code>和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">replaceState</code>两个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">API</code>，通过这两个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">API</code>可以改变链接地址且不发送请求，同时多出一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">popstate</code>事件。历史模式路由可以分为三大部分，分别是切换、修改、拦截，并且改模式的路由只能兼容到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">IE10</code>。</p>
<p>​    <code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">history</code>不同于<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">hash</code>的地方在于，<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">hash</code>是拿来做页面定位的，如果拿来做路由，锚点功能就不能用了，而且<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">hash</code>传参是基于<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">URL</code>的，如果传递复杂的数据会有体积的限制，而<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">history</code>不仅可以把数据放入到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">URL</code>中，也可以将数据存放在一个特定的对象中。</p>
<h5 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.go(<span class="number">-2</span>); <span class="comment">// 后退两次</span></span><br><span class="line"><span class="built_in">window</span>.history.go(<span class="number">2</span>); <span class="comment">// 前进两次</span></span><br><span class="line"><span class="built_in">window</span>.history.back(); <span class="comment">// 后退</span></span><br><span class="line"><span class="built_in">window</span>.history.forward(); <span class="comment">// 前进</span></span><br><span class="line"><span class="built_in">window</span>.history.lengthk(); <span class="comment">// 查看当前历史堆栈中的页面数量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.pushState(state, title, url)</span><br><span class="line"><span class="comment">// state: 需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取</span></span><br><span class="line"><span class="comment">// title：标题，基本没用，一般传 null</span></span><br><span class="line"><span class="comment">// url：设定新的历史记录的 url。新的 url 与当前 url 的 origin 必须是一樣的，否则会抛出错误。url可以是绝对路径，也可以是相对路径</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.history.replaceState(state, title, url)</span><br><span class="line"><span class="comment">// 与 pushState 基本相同，但她是修改当前历史记录，而 pushState 是创建新的历史记录</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"popstate"</span>, () =&gt; &#123;</span><br><span class="line">    <span class="comment">// 监听浏览器前进后退事件，pushState 与 replaceState 方法不会触发              </span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h4 id="history模式下的404问题"><a href="#history模式下的404问题" class="headerlink" title="history模式下的404问题"></a>history模式下的404问题</h4><p>​    对于<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>项目的开发环境下，我们使用历史模式路由是不会存在问题的，因为我们使用的是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">node</code>服务器，<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">dev</code>中已经配置好了，但是我们在生产环境对项目打包后部署在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">nginx</code>上的时候，点击刷新或者其他操作的时候有可能会出现404页面的问题，遇到这种问题我们可以在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">nginx</code>中增加如下配置信息就可以解决：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">root</span>   /data/nginx/html;</span><br><span class="line">    <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">        <span class="attribute">rewrite</span><span class="regexp"> ^/(.*)</span> /index.html <span class="literal">last</span>;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-router</tag>
        <tag>hash</tag>
        <tag>history</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>vue使用钩子函数做路由鉴权</title>
    <url>/blog/2018/08/09/vue%E4%BD%BF%E7%94%A8%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%81%9A%E8%B7%AF%E7%94%B1%E9%89%B4%E6%9D%83/</url>
    <content><![CDATA[<p>一般情况下，在用户未登录的时候我们一些功能是不能让用户使用的，当我们点击这些连接的时候会跳转到登陆的页面，当用户登陆后才能够进行操作，这个功能我们简称路由鉴权，在vue中我们使用路由鉴权，需要使用vue的钩子函数以及vue-router路由管理。</p>
<h5 id="1-全局引入vue-router"><a href="#1-全局引入vue-router" class="headerlink" title="1.全局引入vue-router"></a>1.全局引入vue-router</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure>

<h5 id="2-路由文件配置"><a href="#2-路由文件配置" class="headerlink" title="2.路由文件配置"></a>2.路由文件配置</h5><p>在vue项目中的src目录下，新建router文件夹，并创建一个index.js的文件。</p>
<p><img src="/blog/images/vue%E4%BD%BF%E7%94%A8%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%81%9A%E8%B7%AF%E7%94%B1%E9%89%B4%E6%9D%83/1533804813.jpg" alt="1533804813"></p>
<h5 id="3-vue-router文件编写"><a href="#3-vue-router文件编写" class="headerlink" title="3.vue-router文件编写"></a>3.vue-router文件编写</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span> <span class="comment">// 导入vue</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span> <span class="comment">// 导入vue-router</span></span><br><span class="line"><span class="keyword">import</span> Menu1 <span class="keyword">from</span> <span class="string">'@/components/menu1'</span> <span class="comment">// 导入一个组建</span></span><br><span class="line"><span class="keyword">import</span> Menu2 <span class="keyword">from</span> <span class="string">'@/components/menu2'</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">'@/components/login'</span></span><br><span class="line"><span class="keyword">import</span> UpdateUserInfo <span class="keyword">from</span> <span class="string">'@/components/updateUserInfo'</span></span><br><span class="line">Vue.use(VueRouter) <span class="comment">// 使用vue-router</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    <span class="comment">// 设置起始页面重定向</span></span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/'</span>,</span><br><span class="line">      redirect: <span class="string">'/Menu1'</span>,</span><br><span class="line">      name: <span class="string">'主页'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/Menu1'</span>,</span><br><span class="line">      name: <span class="string">'Menu1'</span>,</span><br><span class="line">      component: Menu1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/Menu2'</span>,</span><br><span class="line">      name: <span class="string">'Menu2'</span>,</span><br><span class="line">      component: Menu2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/Login'</span>,</span><br><span class="line">      name: <span class="string">'Login'</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">'/UpdateUserInfo'</span>,</span><br><span class="line">      name: <span class="string">'UpdateUserInfo'</span>,</span><br><span class="line">      component: UpdateUserInfo,</span><br><span class="line">      meta: &#123;</span><br><span class="line">        requireAuth: <span class="literal">true</span> <span class="comment">// 路由鉴权</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="4-登录功能"><a href="#4-登录功能" class="headerlink" title="4.登录功能"></a>4.登录功能</h5><p>我在这里请求的时候跟后端代码并非同源，所以涉及到了跨域的问题，正常情况下，想做路由鉴权测试可以直接将登陆的用户名和密码写死。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">	&lt;div&gt;</span><br><span class="line">        &lt;label&gt;账号&lt;&#x2F;label&gt;</span><br><span class="line">        &lt;Input v-model&#x3D;&quot;userInfo.userName&quot;&#x2F;&gt;</span><br><span class="line">        &lt;label&gt;密码&lt;&#x2F;label&gt;</span><br><span class="line">        &lt;Input v-model&#x3D;&quot;userInfo.password&quot;&#x2F;&gt;</span><br><span class="line">        &lt;label&gt;验证码&lt;&#x2F;label&gt;</span><br><span class="line">        &lt;Input v-model&#x3D;&quot;userInfo.code&quot;&#x2F;&gt;</span><br><span class="line">        &lt;Button type&#x3D;&quot;primary&quot; @click&#x3D;&quot;doLogin&quot;&gt;登 录&lt;&#x2F;Button&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;</span><br><span class="line">        name: &#39;login&#39;,</span><br><span class="line">        data () &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                userInfo: &#123;</span><br><span class="line">                    userName: &#39;&#39;,</span><br><span class="line">                    password: &#39;&#39;,</span><br><span class="line">                    code: &#39;&#39;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            doLogin () &#123;</span><br><span class="line">      if (this.userInfo.userName &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123;</span><br><span class="line">        alert(&#39;用户名不能为空&#39;)</span><br><span class="line">        return false</span><br><span class="line">      &#125;</span><br><span class="line">      if (this.userInfo.password &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123;</span><br><span class="line">        alert(&#39;密码不能为空&#39;)</span><br><span class="line">        return false</span><br><span class="line">      &#125;</span><br><span class="line">      if (this.userInfo.code &#x3D;&#x3D;&#x3D; &#39;&#39;) &#123;</span><br><span class="line">        alert(&#39;验证码不能为空&#39;)</span><br><span class="line">        return false</span><br><span class="line">      &#125;</span><br><span class="line">      fetch(&#96;&#x2F;api&#x2F;user&#x2F;login?mobile&#x3D;$&#123;this.userInfo.userName&#125;&amp;password&#x3D;$&#123;this.userInfo.password&#125;&amp;code&#x3D;$&#123;this.userInfo.code&#125;&#96;, &#123;</span><br><span class="line">                  method: &#39;get&#39;,</span><br><span class="line">                  &#x2F;&#x2F; 允许跨域cookies</span><br><span class="line">                  credentials: &#39;include&#39;</span><br><span class="line">              &#125;)</span><br><span class="line">              .then(function (res) &#123;</span><br><span class="line">                  if (res.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">                      res.json().then(data &#x3D;&gt; &#123;</span><br><span class="line">                          window.localStorage.setItem(&#39;hhh&#39;, data.userInfo.mobile)</span><br><span class="line">                          sessionStorage.setItem(&#39;hhh&#39;, data.userInfo.mobile)</span><br><span class="line">                      &#125;)</span><br><span class="line">                  &#125; else &#123;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">              this.$store.commit(&#39;setLogin&#39;, this.userInfo) &#x2F;&#x2F; 提交store，在使用路由鉴权时候可以省略</span><br><span class="line">              this.$router.push(&#39;&#x2F;&#39;) &#x2F;&#x2F; 路由跳转</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h5 id="5-main-js文件编写钩子函数"><a href="#5-main-js文件编写钩子函数" class="headerlink" title="5.main.js文件编写钩子函数"></a>5.main.js文件编写钩子函数</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span> <span class="comment">// 引入我们的vue-router文件</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router, <span class="comment">// 全局配置router</span></span><br><span class="line">  store,</span><br><span class="line">  components: &#123;App&#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登录路由鉴权</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 判断要去的路由界面是不是要鉴权</span></span><br><span class="line">  <span class="keyword">if</span> (to.matched.some(<span class="function"><span class="params">res</span> =&gt;</span> res.meta.requireAuth)) &#123; <span class="comment">// 指向路由配置中的requireAuth: true</span></span><br><span class="line">  <span class="comment">// 查看是否登陆</span></span><br><span class="line">    <span class="keyword">let</span> user = sessionStorage.getItem(<span class="string">'hhh'</span>)</span><br><span class="line">    <span class="keyword">if</span> (user === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 没登录的做处理</span></span><br><span class="line">      alert(<span class="string">'请先登录'</span>)</span><br><span class="line">      next(&#123;</span><br><span class="line">        path: <span class="string">'/Login'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 登陆的正常跳</span></span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不需要鉴权的正常跳</span></span><br><span class="line">    next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="6-效果展示"><a href="#6-效果展示" class="headerlink" title="6.效果展示"></a>6.效果展示</h5><p><img src="/blog/images/vue%E4%BD%BF%E7%94%A8%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E5%81%9A%E8%B7%AF%E7%94%B1%E9%89%B4%E6%9D%83/666.gif" alt="666"></p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-router</tag>
        <tag>钩子函数</tag>
      </tags>
  </entry>
  <entry>
    <title>vue动态绑定src错误</title>
    <url>/blog/2018/12/11/vue%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9Asrc%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h4 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h4><p>​    很多时候我们要对图片进行动态的绑定，例如在循环的时候增加<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">:src</code>，但是这样会造成一个问题，就是编译虽然不报错，但是我们在网页中并不能看到我们的图片，不过我们在浏览器里打开控制台的时候发现图片的路径是正确无误的。</p>
<p><img src="/blog/images/vue%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9Asrc%E9%94%99%E8%AF%AF/20181211173152.png" alt="找不到图片展示图"></p>
<h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>​    这时候就有很多人好奇为什么出现这个情况，在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">webpack</code>中会将图片当作模块来用，因为我们图片是动态加载的，所以<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">url-loader</code>将无法进行图片的解析，然后在我们运行项目的时候会导致图片路径没有被加工，只是显示到了文档的结构中。</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>​    将图片作为模块方式加载进去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    images: require(&#39;.&#x2F;imagename.jpc&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="拓展介绍"><a href="#拓展介绍" class="headerlink" title="拓展介绍"></a>拓展介绍</h4><h5 id="assets"><a href="#assets" class="headerlink" title="assets"></a>assets</h5><p>在项目编译的过程中会被<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">webpack</code>处理解析为模块依赖，只支持相对路径的形式。</p>
<h5 id="static"><a href="#static" class="headerlink" title="static"></a>static</h5><p>在这个目录下文件不会被<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">webpack</code>处理,简单就是说存放第三方文件的地方，不会被<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">webpack</code>解析。他会直接被复制到最终的打包目录（默认是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">dist/static</code>）下。必须使用绝对路径引用这些文件。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
        <tag>assets和static</tag>
      </tags>
  </entry>
  <entry>
    <title>vue生命周期钩子</title>
    <url>/blog/2018/08/30/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/</url>
    <content><![CDATA[<p>关于生命周期钩子对于一些想深入了解vue内部工作原理的人是很重要的。</p>
<h4 id="1-什么是vue生命周期"><a href="#1-什么是vue生命周期" class="headerlink" title="1. 什么是vue生命周期"></a>1. 什么是vue生命周期</h4><p>vue生命周期就是vue实例从创建到销毁的一个过程，我们一般把这个过程叫做生命周期。详细的来讲就是从<span style="color: red;"> 开始创建，初始化数据，编译模板，挂在dom，渲染，更新，渲染，卸载 </span>的一系列过程。</p>
<p>下面的图片是vue官网对生命周期钩子各个阶段的图解，我在上面写了一些注释以帮助理解。</p>
<p><img src="/blog/images/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/lifecycle.png" alt="lifecycle"></p>
<h4 id="2-钩子函数代码"><a href="#2-钩子函数代码" class="headerlink" title="2. 钩子函数代码"></a>2. 钩子函数代码</h4><p>通过代码，我们把所有的钩子都罗列出来，然后通过浏览器的console进行查看。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;app1&quot;&gt;&#123;&#123;message&#125;&#125;</span><br><span class="line">    &lt;button @click&#x3D;&quot;clickme&quot;&gt;点我更新数据&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &#39;#app1&#39;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      message: &#39;生命周期案例&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeCreate () &#123;</span><br><span class="line">    console.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;创建前&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line">    console.log(&#39;message:&#39; + this.message)</span><br><span class="line">    console.log(this.$el)</span><br><span class="line">  &#125;,</span><br><span class="line">  created () &#123;</span><br><span class="line">    console.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;已创建&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line">    console.log(&#39;message:&#39; + this.message)</span><br><span class="line">    console.log(this.$el)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeMount () &#123;</span><br><span class="line">    console.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;mount之前&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line">    console.log(&#39;message:&#39; + this.message)</span><br><span class="line">    console.log(this.$el)</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    console.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;mount&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line">    console.log(&#39;message:&#39; + this.message)</span><br><span class="line">    console.log(this.$el)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeUpdate () &#123;</span><br><span class="line">    console.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;更新前&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line">    console.log(&#39;message:&#39; + this.message)</span><br><span class="line">    console.log(this.$el)</span><br><span class="line">  &#125;,</span><br><span class="line">  updated () &#123;</span><br><span class="line">    console.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;更新完成&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line">    console.log(&#39;message:&#39; + this.message)</span><br><span class="line">    console.log(this.$el)</span><br><span class="line">  &#125;,</span><br><span class="line">  beforeDestroy () &#123;</span><br><span class="line">    console.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;销毁前&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line">    console.log(&#39;message:&#39; + this.message)</span><br><span class="line">    console.log(this.$el)</span><br><span class="line">  &#125;,</span><br><span class="line">  destroyed () &#123;</span><br><span class="line">    console.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;销毁后&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#39;)</span><br><span class="line">    console.log(&#39;message:&#39; + this.message)</span><br><span class="line">    console.log(this.$el)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    clickme () &#123;</span><br><span class="line">      this.message &#x3D; &#39;数据已更新&#39;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><br>下图为浏览器中看到的效果</p>
<br>

<p><img src="/blog/images/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/1535610503.jpg" alt="1535610503"></p>
<h4 id="3-各个钩子函数的作用"><a href="#3-各个钩子函数的作用" class="headerlink" title="3. 各个钩子函数的作用"></a>3. 各个钩子函数的作用</h4><h5 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h5><p>vue实例的挂载元素$el和数据对象data都为undefined，还处在没有被初始化的阶段。</p>
<h5 id="created"><a href="#created" class="headerlink" title="created"></a>created</h5><p>vue实例的数据对象data有了，但是$el还没有。</p>
<h5 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h5><p>vue实例的$el和data都已经被初始化了，但还是挂载之前的虚拟dom节点，同时数据也并没有被渲染到dom中。</p>
<h5 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h5><p>vue实例挂载完成，数据也渲染完成</p>
<h5 id="update部分"><a href="#update部分" class="headerlink" title="update部分"></a>update部分</h5><p>点击更新数据按钮后，查看控制台和页面</p>
<p><img src="/blog/images/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90/1535610580.jpg" alt="1535610580"></p>
<p><span style="color: red;">beforeUpdate中data并没有发生变化</span></p>
<p><span style="color: red;">updated中data已经变化</span></p>
<h5 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h5><p>销毁前所有的实例都是可用状态</p>
<h5 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h5><p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>钩子函数</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>vue预渲染，seo优化，nginx部署</title>
    <url>/blog/2018/09/03/vue%E9%A2%84%E6%B8%B2%E6%9F%93%EF%BC%8Cseo%E4%BC%98%E5%8C%96%EF%BC%8Cnginx%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<p>由于seo的优化对于单页面应用的vue来说优势不大，所以需要找到一个能够解决vue单页面应用问题的解决方案。大体上会有两种解决方式，一种是预渲染，一种是ssr服务端渲染。为此特意尝试了基于ssr的nuxt，但是效果并不是很好，所以打算使用预渲染的方式解决这个问题。</p>
<h5 id="1-插件安装"><a href="#1-插件安装" class="headerlink" title="1. 插件安装"></a>1. 插件安装</h5><pre><code>首先我们要安装两个插件，分别是prerender-spa-plugin和vue-meta-info，安装方式通过npm，cnpm，yarn等。我在这里使用的是cnpm。</code></pre><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install -D prerender-spa-plugin</span><br><span class="line">cnpm install vue-meta-info</span><br></pre></td></tr></table></figure>

<p><span style="color: red;">扩展：</span>npm中的-D表示–save-dev，被写入到 devDependencies 对象里面去，如果不加-D表示–save，被写入到 dependencies 对象里面去。devDependencies  里面的插件只用于开发环境，不用于生产环境，而 dependencies  是需要发布到生产环境的。</p>
<h5 id="2-编写webpack-prod-conf-js文件"><a href="#2-编写webpack-prod-conf-js文件" class="headerlink" title="2. 编写webpack.prod.conf.js文件"></a>2. 编写webpack.prod.conf.js文件</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 引入文件</span></span><br><span class="line"><span class="keyword">const</span> PrerenderSpaPlugin = <span class="built_in">require</span>(<span class="string">'prerender-spa-plugin'</span>)</span><br><span class="line"><span class="keyword">const</span> Renderer = PrerenderSpaPlugin.PuppeteerRenderer</span><br><span class="line"><span class="keyword">const</span> webpackConfig = merge(baseWebpackConfig, &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> CopyWebpackPlugin([</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">from</span>: path.resolve(__dirname, <span class="string">'../static'</span>),</span><br><span class="line">        to: config.build.assetsSubDirectory,</span><br><span class="line">        ignore: [<span class="string">'.*'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]),</span><br><span class="line">    <span class="keyword">new</span> PrerenderSpaPlugin(&#123;</span><br><span class="line">      <span class="comment">// 生成文件的路径，也可以与webpakc打包的一致。</span></span><br><span class="line">      <span class="comment">// 下面这句话非常重要！！！</span></span><br><span class="line">      <span class="comment">// 这个目录只能有一级，如果目录层次大于一级，在生成的时候不会有任何错误提示，在预渲染的时候只会卡着不动。</span></span><br><span class="line">      staticDir: path.join(__dirname, <span class="string">'../dist'</span>),</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对应自己的路由文件，比如index有参数，就需要写成 /index/param1。</span></span><br><span class="line">      routes: [ <span class="string">'/page/PurchaseAgent'</span>,<span class="string">'/page/api/Yzapi'</span>,<span class="string">'/userAdmin/Personal/AccountManagement'</span>,<span class="string">'/userAdmin/Personal/MyOrder'</span>,<span class="string">'/userAdmin/Personal/MyMoney'</span>],</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这个很重要，如果没有配置这段，也不会进行预编译</span></span><br><span class="line">      renderer: <span class="keyword">new</span> Renderer(&#123;</span><br><span class="line">        inject: &#123;</span><br><span class="line">          foo: <span class="string">'bar'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        headless: <span class="literal">false</span>,</span><br><span class="line">        <span class="comment">// 在 main.js 中 document.dispatchEvent(new Event('render-event'))，两者的事件名称要对应上。</span></span><br><span class="line">        renderAfterDocumentEvent: <span class="string">'render-event'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="3-编写main-js文件"><a href="#3-编写main-js文件" class="headerlink" title="3. 编写main.js文件"></a>3. 编写main.js文件</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  components: &#123;App&#125;,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">  <span class="comment">/* 这句非常重要，否则预渲染将不会启动 */</span></span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">document</span>.dispatchEvent(<span class="keyword">new</span> Event(<span class="string">'render-event'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>到此，我们使用prerender-spa-plugin这个做预渲染已经完成。接下来，我们进行seo插件的安装和使用。</p>
<br>

<h5 id="4-配置vue-meta-info"><a href="#4-配置vue-meta-info" class="headerlink" title="4. 配置vue-meta-info"></a>4. 配置vue-meta-info</h5><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> MetaInfo <span class="keyword">from</span> <span class="string">'vue-meta-info'</span></span><br><span class="line">Vue.use(MetaInfo)</span><br></pre></td></tr></table></figure>

<h5 id="5-使用vue-meta-info"><a href="#5-使用vue-meta-info" class="headerlink" title="5. 使用vue-meta-info"></a>5. 使用vue-meta-info</h5><p>我们可以在对应的页面加入一下参数以使用该seo插件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">'purchaseAgent'</span>,</span><br><span class="line">  metaInfo: &#123;</span><br><span class="line">    title: <span class="string">'标签页标题'</span>,</span><br><span class="line">    meta: [</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'keywords'</span>,</span><br><span class="line">        content: <span class="string">'代理1,代理2,代理3'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        name: <span class="string">'description'</span>,</span><br><span class="line">        content: <span class="string">'这是一段网页的描述'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-编译项目"><a href="#6-编译项目" class="headerlink" title="6. 编译项目"></a>6. 编译项目</h5><p>在完成预渲染和seo优化后，我们进行项目的打包构建。打包后我们会在项目目录中多出一个dist的文件夹，这个文件夹里面的资源就是编译后的项目。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run build</span><br></pre></td></tr></table></figure>

<p>编译成功后，命令行提示信息如下图</p>
<p><img src="/blog/images/vue%E9%A2%84%E6%B8%B2%E6%9F%93%EF%BC%8Cseo%E4%BC%98%E5%8C%96%EF%BC%8Cnginx%E9%83%A8%E7%BD%B2/1535967882.jpg" alt="1535967882"></p>
<p>同时项目目录中会多出一个dist文件夹</p>
<p><img src="/blog/images/vue%E9%A2%84%E6%B8%B2%E6%9F%93%EF%BC%8Cseo%E4%BC%98%E5%8C%96%EF%BC%8Cnginx%E9%83%A8%E7%BD%B2/1535967943.jpg" alt="1535967943"></p>
<p>文件夹中的结构如下，其中page和userAdmin为我项目中的路由页面，static为静态的js，css等资源。</p>
<p><img src="/blog/images/vue%E9%A2%84%E6%B8%B2%E6%9F%93%EF%BC%8Cseo%E4%BC%98%E5%8C%96%EF%BC%8Cnginx%E9%83%A8%E7%BD%B2/1535967972.jpg" alt="1535967972"></p>
<p>之后我们随便打开个页面可以看到没有样式，但是我们的seo已经存在在页面中，并且页面在预选然后也不再是单页面的应用，我们通过查看网站源代码时候可以发现，我们的内容会有很多。</p>
<p><span style="color: red;">未使用预渲染的网站结构的图片</span></p>
<p><img src="1535968788.jpg" alt="1535968788"></p>
<p><span style="color: red;">使用预渲染的网站结构以及使用了seo的效果图片</span></p>
<p><img src="1535968376.jpg" alt="1535968376"></p>
<h5 id="7-nginx发布项目"><a href="#7-nginx发布项目" class="headerlink" title="7. nginx发布项目"></a>7. nginx发布项目</h5><p>由于我们没有使用服务器发布项目，导致一些静态资源无法加载，所以我们要想看到样式，需要弄一个nginx服务器。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 后台方法路径转发</span><br><span class="line">location /api/ &#123;</span><br><span class="line">	proxy_pass http://192.168.1.12:8080/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">    root   F:/project/vue/lll/x/dist;</span><br><span class="line">    index  index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置完成后启动nginx服务，通过localhost进行查看。</p>
<p><img src="1535968172.jpg" alt="1535968172"></p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>预渲染</tag>
        <tag>seo优化</tag>
        <tag>nginx部署</tag>
      </tags>
  </entry>
  <entry>
    <title>偏函数与柯里化</title>
    <url>/blog/2019/05/13/%E5%81%8F%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9F%AF%E9%87%8C%E5%8C%96/</url>
    <content><![CDATA[<p>这篇文章会深入讲解<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">JavaScript</code>中的偏函数和柯里化，这些知识在实际的业务开发中可能很少使用，但是如果想要深入了解框架实现原理或者阅读源码时候就要掌握这两个知识。偏函数和柯里化都是函数式编程的一种实现。</p>
<blockquote>
<p>[1] 如果你在阅读中发现错误或者存在某些问题可以通过邮件的形式发送到作者的邮箱，再收到邮件后作者会及时处理这些问题。</p>
<p>[2] 阅读文章后你能了解到的有偏函数和柯里化是什么以及使用方式。</p>
</blockquote>
<hr>
<h4 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h4><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><p>所谓偏函数是指通过固定的一个函数或者一些固定的参数返回一个用于接收不固定参数的函数。</p>
<h5 id="例1"><a href="#例1" class="headerlink" title="例1:"></a>例1:</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">1</span>)) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>)) <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">3</span>)) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">4</span>)) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">5</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>通过上面的代码我们能够找到一个规律，add方法每次都传入了一个相同的参数，在参数比较多的情况下这种机械式的重复会十分繁琐。</p>
<h5 id="例2"><a href="#例2" class="headerlink" title="例2:"></a>例2:</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c + d + e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure>

<p>可以看到一旦我们有一个包装后的方法，它的前三个参数是固定参数，这样写就是机械式的重复，为此我们要用一种方法去解决这个问题。</p>
<h5 id="例3"><a href="#例3" class="headerlink" title="例3:"></a>例3:</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 入参函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产偏函数的工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partial</span>(<span class="params">fn, a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn(a, b, c)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> parAdd = partial(add, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(parAdd(<span class="number">1</span>)) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(parAdd(<span class="number">2</span>)) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(parAdd(<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(parAdd(<span class="number">4</span>)) <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(parAdd(<span class="number">5</span>)) <span class="comment">// 8</span></span><br></pre></td></tr></table></figure>

<p>我们通过偏函数的形式，减少了每次传参量。</p>
<h5 id="偏函数与bind联用"><a href="#偏函数与bind联用" class="headerlink" title="偏函数与bind联用"></a>偏函数与<a color="blue" href="http://www.songjian.site/2019/05/13/this%E3%80%81apply%E3%80%81call%E3%80%81bind/#more" target="_blank" rel="noopener">bind</a>联用</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.parAdd = add.bind(obj, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.parAdd(<span class="number">1</span>)) <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.parAdd(<span class="number">2</span>)) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.parAdd(<span class="number">3</span>)) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<p>我们可以在封装函数时候对固定传入参数使用偏函数形式，减少传参量。</p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>减少重复的参数传递。</p>
<hr>
<h4 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h4><h5 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h5><p>柯里化是将一元参数函数转换为多元参数函数，可以理解为fn(a, b)转换为fn(a)(b)。</p>
<h5 id="例1-1"><a href="#例1-1" class="headerlink" title="例1:"></a>例1:</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包装器函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> func(a, b, c)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> carriedSum = curry(add)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(carriedSum(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)) <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(carriedSum(<span class="number">2</span>)(<span class="number">3</span>)(<span class="number">4</span>)) <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">console</span>.log(carriedSum(<span class="number">3</span>)(<span class="number">4</span>)(<span class="number">5</span>)) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>



<h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><p>将传入参数拆分成最小单元，并且可以对每个单元进行任何操作。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>偏函数</tag>
        <tag>柯里化</tag>
      </tags>
  </entry>
  <entry>
    <title>深入解读vue源码（一）目录设计</title>
    <url>/blog/2019/05/14/%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBvue%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%80%EF%BC%89%E7%9B%AE%E5%BD%95%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>此篇文章作为该专题的开篇，将会把<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>的目录结构及作用进行简单的介绍，<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>项目的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">github</code>地址在<a color="blue" href="https://github.com/vuejs/vue" target="_blank" rel="noopener">vue</a>。</p>
<p>我们主要去介绍<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src</code>下面的目录结构，因为<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src</code>是源码的目录。</p>
<hr>
<h4 id="src"><a href="#src" class="headerlink" title="src"></a>src</h4><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src</code>目录是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>的源码目录，该目录下包含：</p>
<h5 id="compiler（编译相关）"><a href="#compiler（编译相关）" class="headerlink" title="compiler（编译相关）"></a>compiler（编译相关）</h5><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">compiler</code>包含<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>所有编译相关的代码。包括将模版解析成<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">ast</code>语法树，以及对语法树的优化，代码自动生成等。</p>
<p>编译工作可以借助<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">webpack</code>、<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue-loader</code>等工具。</p>
<p>codegen —— 用ast去生成render函数</p>
<p>directives —— 生成render函数之前需要处理的指令</p>
<p>parser —— 模板解析</p>
<h5 id="core（核心业务代码）"><a href="#core（核心业务代码）" class="headerlink" title="core（核心业务代码）"></a>core（核心业务代码）</h5><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">core</code>目录包含<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>的核心代码，如内置组件、API、实例化、虚拟DOM、工具类函数等。</p>
<p>components —— 全局的组件，这里只有keep-alive</p>
<p>global-api —— 全局方法，也就是添加在Vue对象上的方法，比如Vue.use、Vue.extend、Vue.mixin等</p>
<p>instance —— 实例方法、生命周期、事件等</p>
<p>observer —— 双向数据绑定</p>
<p>util —— 工具</p>
<p>vdom —— 虚拟化DOM</p>
<h5 id="platforms（终端支持）"><a href="#platforms（终端支持）" class="headerlink" title="platforms（终端支持）"></a>platforms（终端支持）</h5><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>是一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">mvvm</code>框架，能够运行在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">web</code>上，也可以配合<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">weex</code>运行在客户端上。</p>
<p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">platforms</code>是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>程序的入口，<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">platforms</code>具有两个入口，分别运行在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">web</code>上和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">weex</code>上。</p>
<p>compiler —— 编译阶段需要处理的指令和模块</p>
<p>runtime —— 运行阶段需要处理的指令和模块</p>
<p>server —— 服务端渲染</p>
<p>util —— 工具</p>
<h5 id="server（服务端渲染）"><a href="#server（服务端渲染）" class="headerlink" title="server（服务端渲染）"></a>server（服务端渲染）</h5><p>从2.0版本开始，<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>支持服务端的渲染方式，<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">server</code>目录下包含所有与服务端渲染相关的逻辑。</p>
<p>注：</p>
<ul>
<li>这部分代码是运行在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">node</code>上的代码，不要和运行在浏览器的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>混淆</li>
<li>服务端渲染是指服务器把组件以<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">html</code>字符串的形式发送到客户端</li>
</ul>
<h5 id="sfc（对vue文件的支持与解析）"><a href="#sfc（对vue文件的支持与解析）" class="headerlink" title="sfc（对vue文件的支持与解析）"></a>sfc（对vue文件的支持与解析）</h5><p>通常我们开发项目都是通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">webpack</code>进行打包处理，通过编写<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>文件实现功能。<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">sfc</code>目录下的代码能够去把<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>文件解析成<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">JavaScript</code>对象。</p>
<h5 id="shared（共享代码）"><a href="#shared（共享代码）" class="headerlink" title="shared（共享代码）"></a>shared（共享代码）</h5><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>会定义一些方法，这些方法是会被客户端和服务端所共享的。</p>
<hr>
<h4 id="dist"><a href="#dist" class="headerlink" title="dist"></a>dist</h4><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>项目打包后的文件存储区。</p>
<hr>
<h4 id="benchmarks"><a href="#benchmarks" class="headerlink" title="benchmarks"></a>benchmarks</h4><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">benchmarks</code>的目的主要有两种，一是验证性能，另一个是获得一些基准数据，从而可以与本软件的其他版本或其他同类软件进行比较，通常不使用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">benchmarks</code>做正确性验证。</p>
<hr>
<h4 id="flow"><a href="#flow" class="headerlink" title="flow"></a>flow</h4><p>静态类型检查工具，此目录会规定一些参数和方法的类型。</p>
<p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>本身使用了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">flow</code>来进行静态类型检查。</p>
<hr>
<h4 id="examples"><a href="#examples" class="headerlink" title="examples"></a>examples</h4><p>存放一些使用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>开发的应用案例。</p>
<hr>
<h4 id="packages"><a href="#packages" class="headerlink" title="packages"></a>packages</h4><p>生成其他<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">npm</code>包。</p>
<hr>
<h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>测试用例。</p>
<hr>
<h4 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h4><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Rollup</code>构建时相关的配置文件。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入解读vue源码（三）runtime-compiler入口</title>
    <url>/blog/2019/05/16/%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBvue%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%89%EF%BC%89runtime-compiler%E5%85%A5%E5%8F%A3/</url>
    <content><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>上篇文章较为全面的介绍了整个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>源码在执行<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">build</code>过程中的构建过程，在文章的最后还介绍了两种不同的构建方式，分别是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">runtime only</code>和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">runtime compiler</code>。</p>
<p>值得注意的是这两种构建方式都是基于<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">web</code>环境参数下的构建方式，<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">weex</code>并不在这个范围内。</p>
<p>本篇文章我们会对<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">runtime compiler</code>这种构建方式的入口进行分析，之所以选择这种构建方式介绍是因为<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">runtime compiler</code>相对于<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">runtime only</code>来说多了个编译器的功能，在这篇文章中都会一并介绍。</p>
<p>简单来说<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>就是一个方法类，在这个方法中挂载了一些<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>自带的方法等。</p>
<hr>
<h4 id="程序入口解析"><a href="#程序入口解析" class="headerlink" title="程序入口解析"></a>程序入口解析</h4><h5 id="entry-runtime-with-compiler分析"><a href="#entry-runtime-with-compiler分析" class="headerlink" title="entry-runtime-with-compiler分析"></a>entry-runtime-with-compiler分析</h5><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">entry-runtime-with-compiler</code>文件是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">runtime compiler</code>构建方式下的入口文件，该文件路径在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/platforms/web/</code>下。</p>
<p>下面的代码是从<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">entry-runtime-with-compiler</code>中抽象出来的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">mount</code>方法。这种能够表达代码结果和逻辑的代码我们称之为伪代码。伪代码并不能通过编译器的检查，更不能运行。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params">el?: string | Element, hydrating?: boolean</span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">	......</span><br><span class="line">  <span class="keyword">const</span> options = <span class="keyword">this</span>.$options <span class="comment">// new Vue(options)提供的实参options</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123; <span class="comment">// 使用实例化Vue时提供render函数，不是render函数的情况下进入</span></span><br><span class="line">    <span class="keyword">if</span> (template) &#123; <span class="comment">// 如果没有提供render函数，则优先使用提供的template选项</span></span><br><span class="line">      ......</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123; <span class="comment">// 既没有提供render函数，又没有template选项，就使用el选项</span></span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的这段伪代码用于将<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>中的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">html</code>模板编译成<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>函数，并且把<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">$mount</code>方法定义在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">prototype</code>上，使得每一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">new</code>出来的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>实例都能使用此方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOuterHTML</span> (<span class="params">el: Element</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (el.outerHTML) &#123;</span><br><span class="line">    <span class="keyword">return</span> el.outerHTML</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    container.appendChild(el.cloneNode(<span class="literal">true</span>))</span><br><span class="line">    <span class="keyword">return</span> container.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码主要是得到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">html</code>代码片段，它能够处理以下四种写法。</p>
<p>下面的这段代码，就是我们在使用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>时候在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">main.js</code>最下面<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">new</code>的一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>实例。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;<span class="attr">el</span>: <span class="string">'#index'</span>&#125;</span><br><span class="line">&#123;<span class="attr">el</span>: <span class="built_in">document</span>.querySelector(<span class="string">'#index'</span>)&#125;</span><br><span class="line">&#123;<span class="attr">template</span>: <span class="string">'#index'</span>&#125;</span><br><span class="line">&#123;<span class="attr">template</span>: <span class="string">'&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;'</span>&#125;</span><br></pre></td></tr></table></figure>

<p>到这里基本讲解了下<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">entry-runtime-with-compiler</code>这个文件，我们通过引入的方式找到入口的核心。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src/platforms/web/entry-runtime-with-compiler.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./runtime/index'</span></span><br><span class="line"><span class="comment">// src/platforms/web/runtime/index.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'core/index'</span></span><br></pre></td></tr></table></figure>

<p>在这个文件中还有一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">compileToFunctions</code>方法，这个方法是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">mount</code>方法内调用，通过编译器将<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">html</code>转换为<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>函数的方法，在此就先不在赘述。</p>
<h5 id="src-core-index分析"><a href="#src-core-index分析" class="headerlink" title="src/core/index分析"></a>src/core/index分析</h5><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">core/index.js</code>是核心代码的入口。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'./instance/index'</span></span><br><span class="line"><span class="keyword">import</span> &#123; initGlobalAPI &#125; <span class="keyword">from</span> <span class="string">'./global-api/index'</span> <span class="comment">// 全局api</span></span><br><span class="line"><span class="keyword">import</span> &#123; isServerRendering &#125; <span class="keyword">from</span> <span class="string">'core/util/env'</span> <span class="comment">// 布尔类型变量，判断是否是ssr</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">initGlobalAPI(Vue) <span class="comment">// 开始执行初始化全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为vue原型定义$isServer方法</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Vue.prototype, <span class="string">'$isServer'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: isServerRendering</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 为vue原型定义$isServer方法</span><br><span class="line">Object.defineProperty(Vue.prototype, '$ssrContext', &#123;</span><br><span class="line">  <span class="keyword">get</span> () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.$vnode &amp;&amp; <span class="keyword">this</span>.$vnode.ssrContext</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">Vue.version = <span class="string">'__VERSION__'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure>

<h5 id="src-core-instance-index分析"><a href="#src-core-instance-index分析" class="headerlink" title="src/core/instance/index分析"></a>src/core/instance/index分析</h5><p>该文件定义了一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>的类，然后又调用了一系列<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">init</code>、<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">mixin</code>这样的方法来初始化一些功能，具体的在之后的文章中我们再进行深入的分析。</p>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这篇文章简单的介绍了下<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>的入口，后续的文章会对每一部分进行详细的介绍。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入解读vue源码（二）构建过程</title>
    <url>/blog/2019/05/14/%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBvue%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%8C%EF%BC%89%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>通过上篇文章<a color="blue" href="http://www.songjian.site/2019/05/14/%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBvue%E6%BA%90%E7%A0%81%E4%B9%8B%E7%9B%AE%E5%BD%95%E8%AE%BE%E8%AE%A1/" target="_blank" rel="noopener">《深入解读vue源码（一）目录设计》</a>了解到了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>的目录设计后，这篇文章要对<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>的构建过程进行一些详细的介绍。</p>
<p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>的构建过程是在根目录下的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">scripts</code>目录中通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Rollup</code>编译<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">build.js</code>文件。</p>
<hr>
<h4 id="构建脚本"><a href="#构建脚本" class="headerlink" title="构建脚本"></a>构建脚本</h4><p>通常一个基于<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">node</code>的项目在根目录下都会有一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">package.json</code>的文件，它是对项目的一个描述文件，描述的内容可以是包版本、启动脚本、项目名等等，它的内容是一个标准的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">JSON</code>对象。</p>
<p>我们主要从<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">build</code>模式下分析项目的构建过程（打包编译到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">dist</code>目录），在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">package.json</code>中我们能看到这样一段代码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "build": "node scripts/build.js",</span><br><span class="line">  "build:ssr": "npm run build -- web-runtime-cjs,web-server-renderer",</span><br><span class="line">  "build:weex": "npm run build -- weex"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码作用于构建<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>应用程序，其中<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">ssr</code>和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">weex</code>是对第一条的环境拓展参数，当执行<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">npm run build</code>的时候实际执行的就是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">node scripts/build.js</code>。</p>
<p>对于有环境拓展参数的命令来讲，会将命令中的参数（ – 符号后面的参数）传入<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">process.argv</code>数组中。</p>
<hr>
<h4 id="解读构建过程"><a href="#解读构建过程" class="headerlink" title="解读构建过程"></a>解读构建过程</h4><h5 id="scripts-build-js分析"><a href="#scripts-build-js分析" class="headerlink" title="scripts/build.js分析"></a>scripts/build.js分析</h5><p>我们知道了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">build</code>过程实际是去读取这个文件，打开这个文件我们开始一段段分析：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!fs.existsSync(<span class="string">'dist'</span>)) &#123;</span><br><span class="line">  fs.mkdirSync(<span class="string">'dist'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是在判断项目的根目录下是否存在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">dist</code>目录，不存在则创建。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> builds = <span class="built_in">require</span>(<span class="string">'./config'</span>).getAllBuilds()</span><br></pre></td></tr></table></figure>

<p>这里通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">builds</code>变量保存一个在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">scripts/config.js</code>中返回的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/platforms</code>路径下所有<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">JavaScript</code>文件的数组对象，该对象包括支持<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">ssr</code>、客户端渲染和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">weex</code>的文件名和文件路径等信息。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.argv[<span class="number">2</span>]) &#123; <span class="comment">// 判断是否是ssr或者weex</span></span><br><span class="line">  <span class="keyword">const</span> filters = process.argv[<span class="number">2</span>].split(<span class="string">','</span>) <span class="comment">// 将数组中的第三条数据以逗号分隔形式保存到数组</span></span><br><span class="line">  builds = builds.filter(<span class="function"><span class="params">b</span> =&gt;</span> &#123; <span class="comment">// 遍历builds对象</span></span><br><span class="line">    <span class="comment">// 对filters的每一项与builds对象中的文件名或者文件路径进行筛选，当b中包含f时返回true</span></span><br><span class="line">    <span class="keyword">return</span> filters.some(<span class="function"><span class="params">f</span> =&gt;</span> b.output.file.indexOf(f) &gt; <span class="number">-1</span> || b._name.indexOf(f) &gt; <span class="number">-1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// process.argv[2] = undefined，则不是ssr或者weex</span></span><br><span class="line">  builds = builds.filter(<span class="function"><span class="params">b</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 将b中不包含weex的数据设置为true</span></span><br><span class="line">    <span class="keyword">return</span> b.output.file.indexOf(<span class="string">'weex'</span>) === <span class="number">-1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码判断的是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">build</code>的编译类型，用类型去判断编译哪些文件，在这里通过判断<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">process.argv[2]</code>数组中是否存在第三条数据，存在第三条数据的情况下就是说明<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">build</code>的环境拓展参数是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">ssr</code>或者<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">weex</code>。</p>
<p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">process.argv[2]</code>的值在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">ssr</code>的环境下是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">'web-runtime-cjs,web-server-renderer'</code>，在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">weex</code>的环境下是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">'weex'</code>，在没有环境拓展参数的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">build</code>下为<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">build(builds) <span class="comment">// 将筛选后的builds对象传入build方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">build</span> (<span class="params">builds</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> built = <span class="number">0</span> </span><br><span class="line">  <span class="keyword">const</span> total = builds.length</span><br><span class="line">  <span class="keyword">const</span> next = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 定一个匿名函数，通过递归方式调用</span></span><br><span class="line">    buildEntry(builds[built]).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 调用buildEntry方法，返回一个promise对象</span></span><br><span class="line">      built++</span><br><span class="line">      <span class="keyword">if</span> (built &lt; total) &#123;</span><br><span class="line">        next()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;).catch(logError) <span class="comment">// 调用logError，打印输出错误信息</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next() <span class="comment">// 调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码主要功能是通过递归的方式不断的调用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">buildEntry</code>方法，该方法返回一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">promise</code>对象，之所以使用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">promise</code>对象的原因是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Rollup</code>本身接收和返回的是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">promise</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildEntry</span> (<span class="params">config</span>) </span>&#123; <span class="comment">// 接收builds数组中的一个对象</span></span><br><span class="line">  <span class="keyword">const</span> output = config.output <span class="comment">// 保存对象中的output的value</span></span><br><span class="line">  <span class="keyword">const</span> &#123; file, banner &#125; = output <span class="comment">// banner为scripts/config.js中定义的注释信息</span></span><br><span class="line">  <span class="keyword">const</span> isProd = <span class="regexp">/(min|prod)\.js$/</span>.test(file) <span class="comment">// 正则匹配为min和prod的输出文件名</span></span><br><span class="line">  <span class="keyword">return</span> rollup.rollup(config) <span class="comment">// 将对象传入rollup，交给rollup进行打包</span></span><br><span class="line">    .then(<span class="function"><span class="params">bundle</span> =&gt;</span> bundle.generate(output))</span><br><span class="line">    .then(<span class="function">(<span class="params">&#123; output: [&#123; code &#125;] &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isProd) &#123; <span class="comment">// 代码格式化形式</span></span><br><span class="line">        <span class="keyword">const</span> minified = (banner ? banner + <span class="string">'\n'</span> : <span class="string">''</span>) + terser.minify(code, &#123;</span><br><span class="line">          toplevel: <span class="literal">true</span>,</span><br><span class="line">          output: &#123;</span><br><span class="line">            ascii_only: <span class="literal">true</span></span><br><span class="line">          &#125;,</span><br><span class="line">          compress: &#123;</span><br><span class="line">            pure_funcs: [<span class="string">'makeMap'</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;).code</span><br><span class="line">        <span class="keyword">return</span> write(file, minified, <span class="literal">true</span>) <span class="comment">// 调用创建文件方法，创建文件方法再次不在赘述</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> write(file, code)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="scripts-config-js分析"><a href="#scripts-config-js分析" class="headerlink" title="scripts/config.js分析"></a>scripts/config.js分析</h5><p>在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">scripts/build.js</code>文件中我们调用了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">scripts/config.js</code>这个方法，并且把数据保存在了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">builds</code>的变量中，对于<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">scripts/config.js</code>文件的分析，会从<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">getAllBuilds</code>方法开始。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.TARGET) &#123; <span class="comment">// 判断是否有TARGET，只有在dev环境下才有TARGET</span></span><br><span class="line">  <span class="built_in">module</span>.exports = genConfig(process.env.TARGET)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  exports.getBuild = genConfig</span><br><span class="line">  <span class="comment">// 通过枚举的形式将builds中的key名取出来形成新的数组，并对数组的每一项进行循环调用genConfig方法</span></span><br><span class="line">  exports.getAllBuilds = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">Object</span>.keys(builds).map(genConfig) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码通过判断启动参数来区分是否是编译环境，如果是编译环境的情况下，则把<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">getAllBuilds</code>映射出去。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> builds = &#123;</span><br><span class="line">  <span class="string">'web-runtime-cjs-dev'</span>: &#123;</span><br><span class="line">    entry: resolve(<span class="string">'web/entry-runtime.js'</span>), <span class="comment">// 入口文件</span></span><br><span class="line">    dest: resolve(<span class="string">'dist/vue.runtime.common.dev.js'</span>), <span class="comment">// 编译后的文件</span></span><br><span class="line">    format: <span class="string">'cjs'</span>, <span class="comment">// 编译文件的格式</span></span><br><span class="line">    env: <span class="string">'development'</span>, <span class="comment">// 指定环境</span></span><br><span class="line">    banner <span class="comment">// 注释</span></span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">builds</code>的基本结构，<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Object.keys(builds)</code>获取到的值是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">['web-runtime-cjs-dev', ……]</code>这样的一个数组。之后对数据进行循环，去调用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">genConfig</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> banner =</span><br><span class="line">  <span class="string">'/*!\n'</span> +</span><br><span class="line">  <span class="string">` * Vue.js v<span class="subst">$&#123;version&#125;</span>\n`</span> +</span><br><span class="line">  <span class="string">` * (c) 2014-<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear()&#125;</span> Evan You\n`</span> +</span><br><span class="line">  <span class="string">' * Released under the MIT License.\n'</span> +</span><br><span class="line">  <span class="string">' */'</span></span><br></pre></td></tr></table></figure>

<p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">banner</code>是一个注释，在打包编译的时候将其传入对应文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> base = p.split(<span class="string">'/'</span>)[<span class="number">0</span>] <span class="comment">// 对传入的路径进行截取形成新的数组，同时取得第一条数据，如weex、web、server等</span></span><br><span class="line">  <span class="keyword">if</span> (aliases[base]) &#123; <span class="comment">// 判断aliases[base]是否为undefined</span></span><br><span class="line">    <span class="comment">// 将aliases[base]目录和p路径从base.length + 1往后截取的字符串拼接成打包的entry入口的文件路径</span></span><br><span class="line">    <span class="keyword">return</span> path.resolve(aliases[base], p.slice(base.length + <span class="number">1</span>))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 为undefined的情况下将当前目录、返回上层目录和要输出的文件目录或者生成其它node包的目录传入path.resolve方法</span></span><br><span class="line">    <span class="keyword">return</span> path.resolve(__dirname, <span class="string">'../'</span>, p)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">resolve</code>这个方法已经对<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">builds</code>的结构进行了一系列的处理，并将新的结构返回给<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Object.keys(builds)</code>中。</p>
<p>其中<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">genConfig</code>方法作用是将处理好的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">builds</code>结构包装成符合<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Rollup</code>打包渲染的结构，在这里就不再赘述。</p>
<h5 id="scripts-alias-js分析"><a href="#scripts-alias-js分析" class="headerlink" title="scripts/alias.js分析"></a>scripts/alias.js分析</h5><p>此文件主要用于包装出一个执行不同环境的命令时对应的源码相对路径，并且把相对路径包装成绝对路径。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">p</span> =&gt;</span> path.resolve(__dirname, <span class="string">'../'</span>, p)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  vue: resolve(<span class="string">'src/platforms/web/entry-runtime-with-compiler'</span>),</span><br><span class="line">  compiler: resolve(<span class="string">'src/compiler'</span>),</span><br><span class="line">  core: resolve(<span class="string">'src/core'</span>),</span><br><span class="line">  shared: resolve(<span class="string">'src/shared'</span>),</span><br><span class="line">  web: resolve(<span class="string">'src/platforms/web'</span>),</span><br><span class="line">  weex: resolve(<span class="string">'src/platforms/weex'</span>),</span><br><span class="line">  server: resolve(<span class="string">'src/server'</span>),</span><br><span class="line">  sfc: resolve(<span class="string">'src/sfc'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="runtime-only-and-runtime-compiler"><a href="#runtime-only-and-runtime-compiler" class="headerlink" title="runtime only and runtime compiler"></a>runtime only and runtime compiler</h4><h5 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h5><p>说到构建过程，我们在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>官网能够看到两种构建方式，分别是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">runtime only</code>和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">runtime compiler</code>。这两种构建方式在使用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue-cli</code>创建一个项目的时候，会提供选择的操作，不过我们默认情况下推荐选择<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">runtime only</code>。</p>
<h5 id="二者区别"><a href="#二者区别" class="headerlink" title="二者区别"></a>二者区别</h5><ul>
<li><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">runtime only</code>代表构建过程是在运行的时候，这种构建模式删除了模板编译的功能，因此无法支持带<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">template</code>属性的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>实例。使用此构建方式需要借助<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue-loader</code>、<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">webpack</code>、<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vueify</code>等打包构建工具。</li>
<li><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">runtime compiler</code>代表构建过程在运行的时候添加了编译器的功能，有了编译器就能够解析带有<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">template</code>属性的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>实例。</li>
</ul>
<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runtime compiler</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  template: <span class="string">'&#123;&#123;hello world!&#125;&#125;'</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime only</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render(h) &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">'div'</span>, <span class="string">'hellow world!'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>到此一个完整的构建过程就已经介绍完了，构建过程主要就是在执行根目录下的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">scripts</code>目录中的文件。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入解读vue源码（五）挂载实例的实现</title>
    <url>/blog/2019/06/27/%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBvue%E6%BA%90%E7%A0%81%EF%BC%88%E4%BA%94%EF%BC%89%E6%8C%82%E8%BD%BD%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>中我们是通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">$mount</code>方法去实现<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm</code>的挂载，这个方法在源码中很多文件都有定义如：</p>
<ul>
<li>src/platform/web/entry-runtime-with-compiler.js</li>
<li>src/platform/web/runtime/index.js</li>
<li>src/platform/weex/runtime/index.js</li>
</ul>
<p>其实在前面的几片文章的介绍中我们可以看出来这些文件就是对不同平台、不同环境、不同的构建方式进行的区分，在这篇文章中会介绍带有<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">compiler</code>版本的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">$mount</code>方法的实现原理。</p>
<hr>
<h4 id="compiler版本-mount的实现"><a href="#compiler版本-mount的实现" class="headerlink" title="compiler版本$mount的实现"></a>compiler版本$mount的实现</h4><h5 id="简单回顾"><a href="#简单回顾" class="headerlink" title="简单回顾"></a>简单回顾</h5><p>首先我们先回顾下，在上篇文章中我们讲解了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">new Vue</code>的实现过程，在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/core/instance/index.js</code>文件下能看到这样的代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./init'</span></span><br><span class="line">...</span><br><span class="line">initMixin(Vue)</span><br></pre></td></tr></table></figure>

<p>通过点击能够查看到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">initMixin</code>方法，在这个方法中最底部有这样一段代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">  vm.$mount(vm.$options.el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">el</code>不为空的时候将其通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">$mount</code>方法挂载到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">dom</code>中。</p>
<h5 id="mount的实现"><a href="#mount的实现" class="headerlink" title="$mount的实现"></a>$mount的实现</h5><p>compiler版本$mount的实现在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/platform/web/entry-runtime-with-compiler.js</code>文件，打开这个文件我们一步步进行分析。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br></pre></td></tr></table></figure>

<p>这句话是将原型链上的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">$mount</code>方法缓存在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">mount</code>上。</p>
<p>接着我们深入去看看<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">$mount</code>这个方法是通过什么方式定义的，这个方法定义的路径在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/platforms/web/runtime/index.js</code>下，该文件中有这样一段代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: <span class="built_in">string</span> | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="keyword">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>回归正轨，我们继续分析这个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/platform/web/entry-runtime-with-compiler.js</code>文件。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  el?: <span class="built_in">string</span> | Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码重新定义了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">$mount</code>在原型链上的方法，这时候很多人会好奇，为什么会定义两遍。</p>
<p>其实<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/platform/web/entry-runtime-with-compiler.js</code>文件中的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">$mount</code>方法是一个重写复用的方法，这个方法只在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">compiler</code>版本中存在，在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">runtime-only</code>版本中并不存在。</p>
<p>在这里我们能够看到这个方法接收两个参数，一个参数是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">el</code>，它表示挂载的元素，可以是字符串类型，也可以是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">DOM</code>对象，第二个参数<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">hydrating</code>是和服务端渲染相关的，在客户端浏览器渲染的情况下我们可以忽略这个参数。</p>
<p>在这个方法内部，我们会看到一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">query</code>方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">el = el &amp;&amp; query(el)</span><br></pre></td></tr></table></figure>

<p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">query</code>方法是在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/platforms/web/util/index.js</code>这个文件中进行定义的，这个方法也是比较简单的，总的来说就是调用原生的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">document.querySelector</code>方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">query</span> (<span class="params">el: <span class="built_in">string</span> | Element</span>): <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> el === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> selected = <span class="built_in">document</span>.querySelector(el)</span><br><span class="line">    <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">'Cannot find element: '</span> + el</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> selected</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> el</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法通过判断传入的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">el</code>是否是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">string</code>类型，如果是的话将其转换成<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">dom</code>元素保存在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">selected</code>中，并且判断<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">selected</code>是否为空，为空则警告，不为空则<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">query</code>方法返回<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">selected</code>，当传入的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">el</code>是元素节点类型则直接返回。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">    <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续分析<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">$mount</code>方法，能够看到这样一段代码，这段代码的作用就是判断<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">el</code>的标签中有<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">body</code>和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">html</code>标签的情况下进行警告，这个警告的原因是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">mount</code>方法是通过覆盖的形式进行挂载的，所以不能直接挂载到这两个标签上，通常情况下我们的挂载都是通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">id</code>进行挂载的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续往下看代码，会看到对<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>的处理，通过判断是否有<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>这个函数，我们在使用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue-cli</code>创建一个项目的时候在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">main.js</code>文件中会看到这样的代码，这段代码中在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">new Vue</code>的过程中创建了一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>并且挂载到了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">#app</code>下。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123; <span class="keyword">return</span> h(App) &#125;</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>在判断<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>的内部又进行了对<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">template</code>的判断，值得注意的是，如果想使用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">template</code>就要使用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">compiler</code>版本。这<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>的内部有两个对<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">template</code>的判断，首先我们来分析第一个。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> template = options.template <span class="comment">// 拿到template定义的值</span></span><br><span class="line"><span class="keyword">if</span> (template) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">'string'</span>) &#123; <span class="comment">// 判断template为string类型</span></span><br><span class="line">    <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">'#'</span>) &#123; <span class="comment">// 判断template中的第一个字符为#号</span></span><br><span class="line">      template = idToTemplate(template)</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; !template) &#123; <span class="comment">// 判断template是否为空，为空的情况下提示找不到模板元素或模板元素为空</span></span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Template element not found or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">          <span class="keyword">this</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123; <span class="comment">// 判断template为节点类型</span></span><br><span class="line">    template = template.innerHTML</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123; <span class="comment">// 不是这string类型或节点类型的情况下提示无效的模板选项</span></span><br><span class="line">      warn(<span class="string">'invalid template option:'</span> + template, <span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">  template = getOuterHTML(el) <span class="comment">// template是字符串类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中包含了两个方法，分别是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">idToTemplate</code>和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">getOuterHTML</code>。在这里先简单介绍下<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">idToTemplate</code>方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> idToTemplate = cached(<span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> el = query(id)</span><br><span class="line">  <span class="keyword">return</span> el &amp;&amp; el.innerHTML</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这段代码将<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">template</code>传入到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">query</code>方法，在之前我们看到了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">query</code>方法中接收的两个参数类型，一个是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">string</code>，一个是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Element</code>，对于<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">idToTemplate</code>方法，就是将<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Element</code>类型传入<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">query</code>方法。</p>
<p>接下来我们继续看<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">getOuterHTML</code>这个方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOuterHTML</span> (<span class="params">el: Element</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (el.outerHTML) &#123;</span><br><span class="line">    <span class="keyword">return</span> el.outerHTML</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">    container.appendChild(el.cloneNode(<span class="literal">true</span>))</span><br><span class="line">    <span class="keyword">return</span> container.innerHTML</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是判断<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">el</code>中是否有后代元素并且是否只包含一个父级的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">DOM</code>节点，如果是直接返回，如果不是则在外层包一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">div</code>，使其只有一个父级节点。</p>
<p>在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>的内部对<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">template</code>的二个判断是跟编译相关的，在后面的章节中我们还会进行详细的介绍，在这里我们只需要知道<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">$mount</code>方法就是判断是否有<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>函数，有的话直接使用，没有的话通过编译<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">template</code>使其自动生成个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>函数，也可以理解为我们在使用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>进行任何业务功能的编写时，都是依赖<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>函数的挂载得以实现的。</p>
<p>在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">$mount</code>这个原型链方法的最后还有这样一段代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> mount.call(<span class="keyword">this</span>, el, hydrating)</span><br></pre></td></tr></table></figure>

<p>这段代码中的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">mount</code>方法是文件最开始写入缓存的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">$mount</code>方法，所以这段代码本质依旧是调用原型链上的方法，这个方法在文章的最开始已经介绍过了，是在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/platforms/web/runtime/index.js</code>下的方法。</p>
<p>在这个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">$mount</code>方法内，能看到他最后返回的是一个名字叫做<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">mountComponent</code>的函数，接下来我们去看一下这个函数，这个函数定义在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/core/instance/lifecycle.js</code>这里。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  vm: Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  el: ?Element,</span></span></span><br><span class="line"><span class="function"><span class="params">  hydrating?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先这里会将<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">el</code>缓存到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm</code>中。</p>
<p>继续往下分析，我们会看到这样一段代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">  vm.$options.render = createEmptyVNode</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> ((vm.$options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">'#'</span>) ||</span><br><span class="line">        vm.$options.el || el) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">'You are using the runtime-only build of Vue where the template '</span> +</span><br><span class="line">        <span class="string">'compiler is not available. Either pre-compile the templates into '</span> +</span><br><span class="line">        <span class="string">'render functions, or use the compiler-included build.'</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">'Failed to mount component: template or render function not defined.'</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码判断的是是否有<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>，没有<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>的情况下会给<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>赋值一个空的节点，并且在不是生产环境的情况下抛出一个警告信息，为什么会存在没有<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>的情况呢，有些时候我们使用了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">runtime-only</code>版本，并且定义了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">template</code>，这个时候我们的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">runtime-only</code>版本中并没有对<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">$mount</code>方法进行重写，所以无法获取一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>。</p>
<p>这个方法中还有一些信息，我们在这里只做一些简单的介绍</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">callHook(vm, <span class="string">'beforeMount'</span>) <span class="comment">// 生命周期相关，在后续的文章中会单独进行介绍</span></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">  updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// vue提供的性能埋点系统，用以监控程序运行状态</span></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  updateComponent = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    vm._update(vm._render(), hydrating) <span class="comment">// vNode</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中与性能埋点系统相关的东西，不在我的介绍范围内，详细的可以去官网查看有关文档，我们这里要去分析<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">updateComponent</code>方法，这个方法是怎么执行的呢。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">  before () &#123;</span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;</span><br><span class="line">      callHook(vm, <span class="string">'beforeUpdate'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br></pre></td></tr></table></figure>

<p>这里通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm._render</code>方法生成一个虚拟<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">DOM</code>，在实例化一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Watcher</code>方法，在调用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">updateComponent</code>方法。</p>
<p>最终调用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">VM._update</code>方法更新<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">DOM</code>，<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Watcher</code>方法在这里有两个作用，一是用来初始化时候执行回调函数，二是在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm</code>实例中监测的数据发生改变时触发回调函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">  vm._isMounted = <span class="literal">true</span></span><br><span class="line">  callHook(vm, <span class="string">'mounted'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> vm</span><br></pre></td></tr></table></figure>

<p>函数在最后判断跟节点的时候设置为<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">true</code>，表示这个实例已经挂载了，紧跟着执行<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">mounted</code>生命周期。</p>
<p>这里值得注意的是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm.$vnode == null</code>表示<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>实例的父级的虚拟节点，所以为<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">null</code>时候表示根<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>实例。</p>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这篇文章主要讲解了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">$mount</code>和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">mountComponent</code>方法，这两个方法的逻辑也是十分清晰，它完成了整个实例化渲染<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">DOM</code>的功能。</p>
<hr>
<h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul>
<li><a color="blue" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Document/querySelector" target="_blank" rel="noopener">document.querySelector()</a></li>
<li><a color="blue" href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/outerHTML" target="_blank" rel="noopener">element.outerHTML</a></li>
</ul>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入解读vue源码（六）render</title>
    <url>/blog/2019/06/28/%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBvue%E6%BA%90%E7%A0%81%EF%BC%88%E5%85%AD%EF%BC%89render/</url>
    <content><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>所谓<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>其实是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>的一个私有方法，这个方法用来将实例<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm</code>转换成虚拟的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">node</code>，这个方法的定义在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/core/instance/render.js</code>文件中。</p>
<hr>
<h4 id="render的实现"><a href="#render的实现" class="headerlink" title="render的实现"></a>render的实现</h4><p>首先在源码中的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/core/instance/index.js</code>方法中，能够看到关于<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">renderMixin</code>这个方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">'./render'</span></span><br><span class="line">...</span><br><span class="line">renderMixin(Vue)</span><br></pre></td></tr></table></figure>

<p>通过导入我们能够找到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">renderMixin</code>方法的定义，在这个方法里面能够看到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Vue</code>原型链上的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">_render</code>这个私有方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中我们能够看到它不接收任何参数，但是它会返回一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">VNode</code>，<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">VNode</code>是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>在编译后生成的虚拟节点，又叫<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Virtual DOM</code>。</p>
<p>在这个私有方法中，我们来查看他的具体实现方式。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> vm: Component = <span class="keyword">this</span> <span class="comment">// 从this中拿到vm实例</span></span><br><span class="line"><span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options <span class="comment">// 从vm.$options中拿到render</span></span><br></pre></td></tr></table></figure>

<p>继续往下看能够看到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">_parentVnode</code>私有方法和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm.$vnode</code>的定义，这些在下一篇文章中会详细的介绍，在这里我们只需关注<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>方法。</p>
<p>对于这个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>生成的方式有两种，一种是用户自己去写一个，另一种是通过编译生成一个。继续往下看代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> vnode</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">  vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">render</code>方法调用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">call</code>方法的同时传递两个参数，这里我们要知道<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">call</code>方法的第一个参数是上下文环境，在生产环境中，这个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">call</code>方法的第一个参数代指的就是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm</code>，而<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm</code>我们就可以理解为<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">this</code>。</p>
<p>在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">call</code>方法中传递的第二个参数在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>源码中是一个方法，这个方法在当前文件的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">initRender</code>中有定义。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>) <span class="comment">// 用于自动编译生成render</span></span><br><span class="line">  vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>) <span class="comment">// 用于手动编写生成render</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">initRender</code>中，能够看到这两个方法的定义，通过观察这两个方法都是在调用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">createElement</code>方法的时候最后一个参数有所不同，通过最后一个参数的不同，决定了方法的作用不同。</p>
<p>这里我将通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>的实际使用方式来介绍什么是自动编译和手动编写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 自动生成render</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;</span><br><span class="line">  &#123;&#123;msg&#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  var app &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#app&#39;,</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        msg: &#39;Hello Vue!&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 手动编写render</span><br><span class="line">&lt;div id&#x3D;&quot;app&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">	var app &#x3D; new Vue(&#123;</span><br><span class="line">    el: &#39;#app&#39;,</span><br><span class="line">    render(createElement) &#123;</span><br><span class="line">      return createElement(&#39;div&#39;, &#123;</span><br><span class="line">        attrs: &#123;</span><br><span class="line">          id: &#39;app1&#39;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, this.msg)</span><br><span class="line">    &#125;</span><br><span class="line">    data() &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        msg: &#39;Hello Vue!&#39;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>这里有一点需要注意，在上一篇文章中，我们提到了挂载实例是会被替换掉的，所以不能挂载到标签为<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">body</code>和标签为<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">html</code>的节点上的，如下图所示，我们的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">dom</code>结构中的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">id</code>属性是为<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">app1</code>，而并不是我们之前定义好的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">app</code>。</p>
<p><img src="/blog/images/%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBvue%E6%BA%90%E7%A0%81%EF%BC%88%E5%85%AD%EF%BC%89render/1561947451568.jpg" alt=""></p>
<p>回归源码，我们通过实际编写来介绍了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">createElement</code>方法，接下来我们继续分析<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm._renderProxy</code>方法，对于这个方法的入手点，还是我们老生常谈的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/core/instance/index.js</code>这个文件，在这个文件中，能够看到这段代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">'./init'</span></span><br></pre></td></tr></table></figure>

<p>点击跳转到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/core/instance/init.js</code>文件中的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">initMixin</code>下的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">_init</code>原型链的私有方法，在介绍<a href="http://www.songjian.site/2019/06/20/%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBvue%E6%BA%90%E7%A0%81%EF%BC%88%E5%9B%9B%EF%BC%89new%20Vue/" target="_blank" rel="noopener">《深入解读vue源码（四）new Vue》</a>这篇文章的时候，我们基本了解了这个原型链的私有方法，但是还有这样一段代码我们没有分析。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  initProxy(vm) <span class="comment">// 开发环境</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  vm._renderProxy = vm <span class="comment">// 生产环境</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过对运行环境的判断来进行一些操作，对于生产环境来说<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">_renderProxy</code>就是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm</code>，我们继续分析开发环境下的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">initProxy</code>方法都做了什么。</p>
<p>首先<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">initProxy</code>方法是定义在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/core/instance/proxy.js</code>中的，在这个文件的底部，我们能看到这样的代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">initProxy = <span class="function"><span class="keyword">function</span> <span class="title">initProxy</span> (<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasProxy) &#123; <span class="comment">// 判断浏览器是否支持proxy</span></span><br><span class="line">    <span class="keyword">const</span> options = vm.$options</span><br><span class="line">    <span class="keyword">const</span> handlers = options.render &amp;&amp; options.render._withStripped</span><br><span class="line">    ? getHandler</span><br><span class="line">    : hasHandler</span><br><span class="line">    vm._renderProxy = <span class="keyword">new</span> Proxy(vm, handlers)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm._renderProxy = vm</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">hasProxy</code>来判断浏览器是否支持<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">proxy</code>，<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">proxy</code>的作用简单来讲就是对对象访问做一个劫持，在当前主流的浏览器中，基本都是支持<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">proxy</code>的，继续往下看，我们来分析下<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">getHandler</code>这个对象。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> hasHandler = &#123;</span><br><span class="line">  has (target, key) &#123;</span><br><span class="line">    <span class="keyword">const</span> has = key <span class="keyword">in</span> target <span class="comment">// 判断key在不在target中，返回布尔类型</span></span><br><span class="line">    <span class="keyword">const</span> isAllowed = allowedGlobals(key) ||</span><br><span class="line">          (<span class="keyword">typeof</span> key === <span class="string">'string'</span> &amp;&amp; key.charAt(<span class="number">0</span>) === <span class="string">'_'</span> &amp;&amp; !(key <span class="keyword">in</span> target.$data)) <span class="comment">// allowedGlobals是一些全局的属性和方法，这里是判断key是否属于allowedGlobals中的属性或方法</span></span><br><span class="line">    <span class="keyword">if</span> (!has &amp;&amp; !isAllowed) &#123; <span class="comment">// 都不满足的情况下</span></span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> target.$data) warnReservedPrefix(target, key)</span><br><span class="line">      <span class="keyword">else</span> warnNonPresent(target, key) <span class="comment">// 调用warnNonPresent函数，这个函数抛出的是一个警告</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> has || !isAllowed</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">warnNonPresent</code>有一个值得讲解的问题，首先我们来看下这个函数。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> warnNonPresent = <span class="function">(<span class="params">target, key</span>) =&gt;</span> &#123;</span><br><span class="line">  warn(</span><br><span class="line">    <span class="string">`Property or method "<span class="subst">$&#123;key&#125;</span>" is not defined on the instance but `</span> +</span><br><span class="line">    <span class="string">'referenced during render. Make sure that this property is reactive, '</span> +</span><br><span class="line">    <span class="string">'either in the data option, or for class-based components, by '</span> +</span><br><span class="line">    <span class="string">'initializing the property. '</span> +</span><br><span class="line">    <span class="string">'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.'</span>,</span><br><span class="line">    target</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数内的报错信息大家应该不会陌生，这个报错就是因为在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">template</code>中使用了一个在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>、<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">props</code>或<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">computed</code>中没有声明过的变量。</p>
<p>回到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/core/instance/render.js</code>文件中，我们继续看这段代码。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> VNode)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; <span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">'Multiple root nodes returned from render function. Render function '</span> +</span><br><span class="line">      <span class="string">'should return a single root node.'</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  vnode = createEmptyVNode()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码通过判断上面<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">try</code>、<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">catch</code>语句块中生成的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vnode</code>是否是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">VNode</code>类型，然后继续判断如果<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vnode</code>是一个数组类型则会抛出一个警告信息，如果为数组类型则代表着有多个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">VNode</code>的节点生成。</p>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm._render</code>最终是通过执行<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">createElement</code>方法并返回一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vnode</code>，它是一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Virtual DOM</code>，这个概念也是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue2</code>对比于<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue1</code>的升级点。</p>
<hr>
<h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul>
<li><a color="blue" href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">proxy</a></li>
</ul>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>深入解读vue源码（四）new Vue</title>
    <url>/blog/2019/06/20/%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBvue%E6%BA%90%E7%A0%81%EF%BC%88%E5%9B%9B%EF%BC%89new%20Vue/</url>
    <content><![CDATA[<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>这篇文章作为该系列文章中数据驱动部分的第一篇文章，将会揭开<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">new Vue</code>背后做了什么事情。</p>
<p>在此之前，我们需要理解的是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">new</code>这个关键字，<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">new</code>在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">JavaScript</code>中的作用是实例化一个对象 / 方法，所以说<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">new Vue</code>中的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Vue</code>就是一个类，一个方法。</p>
<hr>
<h4 id="vue-dist下的文件介绍"><a href="#vue-dist下的文件介绍" class="headerlink" title="vue/dist下的文件介绍"></a>vue/dist下的文件介绍</h4><p>在介绍<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">new Vue</code>之前，我们需要理解<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>编译后在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">dist</code>文件夹下的每个文件都是干什么的，这对我们在接下来的分析过程中有着至关重要的作用。同时也对在使用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue-cli</code>构建一个项目会有一定的认知。</p>
<p>首先，我们通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue-cli</code>创建一个项目的时候（v2.6.10），在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">node_modules/vue</code>文件夹下可以看到一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">dist</code>文件夹，该文件夹下面的结构是这样的，接下来我们会逐步分析每个文件的作用：</p>
<p><img src="/blog/images/%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBvue%E6%BA%90%E7%A0%81%EF%BC%88%E5%9B%9B%EF%BC%89newVue/cli-dist.jpg" alt="dist文件夹中的文件"></p>
<h5 id="README-md文件"><a href="#README-md文件" class="headerlink" title="README.md文件"></a>README.md文件</h5><p>在此文件中介绍了协议条款、Runtime+Compiler和Runtime-only、Development和Production Mode以及在常见的打包工具下面如何使用。</p>
<h5 id="vue-common-js"><a href="#vue-common-js" class="headerlink" title="vue.common.js"></a>vue.common.js</h5><p>构建方式：CommonJS、完整构建</p>
<p>打包工具：webpack1.x版本、browserify</p>
<p>打开这个文件，我们能看到以下代码，这段代码是通过区分生产环境和开发环境的不同，导入与之环境相对应的文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./vue.common.prod.js'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'./vue.common.dev.js'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="vue-esm-js"><a href="#vue-esm-js" class="headerlink" title="vue.esm.js"></a>vue.esm.js</h5><p>构建方式：ES Module、完整构建</p>
<p>打包方式：webpack2.x等版本、rollup</p>
<p>针对这个文件有一个衍生的版本vue.esm.browser.js，这个文件是针对不同浏览器做的兼容性的文件。</p>
<h5 id="vue-js"><a href="#vue-js" class="headerlink" title="vue.js"></a>vue.js</h5><p>构建方式：UMD、完整构建</p>
<p>引用方式：CDN</p>
<h5 id="vue-runtime-js"><a href="#vue-runtime-js" class="headerlink" title="vue.runtime.js"></a>vue.runtime.js</h5><p>构建方式：UMD、运行时构建（不能使用template）</p>
<p>引用方式：CDN</p>
<h5 id="vue-runtime-esm-js"><a href="#vue-runtime-esm-js" class="headerlink" title="vue.runtime.esm.js"></a>vue.runtime.esm.js</h5><p>构建方式：ES Module、运行时构建（不能使用template）</p>
<p>打包方式：webpack2.x等版本、rollup</p>
<h5 id="vue-runtime-common-js"><a href="#vue-runtime-common-js" class="headerlink" title="vue.runtime.common.js"></a>vue.runtime.common.js</h5><p>构建方式：CommonJS、运行时构建（不能使用template）</p>
<p>打包方式：webpack1.x版本、browserify</p>
<hr>
<h4 id="new-Vue做了什么"><a href="#new-Vue做了什么" class="headerlink" title="new Vue做了什么"></a>new Vue做了什么</h4><p>首先当我们通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue-cli</code>创建一个项目后，可以在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">main.js</code>文件中看到这样一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123; <span class="keyword">return</span> h(App) &#125;</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure>

<p>我们可以点击查看到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>的引入，这个文件的路径是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">node_modules/vue/dist/vue.runtime.esm.js</code>，在此之前我们简单介绍了下这个文件。</p>
<p>当然，这里的文件都是编译后产生的文件，并不是我们想要分析的源码文件，不过当你点击跳转到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue.runtime.esm.js</code>这个文件的时候你会看到这样一段代码，这段代码对应的源码文件的位置是在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/core/instance/index.js</code>，当你打开这个文件时候，你就能看到这两个文件中的对<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>方法的定义是相通的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp;</span><br><span class="line">    !(<span class="keyword">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">  ) &#123;</span><br><span class="line">    warn(<span class="string">'Vue is a constructor and should be called with the `new` keyword'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>._init(options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...Mixin(Vue) <span class="comment">// 将Vue方法类混入到一些方法中</span></span><br></pre></td></tr></table></figure>

<p>看到这的时候，可能会有些人有疑问，说为什么定义<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>这个方法类是在这里<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/core/instance/index.js</code>。我们在<a href="http://www.songjian.site/2019/05/16/%E6%B7%B1%E5%85%A5%E8%A7%A3%E8%AF%BBvue%E6%BA%90%E7%A0%81%EF%BC%88%E4%B8%89%EF%BC%89runtime-compiler%E5%85%A5%E5%8F%A3/" target="_blank" rel="noopener">《深入解读vue源码（三）runtime-compiler入口》</a>这篇文章中的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/core/index.js</code>时候已经进行介绍了，你也可以查看源码中这个文件的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">import</code>部分的代码。</p>
<p>分析上面的代码，我们能够看出当前环境不为生产环境并且在没有使用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">new</code>关键字的时候进行警告，同时继续执行<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">_init</code>方法。</p>
<p>我们通过点击可以查看到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">_init</code>方法的实现，这个方法的文件路径是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/core/instance/init.js</code>，值得注意的是下划线这个符号在编程界一半代指私有的属性或方法，不能直接被外部调用的属性或方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">_init</code>方法是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>原型链上的一个方法，这个方法做了很多的初始化工作，其中包含一个合并<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">options</code>的方法：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// merge options</span></span><br><span class="line"><span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">  <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">  <span class="comment">// since dynamic options merging is pretty slow, and none of the</span></span><br><span class="line">  <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">  initInternalComponent(vm, options)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  vm.$options = mergeOptions(</span><br><span class="line">    resolveConstructorOptions(vm.<span class="keyword">constructor</span>),</span><br><span class="line">    options || &#123;&#125;,</span><br><span class="line">    vm</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是将我们在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Vue</code>方法类中传入的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">options</code>合并到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm.$options</code>上，在通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue-cli</code>创建一个项目的时候就可以通过下面的写法能够获取到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">el</code>和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>等。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm.$options.el</span><br><span class="line">vm.$options.data</span><br></pre></td></tr></table></figure>

<p>继续往下看<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">_init</code>方法，能够看到这个方法内初始化了很多东西，如生命周期、事件等：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm._self = vm</span><br><span class="line">initLifecycle(vm) <span class="comment">// 生命周期</span></span><br><span class="line">initEvents(vm) <span class="comment">// 事件</span></span><br><span class="line">initRender(vm) <span class="comment">// render</span></span><br><span class="line">callHook(vm, <span class="string">'beforeCreate'</span>)</span><br><span class="line">initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">initState(vm) <span class="comment">//state </span></span><br><span class="line">initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">callHook(vm, <span class="string">'created'</span>)</span><br></pre></td></tr></table></figure>

<p>当初始化都做完后，再往下看就是挂载<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">el</code>，就是将<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">dom</code>结构挂载上来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">  vm.$mount(vm.$options.el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="data中的数据是如何被调用的"><a href="#data中的数据是如何被调用的" class="headerlink" title="data中的数据是如何被调用的"></a>data中的数据是如何被调用的</h4><p>这一部分作为延展来讲，在后续的文章中我会对其进行详细的介绍，在这里拿这个进行简单的举例说明是为了更好的让大家理解<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Vue</code>这个方法类中初始化的过程。</p>
<p>当我们在用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vue</code>去写项目的时候，大家都知道通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">mounted</code>、<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">methods</code>中通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">this.</code>就能调用到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>中定义的变量，接下来我们就来看看这其中有着怎样的关系。</p>
<p>首先在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">_init</code>方法中我们能够看到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">initState(vm)</code>，我们点击寻找这个方法所在文件的路径是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">src/core/instance/state.js</code>，在这个文件中找到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">initState</code>这个方法，这个方法里面根据不同的条件装载不同的方法，这些装载的方法也是在这个文件中定义的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们着重分析下装载<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>的过程，了解这个过程后也就理解了<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>的调用过程。</p>
<p>通过点击<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">initData</code>跳转到对应的方法，可以看到这个方法的实现还是比较简单的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm.$options.data</code>的形式获取到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>并将其保存起来。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">data = vm._data = <span class="keyword">typeof</span> data === <span class="string">'function'</span></span><br><span class="line">    ? getData(data, vm)</span><br><span class="line">    : data || &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码通过判断<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>是否是一个函数，并且将<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">getData</code>方法的返回值保存到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm._data</code>中。其实我们的在写一个组件的时候<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>既可以是函数也可以是对象，例如下面的这两种写法，不过官方更推荐我们使用函数形式的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	export default &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; data: &#123;&#125; 不推荐直接使用对象形式</span><br><span class="line">  &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>回归正题，当判断<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>的类型是一个函数的时候，调用了一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">getData</code>方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params">data: <span class="built_in">Function</span>, vm: Component</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// #7573 disable dep collection when invoking data getters</span></span><br><span class="line">  pushTarget()</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data.call(vm, vm)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    handleError(e, vm, <span class="string">`data()`</span>)</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    popTarget()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">pushTarget()</code>在之后的章节中会有详细的介绍，这个方法主要返回的是一个对象。</p>
<p>接下来我们继续分析<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">initData</code>这个方法。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!isPlainObject(data)) &#123;</span><br><span class="line">  data = &#123;&#125;</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">    <span class="string">'data functions should return an object:\n'</span> +</span><br><span class="line">    <span class="string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,</span><br><span class="line">    vm</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是通过判断<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>是不是一个纯粹的对象（纯粹的对象代指使用”{}”和”new”创建出来的对象），如果不是一个对象并且在不是生产环境的情况（绝大对数是在开发环境下进行警告提示）下会在控制台抛出一个警告信息。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// proxy data on instance</span></span><br><span class="line"><span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data) <span class="comment">// 保存data中的所有key</span></span><br><span class="line"><span class="keyword">const</span> props = vm.$options.props</span><br><span class="line"><span class="keyword">const</span> methods = vm.$options.methods</span><br><span class="line"><span class="keyword">let</span> i = keys.length</span><br><span class="line"><span class="keyword">while</span> (i--) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = keys[i]</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Method "<span class="subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">'production'</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`The data property "<span class="subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +</span><br><span class="line">      <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">    proxy(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码是拿到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>中对象的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">key</code>、拿到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">props</code>和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">methods</code>，通过循环对比的方式判断这个对象是否只定义了一次，简单来说就是在<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>中定义的对象不能再<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">props</code>和<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">methods</code>中进行重复的定义。之所以会有这种限制，是因为他们最后的方法和变量都是挂载到一个全局的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm</code>下，最后用户就可以通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">this</code>关键字调用变量或者方法。</p>
<p>接下来我们继续看，<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>中的数据是如何被改变和读取的，可以点击上面<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">proxy</code>方法，这个方法是通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">get</code>、<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">set</code>方法对<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>中的数据进行读写操作的。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  enumerable: <span class="literal">true</span>,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  <span class="keyword">get</span>: noop,</span><br><span class="line">  <span class="keyword">set</span>: noop</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: <span class="built_in">Object</span>, sourceKey: <span class="built_in">string</span>, key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">proxy</code>方法中通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">sharedPropertyDefinition</code>对象中定义的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">get</code>、<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">set</code>去实现一个<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">getter</code>、<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">setter</code>方法，这个方法中的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">target</code>就是传入的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">vm</code>对象。</p>
<p>值得一提的是这个方法中的<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">sourceKey</code>参数，这个参数传入的是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">_data</code>，这个参数是一个不建议我们在实际业务中使用的方法，因为它是一个内部声明的方法，我们就是通过对<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">sourceKey</code>的绑定实现了对<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>的读取和更改。</p>
<hr>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这篇文章主要讲解的是<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">new Vue</code>的时候，它的内部到底做了什么操作以及简单的讲解下<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>中声明的数据是如何被读取和修改的，至于详细的关于<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">data</code>的信息我们会在后续的文章中进行深入的讲解。</p>
<hr>
<h4 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h4><ul>
<li><a color="blue" href="https://www.ibm.com/developerworks/cn/web/1306_jiangjj_jsinstanceof/index.html" target="_blank" rel="noopener">JavaScript instanceof 运算符深入剖析</a></li>
</ul>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>详解flex布局</title>
    <url>/blog/2018/07/10/%E8%AF%A6%E8%A7%A3flex%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h4 id="一-flex介绍"><a href="#一-flex介绍" class="headerlink" title="一. flex介绍"></a>一. flex介绍</h4><p>flex简单来说就是”弹性布局“，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为一个flex容器。</p>
<p>flex可以以简便、完整、相应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全的使用这个功能。</p>
<p>关于布局传统的解决方案是基于盒状模型的，依赖display+position+float。它对于那些特殊布局非常不方便。比如，垂直居中就不容易实现。</p>
<p><img src="/blog/images/%E8%AF%A6%E8%A7%A3flex%E5%B8%83%E5%B1%80/8712d713c7d0b884a5cb9770efc422b4.jpg" alt="8712d713c7d0b884a5cb9770efc422b4"></p>
<h4 id="二-基本概念"><a href="#二-基本概念" class="headerlink" title="二. 基本概念"></a>二. 基本概念</h4><p>采用flex布局的元素我们称之为flex容器（flex container），简称“容器”。他的所有的子元素都是容器的成员（flex item），简称“项目”。</p>
<p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。</p>
<p>项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。</p>
<p><img src="/blog/images/%E8%AF%A6%E8%A7%A3flex%E5%B8%83%E5%B1%80/3791e575c48b3698be6a94ae1dbff79d.png" alt="3791e575c48b3698be6a94ae1dbff79d"></p>
<h4 id="三-如何声明flex布局"><a href="#三-如何声明flex布局" class="headerlink" title="三. 如何声明flex布局"></a>三. 如何声明flex布局</h4><p>任何一个容器都可以指定为flex布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>行内元素使用flex布局</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>webkit内核的浏览器，必须加上-webkit-前缀</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line">	<span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p style="color: red;">注意：一旦使用flex布局后，子元素的float、clear和vertical-align属性将失效。</p>



<h4 id="四-容器的六种属性"><a href="#四-容器的六种属性" class="headerlink" title="四. 容器的六种属性"></a>四. 容器的六种属性</h4><ul>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<h5 id="4-1-flex-direction属性"><a href="#4-1-flex-direction属性" class="headerlink" title="4.1 flex-direction属性"></a>4.1 flex-direction属性</h5><p>flex-derection属性决定主轴的方向（即项目的排列方向）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	row：（默认值）主轴为水平方向，起点在左端。</span></span><br><span class="line"><span class="comment">	row-reverse：主轴为水平方向，起点在右端。</span></span><br><span class="line"><span class="comment">	column：主轴为垂直方向，起点在上端。</span></span><br><span class="line"><span class="comment">	column-reverse：主轴为垂直方向，起点在下端</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="4-2-flex-wrap属性"><a href="#4-2-flex-wrap属性" class="headerlink" title="4.2 flex-wrap属性"></a>4.2 flex-wrap属性</h5><p>默认情况下，项目都会排列在一条线上。flex-wrap属性，允许我们进行项目的换行操作。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	nowrap：（默认值）不换行。</span></span><br><span class="line"><span class="comment">	wrap：换行，第一行在上方。</span></span><br><span class="line"><span class="comment">	wrap-reverse：换行，第一行在下方。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="4-3-flex-flow属性"><a href="#4-3-flex-flow属性" class="headerlink" title="4.3 flex-flow属性"></a>4.3 flex-flow属性</h5><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">flex-flow</span>: &lt;flex-direction&gt; &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	flex-direction：flex-direction可以选择的值。</span></span><br><span class="line"><span class="comment">	flex-wrap：flex-wrap可以选择的值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="4-4-justify-content属性"><a href="#4-4-justify-content属性" class="headerlink" title="4.4 justify-content属性"></a>4.4 justify-content属性</h5><p>justify-content属性定义了容器中项目在主轴上的对齐方式。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	flex-start：（默认值）左对齐。</span></span><br><span class="line"><span class="comment">	flex-end：右对齐。</span></span><br><span class="line"><span class="comment">	center：居中。</span></span><br><span class="line"><span class="comment">	space-between：两端对齐，项目之间的间隔都相等。</span></span><br><span class="line"><span class="comment">	space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="4-5-align-items属性"><a href="#4-5-align-items属性" class="headerlink" title="4.5 align-items属性"></a>4.5 align-items属性</h5><p>align-items属性定义项目在交叉轴上如何对齐。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	flex-start：交叉轴的起点对齐。</span></span><br><span class="line"><span class="comment">	flex-end：交叉轴的终点对齐。</span></span><br><span class="line"><span class="comment">	center：交叉轴的中点对齐。</span></span><br><span class="line"><span class="comment">	baseline：项目的第一行文字的基线对齐。</span></span><br><span class="line"><span class="comment">	stretch：（默认值）如果项目没有设置高度或者设为auto，将占满整个容器的高度。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="4-6-align-content属性"><a href="#4-6-align-content属性" class="headerlink" title="4.6 align-content属性"></a>4.6 align-content属性</h5><p>align-content属性定义了多根轴线的对齐方式。<p style="color:red">注意：如果项目只有一根轴线，该属性不起作用。</p></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	flex-start：与交叉轴的起点对齐。</span></span><br><span class="line"><span class="comment">	flex-end：与交叉轴的终点对齐。</span></span><br><span class="line"><span class="comment">	center：与交叉轴的中点对齐。</span></span><br><span class="line"><span class="comment">	space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</span></span><br><span class="line"><span class="comment">	space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</span></span><br><span class="line"><span class="comment">	stretch：（默认值）轴线占满整个交叉轴。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>



<h4 id="五-项目的六种属性"><a href="#五-项目的六种属性" class="headerlink" title="五. 项目的六种属性"></a>五. 项目的六种属性</h4><ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ul>
<h5 id="5-1-order属性"><a href="#5-1-order属性" class="headerlink" title="5.1 order属性"></a>5.1 order属性</h5><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">	<span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	integer：（默认值为0）可填任意整数。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="5-2-flex-grow属性"><a href="#5-2-flex-grow属性" class="headerlink" title="5.2 flex-grow属性"></a>5.2 flex-grow属性</h5><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间也不进行放大。</p>
<p style="color:red">当属性值都为1时，等分剩余空间。</p>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">	<span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-3-flex-shrink属性"><a href="#5-3-flex-shrink属性" class="headerlink" title="5.3 flex-shrink属性"></a>5.3 flex-shrink属性</h5><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，将项目进行缩小。</p>
<p style="color:red">值为负数，属性无效。当一个项目属性值为0其它项目属性值都为1时，为0的项目在空间不足的时候也不会被缩放。</p>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">	<span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-flex-basis属性"><a href="#5-4-flex-basis属性" class="headerlink" title="5.4 flex-basis属性"></a>5.4 flex-basis属性</h5><p>flex-basis属性定义了再分配多于空间之前，项目占据的主轴空间。浏览器根据这个属性计算主轴是否有多余空间。他的默认值为auto，即项目本来的大小。</p>
<p>它可以设为跟width或height属性一样的值（比如350px），则项目占据固定空间。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">	<span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-5-flex属性"><a href="#5-5-flex属性" class="headerlink" title="5.5 flex属性"></a>5.5 flex属性</h5><p>flex熟悉是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 </p>
<p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p>
<p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">	<span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-6-align-self属性"><a href="#5-6-align-self属性" class="headerlink" title="5.6 align-self属性"></a>5.6 align-self属性</h5><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 </p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">	<span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="六-总结"><a href="#六-总结" class="headerlink" title="六. 总结"></a>六. 总结</h4><p>本篇文章基本的介绍了下flex布局，总的来说flex布局已经是主流的布局方式，后续我会写一些关于flex布局的实例供大家参考，也希望大家将博客的问题通过留言的方式告诉我，我会陆续进行修改。</p>
]]></content>
      <categories>
        <category>WEB前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title>通过docker-compose统一前端团队开发环境下的node版本</title>
    <url>/blog/2019/04/09/%E9%80%9A%E8%BF%87docker-compose%E7%BB%9F%E4%B8%80%E5%89%8D%E7%AB%AF%E5%9B%A2%E9%98%9F%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84node%E7%89%88%E6%9C%AC/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在写这篇文章的时候，我一直在犹豫给它的分类划分到前端比较好，还是划分到<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">docker</code>比较好。反复分析后觉得此篇文章重在讲解使用<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">docker-compose</code>去做团队的规范、统一，他的应用领域并不局限于控制<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">node</code>的版本，它也可以去统一<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">php</code>、<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">mysql</code>、甚至是前后台的所有环境等。</p>
<hr>
<h4 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h4><blockquote>
<p>[1] 如果你在阅读中发现错误或者存在某些问题可以通过邮件的形式发送到作者的邮箱，再收到邮件后作者会及时处理这些问题。</p>
<p>[2] 阅读文章你需要了解<a href="https://yeasy.gitbooks.io/docker_practice/introduction/what.html>" target="_blank">Docker</a>、<a href="https://yeasy.gitbooks.io/docker_practice/compose/introduction.html" target="_blank">Compose</a>、<a href="https://yeasy.gitbooks.io/docker_practice/image/build.html" target="_blank">Dockerfile</a>、<a href="https://yeasy.gitbooks.io/docker_practice/basic_concept/image.html" target="_blank">Docker镜像</a>、<a href="https://yeasy.gitbooks.io/docker_practice/basic_concept/container.html" target="_blank">Docker容器以及Docker容器与传统虚拟化对比</a>。</p>
<p>[3] 阅读文章你需要了解的技术有node，需要掌握的技术有vue，docker。</p>
<p>[4] 参考资料：<a href="https://nodejs.org/zh-cn/" target="_blank">node</a>、<a href="https://cn.vuejs.org/" target="_blank">vue</a>、<a href="https://www.docker.com/" target="_blank">docker</a>可以参考官网文档，同时docker以及docker-docker-compose可以参考gitbooks上面的<a href="https://yeasy.gitbooks.io/docker_practice/" target="_blank">《Docker技术入门与实战》</a>一书。</p>
</blockquote>
<h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><ul>
<li>docker最重要的概念就是容器，容器化与虚拟化技术区别就在于虚拟硬件和完整的操作系统。</li>
<li>docker-compose最主要的作用在于对docker容器集群的快速编排。</li>
<li>docker-compose中的service代指一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>docker-compose中的project代指由一组关联的应用容器组成的一个完整业务单元，在docker-compose.yml文件中定义。</li>
</ul>
<h4 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h4><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">10.15</span> <span class="comment"># 指定node版本</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> username <span class="comment"># 指定作者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /home/website <span class="comment"># 指定容器内部的工作目录</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"yarn install ; yarn serve"</span>] <span class="comment"># 容器启动后执行的命令</span></span></span><br></pre></td></tr></table></figure>

<h4 id="编写docker-compose-yaml"><a href="#编写docker-compose-yaml" class="headerlink" title="编写docker-compose.yaml"></a>编写docker-compose.yaml</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">'3'</span> <span class="comment"># compose-file的语法版本</span></span><br><span class="line"><span class="attr">services:</span> <span class="comment"># 定义服务</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">dev-web:</span> <span class="comment"># 服务名</span></span><br><span class="line">    <span class="attr">build:</span> </span><br><span class="line">      <span class="attr">context:</span> <span class="string">.</span> <span class="comment"># 指定dockerfile所在文件夹的路径</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">./Dockerfile</span> <span class="comment"># dockerfile文件的相对路径</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">8080</span><span class="string">:8080</span> <span class="comment"># 端口映射</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./:/home/website</span> <span class="comment"># 将项目中的文件挂在到容器内部的工作目录</span></span><br></pre></td></tr></table></figure>

<h4 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker-compose build # 首次执行或者修改配置文件后执行</span><br><span class="line">docker-compose start # 启动</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>我们通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Dockerfile</code>去构建一个镜像，通过<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">docker-compose.yaml</code>文件将<code style="letter-spacing: 2px;font-weight:700;background-color:#e6effb;border-radius:3px;">Dockerfile</code>引入并且配置端口映射以及目录映射。目录映射会把我们本地的项目代码映射到容器中的工作目录，但是所有的依赖包实在容器启动后自动下载，这样就能保证团队中的代码和环境的统一。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>docker</tag>
        <tag>Dockerfile</tag>
        <tag>node</tag>
        <tag>docker-compose</tag>
      </tags>
  </entry>
  <entry>
    <title>通过配置文件修改docker容器端口映射</title>
    <url>/blog/2018/07/04/%E9%80%9A%E8%BF%87%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9docker%E5%AE%B9%E5%99%A8%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84/</url>
    <content><![CDATA[<p>对于修改docker容器端口映射，我们通常会想到将当前容器生成一个镜像，然后重新运行生成的镜像，再添加上端口的映射以达到修改端口的目的。</p>
<p>不过，还有一种方式是修改docker容器配置文件的方式去修改容器的端口映射，相比重新生成镜像来说，这种方式便捷了很多。</p>
<h5 id="关闭运行中的docker容器"><a href="#关闭运行中的docker容器" class="headerlink" title="关闭运行中的docker容器"></a>关闭运行中的docker容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker stop container_name</span><br></pre></td></tr></table></figure>

<h5 id="停止系统中运行的docker服务"><a href="#停止系统中运行的docker服务" class="headerlink" title="停止系统中运行的docker服务"></a>停止系统中运行的docker服务</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<h5 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /var/lib/docker/containers/[container_id]/hostconfig.json</span><br><span class="line"><span class="meta">#</span><span class="bash"> container_id为容器id</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">"4000/tcp": [ </span><br><span class="line">&#123;</span><br><span class="line"> "HostIp": "0.0.0.0",</span><br><span class="line"> "HostPort": "80"</span><br><span class="line"> &#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 4000端口为容器内端口，80为实体机端口</span></span><br></pre></td></tr></table></figure>

<h5 id="修改完成后重启docker服务和docker容器"><a href="#修改完成后重启docker服务和docker容器" class="headerlink" title="修改完成后重启docker服务和docker容器"></a>修改完成后重启docker服务和docker容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line">docker start container_name</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
